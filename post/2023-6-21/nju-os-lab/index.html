<!doctype html><html lang=en><head><meta charset=UTF-8><title>NJU-OS-Lab总结 | Zhytou</title>
<meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Hugo 0.123.8"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><meta property="og:title" content="NJU-OS-Lab总结"><meta property="og:description" content="M1：实现打印进程树状信息的工具 pstree 这个实验整体比较简单，就是去遍历/proc目录下所有数字开头的子目录，通过读取其中的status文件获取它们的进程号、父进程号和名称。我是先将这些信息存在链表中，读取完之后再将链表转换为树，进而格式化打印。
唯一可能要注意的是，得给存放进程名称的char数组长度给够，否则容易出错。
#include <assert.h> #include <dirent.h> #include <memory.h> #include <stdarg.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/stat.h> // 树状节点用于存储进程信息 typedef struct TreeNode { int id; char name[64]; struct TreeNode **children; int num; } TreeNode; // 释放树节点内存 void freeTreeNode(TreeNode *node, int recursive_flag) { if (node != NULL) { // 由于所有的树节点实际是连续存放在一起的，因此只需要递归的释放存储子节点地址的children指针即可。 for (int i = 0; i < node->num; i++) { freeTreeNode(node->children[i], recursive_flag); } free(node->children); node->children = NULL; } } // 查找数组中ID为id的元素序号 int findId(TreeNode *arr, int len, int id) { for (int i = 0; i < len; i++) { if (arr[i]."><meta property="og:type" content="article"><meta property="og:url" content="https://zhytou.github.io/post/2023-6-21/nju-os-lab/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-06-21T16:42:31+08:00"><meta property="article:modified_time" content="2023-06-21T16:42:31+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NJU-OS-Lab总结"><meta name=twitter:description content="M1：实现打印进程树状信息的工具 pstree 这个实验整体比较简单，就是去遍历/proc目录下所有数字开头的子目录，通过读取其中的status文件获取它们的进程号、父进程号和名称。我是先将这些信息存在链表中，读取完之后再将链表转换为树，进而格式化打印。
唯一可能要注意的是，得给存放进程名称的char数组长度给够，否则容易出错。
#include <assert.h> #include <dirent.h> #include <memory.h> #include <stdarg.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/stat.h> // 树状节点用于存储进程信息 typedef struct TreeNode { int id; char name[64]; struct TreeNode **children; int num; } TreeNode; // 释放树节点内存 void freeTreeNode(TreeNode *node, int recursive_flag) { if (node != NULL) { // 由于所有的树节点实际是连续存放在一起的，因此只需要递归的释放存储子节点地址的children指针即可。 for (int i = 0; i < node->num; i++) { freeTreeNode(node->children[i], recursive_flag); } free(node->children); node->children = NULL; } } // 查找数组中ID为id的元素序号 int findId(TreeNode *arr, int len, int id) { for (int i = 0; i < len; i++) { if (arr[i]."><meta itemprop=name content="NJU-OS-Lab总结"><meta itemprop=description content="M1：实现打印进程树状信息的工具 pstree 这个实验整体比较简单，就是去遍历/proc目录下所有数字开头的子目录，通过读取其中的status文件获取它们的进程号、父进程号和名称。我是先将这些信息存在链表中，读取完之后再将链表转换为树，进而格式化打印。
唯一可能要注意的是，得给存放进程名称的char数组长度给够，否则容易出错。
#include <assert.h> #include <dirent.h> #include <memory.h> #include <stdarg.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/stat.h> // 树状节点用于存储进程信息 typedef struct TreeNode { int id; char name[64]; struct TreeNode **children; int num; } TreeNode; // 释放树节点内存 void freeTreeNode(TreeNode *node, int recursive_flag) { if (node != NULL) { // 由于所有的树节点实际是连续存放在一起的，因此只需要递归的释放存储子节点地址的children指针即可。 for (int i = 0; i < node->num; i++) { freeTreeNode(node->children[i], recursive_flag); } free(node->children); node->children = NULL; } } // 查找数组中ID为id的元素序号 int findId(TreeNode *arr, int len, int id) { for (int i = 0; i < len; i++) { if (arr[i]."><meta itemprop=datePublished content="2023-06-21T16:42:31+08:00"><meta itemprop=dateModified content="2023-06-21T16:42:31+08:00"><meta itemprop=wordCount content="2593"><meta itemprop=keywords content></head><body><header><div id=avatar><a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a></div><div id=titletext><h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2></div><div id=title-description><p id=subtitle>May the force be with me.</p><div id=social><nav><ul><li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li><li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>Posts</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>21</span>
<span class=rest>Jun 2023</span></div></div><div class=matter><h1 class=title>NJU-OS-Lab总结</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><h2 id=m1实现打印进程树状信息的工具-pstree>M1：实现打印进程树状信息的工具 pstree</h2><p>这个实验整体比较简单，就是去遍历/proc目录下所有数字开头的子目录，通过读取其中的status文件获取它们的进程号、父进程号和名称。我是先将这些信息存在链表中，读取完之后再将链表转换为树，进而格式化打印。</p><p>唯一可能要注意的是，得给存放进程名称的char数组长度给够，否则容易出错。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;assert.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;dirent.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;memory.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;stdarg.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;stdio.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;stdlib.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;string.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579>#include</span> <span style=color:#579>&lt;sys/stat.h&gt;</span><span style=color:#579>
</span></span></span><span style=display:flex><span><span style=color:#579></span>
</span></span><span style=display:flex><span><span style=color:#888>// 树状节点用于存储进程信息
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>typedef</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>TreeNode</span> {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> id;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>char</span> name[<span style=color:#00d;font-weight:700>64</span>];
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>TreeNode</span> <span style=color:#333>**</span>children;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> num;
</span></span><span style=display:flex><span>} TreeNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 释放树节点内存
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>freeTreeNode</span>(TreeNode <span style=color:#333>*</span>node, <span style=color:#339;font-weight:700>int</span> recursive_flag) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (node <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 由于所有的树节点实际是连续存放在一起的，因此只需要递归的释放存储子节点地址的children指针即可。
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> node<span style=color:#333>-&gt;</span>num; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>      freeTreeNode(node<span style=color:#333>-&gt;</span>children[i], recursive_flag);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    free(node<span style=color:#333>-&gt;</span>children);
</span></span><span style=display:flex><span>    node<span style=color:#333>-&gt;</span>children <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 查找数组中ID为id的元素序号
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>findId</span>(TreeNode <span style=color:#333>*</span>arr, <span style=color:#339;font-weight:700>int</span> len, <span style=color:#339;font-weight:700>int</span> id) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> len; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (arr[i].id <span style=color:#333>==</span> id) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>return</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 按Id从小到大排序子树节点
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sortTreeNode</span>(TreeNode <span style=color:#333>*</span>node, <span style=color:#339;font-weight:700>int</span> recursive_flag) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (node <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (recursive_flag) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> node<span style=color:#333>-&gt;</span>num; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>        sortTreeNode(node<span style=color:#333>-&gt;</span>children[i], recursive_flag);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> node<span style=color:#333>-&gt;</span>num; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> j <span style=color:#333>=</span> i <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>1</span>; j <span style=color:#333>&lt;</span> node<span style=color:#333>-&gt;</span>num; j<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (node<span style=color:#333>-&gt;</span>children[i]<span style=color:#333>-&gt;</span>id <span style=color:#333>&gt;</span> node<span style=color:#333>-&gt;</span>children[j]<span style=color:#333>-&gt;</span>id) {
</span></span><span style=display:flex><span>          TreeNode <span style=color:#333>*</span>tmp <span style=color:#333>=</span> node<span style=color:#333>-&gt;</span>children[i];
</span></span><span style=display:flex><span>          node<span style=color:#333>-&gt;</span>children[i] <span style=color:#333>=</span> node<span style=color:#333>-&gt;</span>children[j];
</span></span><span style=display:flex><span>          node<span style=color:#333>-&gt;</span>children[j] <span style=color:#333>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 链表节点用于遍历文件夹是存储信息
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>typedef</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>ListNode</span> {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> pid;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> ppid;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>char</span> name[<span style=color:#00d;font-weight:700>64</span>];
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>ListNode</span> <span style=color:#333>*</span>next;
</span></span><span style=display:flex><span>} ListNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 构造新链表节点
</span></span></span><span style=display:flex><span><span style=color:#888></span>ListNode <span style=color:#333>*</span><span style=color:#06b;font-weight:700>newListNode</span>(<span style=color:#339;font-weight:700>int</span> pid, <span style=color:#339;font-weight:700>int</span> ppid, <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>name) {
</span></span><span style=display:flex><span>  ListNode <span style=color:#333>*</span>node <span style=color:#333>=</span> (ListNode <span style=color:#333>*</span>)malloc(<span style=color:#080;font-weight:700>sizeof</span>(ListNode));
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (node <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    dPrintf(<span style=background-color:#fff0f0>&#34;newListNode: malloc failed</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  node<span style=color:#333>-&gt;</span>pid <span style=color:#333>=</span> pid;
</span></span><span style=display:flex><span>  node<span style=color:#333>-&gt;</span>ppid <span style=color:#333>=</span> ppid;
</span></span><span style=display:flex><span>  strcpy(node<span style=color:#333>-&gt;</span>name, name);
</span></span><span style=display:flex><span>  node<span style=color:#333>-&gt;</span>next <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> node;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 删除链表节点
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>freeListNode</span>(ListNode <span style=color:#333>*</span>node, <span style=color:#339;font-weight:700>int</span> recursive_flag) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (node <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    freeListNode(node<span style=color:#333>-&gt;</span>next, recursive_flag);
</span></span><span style=display:flex><span>    free(node);
</span></span><span style=display:flex><span>    node <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 遍历/proc文件夹，并返回进程数
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>traverseProc</span>(ListNode <span style=color:#333>*</span>dummy) {
</span></span><span style=display:flex><span>  DIR <span style=color:#333>*</span>dir;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>dirent</span> <span style=color:#333>*</span>entry;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>stat</span> statbuf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 打开目录
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>if</span> ((dir <span style=color:#333>=</span> opendir(<span style=background-color:#fff0f0>&#34;/proc&#34;</span>)) <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    fprintf(stderr, <span style=background-color:#fff0f0>&#34;Cannot open directory: %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, <span style=background-color:#fff0f0>&#34;/proc&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> ret <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#888>// 读取目录内容
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>while</span> ((entry <span style=color:#333>=</span> readdir(dir)) <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 获取文件或目录的信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>    lstat(entry<span style=color:#333>-&gt;</span>d_name, <span style=color:#333>&amp;</span>statbuf);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (S_ISDIR(statbuf.st_mode)) {
</span></span><span style=display:flex><span>      <span style=color:#888>// 子目录为.或..直接跳过
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#080;font-weight:700>if</span> (strcmp(<span style=background-color:#fff0f0>&#34;.&#34;</span>, entry<span style=color:#333>-&gt;</span>d_name) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span> <span style=color:#333>||</span> strcmp(<span style=background-color:#fff0f0>&#34;..&#34;</span>, entry<span style=color:#333>-&gt;</span>d_name) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#888>// 判断子目录是否为数字目录
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#339;font-weight:700>int</span> is_num <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> <span style=color:#00d;font-weight:700>256</span> <span style=color:#333>&amp;&amp;</span> entry<span style=color:#333>-&gt;</span>d_name[i] <span style=color:#333>!=</span> <span style=color:#04d;background-color:#fff0f0>&#39;\0&#39;</span>; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (entry<span style=color:#333>-&gt;</span>d_name[i] <span style=color:#333>&lt;</span> <span style=color:#04d;background-color:#fff0f0>&#39;0&#39;</span> <span style=color:#333>||</span> entry<span style=color:#333>-&gt;</span>d_name[i] <span style=color:#333>&gt;</span> <span style=color:#04d;background-color:#fff0f0>&#39;9&#39;</span>) {
</span></span><span style=display:flex><span>          is_num <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (is_num <span style=color:#333>!=</span> <span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#888>// 如果是数字目录，则读取/proc/pid/status文件
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#339;font-weight:700>char</span> path[<span style=color:#00d;font-weight:700>256</span>];
</span></span><span style=display:flex><span>      strcpy(path, <span style=background-color:#fff0f0>&#34;/proc/&#34;</span>);
</span></span><span style=display:flex><span>      strcat(path, entry<span style=color:#333>-&gt;</span>d_name);
</span></span><span style=display:flex><span>      strcat(path, <span style=background-color:#fff0f0>&#34;/status&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      FILE <span style=color:#333>*</span>fp <span style=color:#333>=</span> fopen(path, <span style=background-color:#fff0f0>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (<span style=color:#333>!</span>fp) {
</span></span><span style=display:flex><span>        <span style=color:#888>// 错误处理
</span></span></span><span style=display:flex><span><span style=color:#888></span>        dPrintf(<span style=background-color:#fff0f0>&#34;traverseProc: cannot open file: %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, path);
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#888>// 读取Name和PPid
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#339;font-weight:700>char</span> buf[<span style=color:#00d;font-weight:700>256</span>];
</span></span><span style=display:flex><span>      ListNode <span style=color:#333>*</span>node <span style=color:#333>=</span> newListNode(atoi(entry<span style=color:#333>-&gt;</span>d_name), <span style=color:#00d;font-weight:700>0</span>, <span style=background-color:#fff0f0>&#34;&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>while</span> (fgets(buf, <span style=color:#080;font-weight:700>sizeof</span>(buf), fp)) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (strncmp(buf, <span style=background-color:#fff0f0>&#34;Name:&#34;</span>, <span style=color:#00d;font-weight:700>5</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>          <span style=color:#339;font-weight:700>int</span> pos <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>5</span>;
</span></span><span style=display:flex><span>          <span style=color:#888>// 去除Name开头可能的\b或\t
</span></span></span><span style=display:flex><span><span style=color:#888></span>          <span style=color:#080;font-weight:700>while</span> (pos <span style=color:#333>&lt;</span> <span style=color:#080;font-weight:700>sizeof</span>(buf) <span style=color:#333>&amp;&amp;</span> (buf[pos] <span style=color:#333>==</span> <span style=color:#04d;background-color:#fff0f0>&#39; &#39;</span> <span style=color:#333>||</span> buf[pos] <span style=color:#333>==</span> <span style=color:#04d;background-color:#fff0f0>&#39;\t&#39;</span>)) {
</span></span><span style=display:flex><span>            pos <span style=color:#333>+=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          strcpy(node<span style=color:#333>-&gt;</span>name, buf <span style=color:#333>+</span> pos);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#888>// 去除Name末尾可能的\n或\r
</span></span></span><span style=display:flex><span><span style=color:#888></span>          <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> <span style=color:#080;font-weight:700>sizeof</span>(node<span style=color:#333>-&gt;</span>name); i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>if</span> (node<span style=color:#333>-&gt;</span>name[i] <span style=color:#333>==</span> <span style=color:#04d;background-color:#fff0f0>&#39;\n&#39;</span> <span style=color:#333>||</span> node<span style=color:#333>-&gt;</span>name[i] <span style=color:#333>==</span> <span style=color:#04d;background-color:#fff0f0>&#39;\r&#39;</span>) {
</span></span><span style=display:flex><span>              node<span style=color:#333>-&gt;</span>name[i] <span style=color:#333>=</span> <span style=color:#04d;background-color:#fff0f0>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>              <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        } <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> (strncmp(buf, <span style=background-color:#fff0f0>&#34;PPid:&#34;</span>, <span style=color:#00d;font-weight:700>5</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>          <span style=color:#339;font-weight:700>int</span> pos <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>5</span>;
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>while</span> (pos <span style=color:#333>&lt;</span> <span style=color:#080;font-weight:700>sizeof</span>(buf) <span style=color:#333>&amp;&amp;</span> buf[pos] <span style=color:#333>==</span> <span style=color:#04d;background-color:#fff0f0>&#39; &#39;</span>) {
</span></span><span style=display:flex><span>            pos <span style=color:#333>+=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          node<span style=color:#333>-&gt;</span>ppid <span style=color:#333>=</span> atoi(buf <span style=color:#333>+</span> pos);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#888>// 将新节点插入链表中
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#080;font-weight:700>if</span> (dummy<span style=color:#333>-&gt;</span>next <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>        node<span style=color:#333>-&gt;</span>next <span style=color:#333>=</span> dummy<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      dummy<span style=color:#333>-&gt;</span>next <span style=color:#333>=</span> node;
</span></span><span style=display:flex><span>      ret <span style=color:#333>+=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>      fclose(fp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 关闭目录
</span></span></span><span style=display:flex><span><span style=color:#888></span>  closedir(dir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 返回进程数量
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 根据链表构造树
</span></span></span><span style=display:flex><span><span style=color:#888></span>TreeNode <span style=color:#333>*</span><span style=color:#06b;font-weight:700>constructTree</span>(<span style=color:#339;font-weight:700>int</span> len, TreeNode <span style=color:#333>*</span>treeArr, ListNode <span style=color:#333>*</span>head,
</span></span><span style=display:flex><span>                        <span style=color:#339;font-weight:700>int</span> numeric_sort) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (len <span style=color:#333>&lt;=</span> <span style=color:#00d;font-weight:700>0</span> <span style=color:#333>||</span> treeArr <span style=color:#333>==</span> <span style=color:#007020>NULL</span> <span style=color:#333>||</span> head <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    dPrintf(<span style=background-color:#fff0f0>&#34;constructTree: invalid arguments</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#888>// Info用于储存每个树节点有几个子节点
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>typedef</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>Info</span> {
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>int</span> id;
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>int</span> num;
</span></span><span style=display:flex><span>  } Info;
</span></span><span style=display:flex><span>  <span style=color:#888>// 初始化 infoArr
</span></span></span><span style=display:flex><span><span style=color:#888></span>  Info <span style=color:#333>*</span>infoArr <span style=color:#333>=</span> (Info <span style=color:#333>*</span>)malloc(<span style=color:#080;font-weight:700>sizeof</span>(Info) <span style=color:#333>*</span> (len <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>1</span>));
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (infoArr <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  memset(infoArr, <span style=color:#00d;font-weight:700>0</span>, <span style=color:#080;font-weight:700>sizeof</span>(Info) <span style=color:#333>*</span> (<span style=color:#00d;font-weight:700>1</span> <span style=color:#333>+</span> len));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 遍历链表，初始化树节点
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>int</span> t <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>  ListNode <span style=color:#333>*</span>p <span style=color:#333>=</span> head;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>while</span> (t <span style=color:#333>&lt;</span> len <span style=color:#333>&amp;&amp;</span> p <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    treeArr[t].id <span style=color:#333>=</span> p<span style=color:#333>-&gt;</span>pid;
</span></span><span style=display:flex><span>    strcpy(treeArr[t].name, p<span style=color:#333>-&gt;</span>name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;=</span> len; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (infoArr[i].id <span style=color:#333>==</span> p<span style=color:#333>-&gt;</span>ppid) {
</span></span><span style=display:flex><span>        infoArr[i].num <span style=color:#333>+=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (infoArr[i].id <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span> <span style=color:#333>&amp;&amp;</span> infoArr[i].num <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>        infoArr[i].id <span style=color:#333>=</span> p<span style=color:#333>-&gt;</span>ppid;
</span></span><span style=display:flex><span>        infoArr[i].num <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    p <span style=color:#333>=</span> p<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>    t <span style=color:#333>+=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 根据infoArr，给每个树节点children分配内存
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;=</span> len; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (infoArr[i].id <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> t <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; t <span style=color:#333>&lt;</span> len; t<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (infoArr[i].id <span style=color:#333>==</span> treeArr[t].id) {
</span></span><span style=display:flex><span>        treeArr[t].num <span style=color:#333>=</span> infoArr[i].num;
</span></span><span style=display:flex><span>        treeArr[t].children <span style=color:#333>=</span>
</span></span><span style=display:flex><span>            (TreeNode <span style=color:#333>**</span>)malloc(<span style=color:#080;font-weight:700>sizeof</span>(TreeNode <span style=color:#333>*</span>) <span style=color:#333>*</span> infoArr[i].num);
</span></span><span style=display:flex><span>        memset(treeArr[t].children, <span style=color:#00d;font-weight:700>0</span>, <span style=color:#080;font-weight:700>sizeof</span>(TreeNode <span style=color:#333>*</span>) <span style=color:#333>*</span> infoArr[i].num);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 按父子关系，构造树
</span></span></span><span style=display:flex><span><span style=color:#888></span>  p <span style=color:#333>=</span> head;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>while</span> (p <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (p<span style=color:#333>-&gt;</span>ppid <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>      p <span style=color:#333>=</span> p<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>int</span> parent_idx <span style=color:#333>=</span> findId(treeArr, len, p<span style=color:#333>-&gt;</span>ppid);
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>int</span> child_idx <span style=color:#333>=</span> findId(treeArr, len, p<span style=color:#333>-&gt;</span>pid);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (parent_idx <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span> <span style=color:#333>||</span> child_idx <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>      dPrintf(
</span></span><span style=display:flex><span>          <span style=background-color:#fff0f0>&#34;findId: fail to find a node,{ppid: %d, parent_idx: %d, pid: %d, &#34;</span>
</span></span><span style=display:flex><span>          <span style=background-color:#fff0f0>&#34;child_idx: %d}</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>,
</span></span><span style=display:flex><span>          p<span style=color:#333>-&gt;</span>ppid, parent_idx, p<span style=color:#333>-&gt;</span>pid, child_idx);
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> treeArr[parent_idx].num; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (treeArr[parent_idx].children[i] <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>        treeArr[parent_idx].children[i] <span style=color:#333>=</span> treeArr <span style=color:#333>+</span> child_idx;
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    p <span style=color:#333>=</span> p<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 找到根节点并返回
</span></span></span><span style=display:flex><span><span style=color:#888></span>  TreeNode <span style=color:#333>*</span>root <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (findId(treeArr, len, <span style=color:#00d;font-weight:700>1</span>) <span style=color:#333>!=</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    root <span style=color:#333>=</span> treeArr <span style=color:#333>+</span> findId(treeArr, len, <span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 若numeric_sort为真，则需要每个树节点中子节点按id排序
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>if</span> (numeric_sort) {
</span></span><span style=display:flex><span>    sortTreeNode(root, <span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> root;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 打印树状进程信息
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>printInfo</span>(TreeNode <span style=color:#333>*</span>root, <span style=color:#339;font-weight:700>int</span> level, <span style=color:#339;font-weight:700>int</span> show_pids) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (root <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    dPrintf(<span style=background-color:#fff0f0>&#34;printInfo: root is NULL!</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> level; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>    printf(<span style=background-color:#fff0f0>&#34;</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\t</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (show_pids) {
</span></span><span style=display:flex><span>    printf(<span style=background-color:#fff0f0>&#34;%s(%d)&#34;</span>, root<span style=color:#333>-&gt;</span>name, root<span style=color:#333>-&gt;</span>id);
</span></span><span style=display:flex><span>  } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    printf(<span style=background-color:#fff0f0>&#34;%s&#34;</span>, root<span style=color:#333>-&gt;</span>name);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> root<span style=color:#333>-&gt;</span>num; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>    printf(<span style=background-color:#fff0f0>&#34;</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\r\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    printInfo(root<span style=color:#333>-&gt;</span>children[i], level <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>1</span>, show_pids);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>(<span style=color:#339;font-weight:700>int</span> argc, <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>argv[]) {
</span></span><span style=display:flex><span>  <span style=color:#888>// 获取命令行参数
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>int</span> show_pids <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>, numeric_sort <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>, version <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>&lt;</span> argc; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>    assert(argv[i]);
</span></span><span style=display:flex><span>    dPrintf(<span style=background-color:#fff0f0>&#34;argv[%d] = %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, i, argv[i]);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (strcmp(argv[i], <span style=background-color:#fff0f0>&#34;-p&#34;</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span> <span style=color:#333>||</span> strcmp(argv[i], <span style=background-color:#fff0f0>&#34;--show-pids&#34;</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>      show_pids <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (strcmp(argv[i], <span style=background-color:#fff0f0>&#34;-n&#34;</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span> <span style=color:#333>||</span> strcmp(argv[i], <span style=background-color:#fff0f0>&#34;--numeric-sort&#34;</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>      numeric_sort <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (strcmp(argv[i], <span style=background-color:#fff0f0>&#34;-V&#34;</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span> <span style=color:#333>||</span> strcmp(argv[i], <span style=background-color:#fff0f0>&#34;--version&#34;</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>      version <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  assert(<span style=color:#333>!</span>argv[argc]);
</span></span><span style=display:flex><span>  <span style=color:#888>// 若打印版本信息，则打印完版本信息后直接返回
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#888>// 反之，则显示当前线程信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>if</span> (version <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    printf(
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;NanJing University Operating System Mini Lab1 1.0.0 \
</span></span></span><span style=display:flex><span><span style=background-color:#fff0f0>         Copyright (C) 1993-2020  Zhytou</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ListNode <span style=color:#333>*</span>dummy <span style=color:#333>=</span> newListNode(<span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>, <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>, <span style=background-color:#fff0f0>&#34;&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#888>// 遍历/proc获取进程信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>int</span> len <span style=color:#333>=</span> traverseProc(dummy);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 初始化 treeArr
</span></span></span><span style=display:flex><span><span style=color:#888></span>  TreeNode <span style=color:#333>*</span>treeArr <span style=color:#333>=</span> (TreeNode <span style=color:#333>*</span>)malloc(<span style=color:#080;font-weight:700>sizeof</span>(TreeNode) <span style=color:#333>*</span> len);
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (treeArr <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    dPrintf(<span style=background-color:#fff0f0>&#34;main: fail to malloc treeArr!</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  memset(treeArr, <span style=color:#00d;font-weight:700>0</span>, <span style=color:#080;font-weight:700>sizeof</span>(TreeNode) <span style=color:#333>*</span> len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 构造树状进程信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>  TreeNode <span style=color:#333>*</span>root <span style=color:#333>=</span> constructTree(len, treeArr, dummy<span style=color:#333>-&gt;</span>next, numeric_sort);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 格式化打印信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>  printInfo(root, <span style=color:#00d;font-weight:700>0</span>, show_pids);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// 释放内存
</span></span></span><span style=display:flex><span><span style=color:#888></span>  freeListNode(dummy, <span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>  freeTreeNode(root, <span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>  free(treeArr);
</span></span><span style=display:flex><span>  treeArr <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=m2实现协程库-libco>M2：实现协程库 libco</h2><h3 id=协程>协程</h3><p><strong>理解协程</strong>：</p><p>在开始做本实验之前，我认为可以先阅读一些材料来认识进程、线程和协程之间的关系，比如这一篇<a href=https://www.linkedin.com/pulse/process-thread-coroutines-amit-nadiger/ target=_blank>Process , Thread and Coroutines</a>。当我们能够认识到协程其实就是调度由用户管理的轻量级线程，即：用户态线程时，实验说明中的大部分内容就很好理解了。</p><p>至于协程结构体，则可以直接使用实验讲义中给出的，具体如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888>// 协程状态
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>enum</span> co_status {
</span></span><span style=display:flex><span>  CO_NEW <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>,  <span style=color:#888>// 新创建，还未执行过
</span></span></span><span style=display:flex><span><span style=color:#888></span>  CO_RUNNING,  <span style=color:#888>// 已经执行过
</span></span></span><span style=display:flex><span><span style=color:#888></span>  CO_WAITING,  <span style=color:#888>// 在 co_wait 上等待
</span></span></span><span style=display:flex><span><span style=color:#888></span>  CO_DEAD,     <span style=color:#888>// 已经结束，但还未释放资源
</span></span></span><span style=display:flex><span><span style=color:#888></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 协程
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>struct</span> <span style=color:#06b;font-weight:700>__attribute__</span>((<span style=color:#06b;font-weight:700>aligned</span>(<span style=color:#00d;font-weight:700>16</span>))) co {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>name;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>void</span> (<span style=color:#333>*</span>func)(<span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>);  <span style=color:#888>// co_start 指定的入口地址和参数
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>arg;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>enum</span> co_status status;  <span style=color:#888>// 协程的状态
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>struct</span> co <span style=color:#333>*</span>waiter;      <span style=color:#888>// 是否有其他协程在等待当前协程
</span></span></span><span style=display:flex><span><span style=color:#888></span>  jmp_buf context;        <span style=color:#888>// 寄存器现场 (setjmp.h)
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>unsigned</span> <span style=color:#339;font-weight:700>char</span> stack[STACK_SIZE];  <span style=color:#888>// 协程的堆栈
</span></span></span><span style=display:flex><span><span style=color:#888></span>};
</span></span></code></pre></div><p><strong>管理协程</strong>：</p><p>libco中应该记录当前执行协程以及当前所有协程，以便选择协程切换和保存当前协程状态。其中，我用来记录所有协程的数据结构是链表，实现如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888>// 当前运行协程，默认是main
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>struct</span> co <span style=color:#333>*</span>current <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 当前所有协程表
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>struct</span> co_mgr_node <span style=color:#333>*</span>co_mgr_head <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 协程管理，用链表存储当前上下文所有协程
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>struct</span> co_mgr_node {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> co <span style=color:#333>*</span>val;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> co_mgr_node <span style=color:#333>*</span>next;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>资源初始化和释放</strong>：</p><p>定义<code>__attribute__((constructor))</code>属性和<code>__attribute__((destructor))</code>属性的函数，保证在main函数执行之前正确初始化资源，在main函数 结束之后释放资源。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888>// co_mgr_head和current初始化，main函数执行前调用
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>static</span> <span style=color:#06b;font-weight:700>__attribute__</span>((constructor)) <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>co_constructor</span>(<span style=color:#339;font-weight:700>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#888>// 创建主线程，并将其加入到协程管理表中
</span></span></span><span style=display:flex><span><span style=color:#888></span>  current <span style=color:#333>=</span> <span style=color:#06b;font-weight:700>co_start</span>(<span style=background-color:#fff0f0>&#34;main&#34;</span>, <span style=color:#007020>NULL</span>, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (current <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>debug_printf</span>(<span style=background-color:#fff0f0>&#34;co_start main failed</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  current<span style=color:#333>-&gt;</span>status <span style=color:#333>=</span> CO_RUNNING;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// co_mgr_head和current释放，main函数执行后调用
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>static</span> <span style=color:#06b;font-weight:700>__attribute__</span>((destructor)) <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>co_destructor</span>(<span style=color:#339;font-weight:700>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> co_mgr_node <span style=color:#333>*</span>curr <span style=color:#333>=</span> co_mgr_head;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>while</span> (curr <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>struct</span> co_mgr_node <span style=color:#333>*</span>next <span style=color:#333>=</span> curr<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>free</span>(curr<span style=color:#333>-&gt;</span>val);
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>free</span>(curr);
</span></span><span style=display:flex><span>    curr <span style=color:#333>=</span> next;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  co_mgr_head <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>  current <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=上下文切换>上下文切换</h3><p><strong>理解setjmp/logjmp</strong>：</p><p>setjmp和longjmp是C语言中的非局部跳转函数，它可以实现函数间的非顺序调用。其中，setjmp的功能是:</p><ul><li>保存当前函数的执行环境/寄存器状态到jmp_buf结构体数据类型变量中</li><li>函数返回值为0
longjmp的功能是:</li></ul><p>根据jmp_buf结构体数据跳到之前使用setjmp保存的函数环境中
参数决定返回值是否为0</p><p><strong>实现co_field</strong>：</p><p>setjmp和longjmp是C语言提供的非局部跳转机制。一般来说，使用它们实现跳转的方法如下：</p><ul><li>使用setjmp保存当前执行环境到jmp_buf，然后默认返回0。</li><li>程序继续执行，到某个地方调用longjmp，传入上面保存的jmp_buf，以及另一个值。</li><li>此时执行点又回到调用setjmp的返回处，且返回值变成longjmp设置的值。</li></ul><p>在理解了setjmp/logjmp的作用之后实现上下文切换就很容易了，具体实现如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888>// 切换协程
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>co_yield</span> () {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> ret <span style=color:#333>=</span> <span style=color:#06b;font-weight:700>setjmp</span>(current<span style=color:#333>-&gt;</span>context);
</span></span><span style=display:flex><span>  <span style=color:#888>// 若ret为0，即为第一次设置jmp_buf（可以使用longjmp函数恢复寄存器状态），切换到一个新建或运行中的协程执行
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#888>// 否则为longjmp函数调用，直接返回
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#080;font-weight:700>if</span> (ret <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 找到一个可以切换的协程
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#080;font-weight:700>struct</span> co <span style=color:#333>*</span>co <span style=color:#333>=</span> <span style=color:#06b;font-weight:700>get_random_available_co</span>(co_mgr_head);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (co<span style=color:#333>-&gt;</span>status <span style=color:#333>==</span> CO_NEW) {
</span></span><span style=display:flex><span>      <span style=color:#888>// 切换上下文，执行current-&gt;func
</span></span></span><span style=display:flex><span><span style=color:#888></span>      ((<span style=color:#080;font-weight:700>volatile</span> <span style=color:#080;font-weight:700>struct</span> co <span style=color:#333>*</span>)co)<span style=color:#333>-&gt;</span>status <span style=color:#333>=</span> CO_RUNNING;
</span></span><span style=display:flex><span>      <span style=color:#06b;font-weight:700>stack_switch_call</span>(co<span style=color:#333>-&gt;</span>stack <span style=color:#333>+</span> STACK_SIZE, co<span style=color:#333>-&gt;</span>func, co<span style=color:#333>-&gt;</span>arg);
</span></span><span style=display:flex><span>      <span style=color:#888>// 恢复寄存器状态
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#06b;font-weight:700>restore_registers_call</span>();
</span></span><span style=display:flex><span>      ((<span style=color:#080;font-weight:700>volatile</span> <span style=color:#080;font-weight:700>struct</span> co <span style=color:#333>*</span>)co)<span style=color:#333>-&gt;</span>status <span style=color:#333>=</span> CO_DEAD;
</span></span><span style=display:flex><span>      <span style=color:#888>// 修改等待协程的状态
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#080;font-weight:700>if</span> (co<span style=color:#333>-&gt;</span>waiter <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>        co<span style=color:#333>-&gt;</span>waiter<span style=color:#333>-&gt;</span>status <span style=color:#333>=</span> CO_RUNNING;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#888>//
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#06b;font-weight:700>co_yield</span> ();
</span></span><span style=display:flex><span>    } <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> (co<span style=color:#333>-&gt;</span>status <span style=color:#333>==</span> CO_RUNNING) {
</span></span><span style=display:flex><span>      <span style=color:#06b;font-weight:700>longjmp</span>(co<span style=color:#333>-&gt;</span>context, <span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>实现stack_swicth_call与restore_registers_call</strong>：</p><p><figure><img src=https://pic2.zhimg.com/80/v2-bd5a0aa1625c4445ba33e506b91dba29_1440w.webp alt=调用栈></figure></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// 首先将call preserved registers保存下来
</span></span></span><span style=display:flex><span><span style=color:#888>// 接着将堆栈寄存器和参数寄存器的值设为sp和arg，并跳转到entry处，从而实现上下文切换
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>inline</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>stack_switch_call</span>(<span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>sp, <span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>entry, <span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>arg) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>asm</span> <span style=color:#080;font-weight:700>volatile</span>(
</span></span><span style=display:flex><span><span style=color:#579>#if __x86_64__
</span></span></span><span style=display:flex><span><span style=color:#579></span>      <span style=background-color:#fff0f0>&#34;mov %%rsp, %%r8;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;mov %0, %%rsp;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;push %%rbx;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;push %%r8;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;push %%rbp;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;push %%r12;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;push %%r13;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;push %%r14;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;push %%r15;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;mov %%rsp, %%rbp;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;sub $0x100, %%rsp;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;mov %2, %%rdi;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;call *%1&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span> <span style=background-color:#fff0f0>&#34;c&#34;</span>((uintptr_t)sp <span style=color:#333>-</span> <span style=color:#00d;font-weight:700>8</span>), <span style=background-color:#fff0f0>&#34;d&#34;</span>((uintptr_t)entry), <span style=background-color:#fff0f0>&#34;a&#34;</span>((uintptr_t)arg)
</span></span><span style=display:flex><span><span style=color:#579>#else
</span></span></span><span style=display:flex><span><span style=color:#579></span>      <span style=background-color:#fff0f0>&#34;movl %%ecx, 4(%0); movl %0, %%esp; movl %2, 0(%0); call *%1&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span> <span style=background-color:#fff0f0>&#34;b&#34;</span>((uintptr_t)sp <span style=color:#333>-</span> <span style=color:#00d;font-weight:700>8</span>), <span style=background-color:#fff0f0>&#34;d&#34;</span>((uintptr_t)entry), <span style=background-color:#fff0f0>&#34;a&#34;</span>((uintptr_t)arg)
</span></span><span style=display:flex><span><span style=color:#579>#endif
</span></span></span><span style=display:flex><span><span style=color:#579></span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 将call preserved registers的值恢复到切换上下文之前
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>inline</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>restore_registers_call</span>() {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>asm</span> <span style=color:#080;font-weight:700>volatile</span>(
</span></span><span style=display:flex><span><span style=color:#579>#if __x86_64__
</span></span></span><span style=display:flex><span><span style=color:#579></span>      <span style=background-color:#fff0f0>&#34;add $0x100, %%rsp;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;pop %%r15;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;pop %%r14;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;pop %%r13;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;pop %%r12;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;pop %%rbp;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;pop %%r8;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;pop %%rbx;&#34;</span>
</span></span><span style=display:flex><span>      <span style=background-color:#fff0f0>&#34;mov %%r8, %%rsp;&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span>
</span></span><span style=display:flex><span><span style=color:#579>#else
</span></span></span><span style=display:flex><span><span style=color:#579></span>      <span style=background-color:#fff0f0>&#34;movl 4(%%esp), %%ecx&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span>
</span></span><span style=display:flex><span>      <span style=color:#333>:</span>
</span></span><span style=display:flex><span><span style=color:#579>#endif
</span></span></span><span style=display:flex><span><span style=color:#579></span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=调试--坑>调试 & 坑</h3><p><strong>调试信息打印函数</strong>：</p><p>为了方便调试，我们可以定义一个debug_printf函数，并利用宏的机制来开启或关闭该信息的显示。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#579>#define DEBUG 0
</span></span></span><span style=display:flex><span><span style=color:#579></span>
</span></span><span style=display:flex><span><span style=color:#888>// 调试打印函数
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>debug_printf</span>(<span style=color:#080;font-weight:700>const</span> <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>fmt, ...) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (DEBUG) {
</span></span><span style=display:flex><span>    va_list args;
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>va_start</span>(args, fmt);
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>vprintf</span>(fmt, args);
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>va_end</span>(args);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>GDB</strong>：</p><p>由于这个实验涉及到使用内联汇编代码实现上下文切换，掌握gdb按汇编指令单步运行，来查看stack_swicth_call与restore_registers_call前后，寄存器是否保存正确、栈是否对齐，就显得十分重要。</p><p>关于如何使用gdb调试，具体可以参考我的<a href=https://zhytou.github.io/post/2023-6-27/gnu-tools/ target=_blank>博客</a>，里面几乎涵盖了这次实验会用到的所有gdb命令。</p><p><strong>我碰到的坑</strong>：</p><ol><li><p>堆栈没有对齐，报错SEGEFV；</p></li><li><p>画蛇添足，在co_wait里若发现协程状态为CO_DEAD就主动释放了该协程内存：</p></li></ol><p>不要在co_wait中释放协程，在destructor中统一释放。</p><h2 id=m3系统调用-profiler-sperf>M3：系统调用 Profiler sperf</h2><p>在这个实验中，我们需要实现命令行工具sperf：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sperf COMMAND <span style=color:#333>[</span>ARG<span style=color:#333>]</span>...
</span></span></code></pre></div><p>它会在系统中执行COMMAND命令，并为COMMAND传入ARG参数(列表)，然后统计命令执行的系统调用所占的时间。</p><h3 id=显示系统调用序列>显示系统调用序列</h3><p>根据实验说明，strace可以得到系统调用。它会 “重置” 某个进程的状态机，通过exceve使 “程序从头开始执行” 的系统调用。为了进一步使其显示相应调用的时间，我们可以使用-T参数，比如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&gt; strace -T ls .
</span></span><span style=display:flex><span>execve<span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;/usr/bin/ls&#34;</span>, <span style=color:#333>[</span><span style=background-color:#fff0f0>&#34;ls&#34;</span>, <span style=background-color:#fff0f0>&#34;.&#34;</span><span style=color:#333>]</span>, 0x7ffc449974d0 /* <span style=color:#60e;font-weight:700>36</span> vars */<span style=color:#333>)</span> <span style=color:#333>=</span> <span style=color:#60e;font-weight:700>0</span> &lt;0.000147&gt;
</span></span><span style=display:flex><span>brk<span style=color:#333>(</span>NULL<span style=color:#333>)</span>                               <span style=color:#333>=</span> 0x557441898000 &lt;0.000075&gt;
</span></span><span style=display:flex><span>arch_prctl<span style=color:#333>(</span>0x3001 /* ARCH_??? */, 0x7ffef498a610<span style=color:#333>)</span> <span style=color:#333>=</span> -1 EINVAL <span style=color:#333>(</span>Invalid argument<span style=color:#333>)</span> &lt;0.000032&gt;
</span></span><span style=display:flex><span>mmap<span style=color:#333>(</span>NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0<span style=color:#333>)</span> <span style=color:#333>=</span> 0x7f4df563c000 &lt;0.000031&gt;
</span></span><span style=display:flex><span>access<span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;/etc/ld.so.preload&#34;</span>, R_OK<span style=color:#333>)</span>      <span style=color:#333>=</span> -1 ENOENT <span style=color:#333>(</span>No such file or directory<span style=color:#333>)</span> &lt;0.000033&gt;
</span></span><span style=display:flex><span><span style=color:#888># 省略很多行</span>
</span></span><span style=display:flex><span>newfstatat<span style=color:#333>(</span>1, <span style=background-color:#fff0f0>&#34;&#34;</span>, <span style=color:#333>{</span><span style=color:#963>st_mode</span><span style=color:#333>=</span>S_IFCHR|0620, <span style=color:#963>st_rdev</span><span style=color:#333>=</span>makedev<span style=color:#333>(</span>0x88, 0x9<span style=color:#333>)</span>, ...<span style=color:#333>}</span>, AT_EMPTY_PATH<span style=color:#333>)</span> <span style=color:#333>=</span> <span style=color:#60e;font-weight:700>0</span> &lt;0.000030&gt;
</span></span><span style=display:flex><span>write<span style=color:#333>(</span>1, <span style=background-color:#fff0f0>&#34;Makefile  sperf-64  sperf.c\n&#34;</span>, 28Makefile  sperf-64  sperf.c
</span></span><span style=display:flex><span><span style=color:#333>)</span> <span style=color:#333>=</span> <span style=color:#60e;font-weight:700>28</span> &lt;0.000090&gt;
</span></span><span style=display:flex><span>close<span style=color:#333>(</span>1<span style=color:#333>)</span>                                <span style=color:#333>=</span> <span style=color:#60e;font-weight:700>0</span> &lt;0.000032&gt;
</span></span><span style=display:flex><span>close<span style=color:#333>(</span>2<span style=color:#333>)</span>                                <span style=color:#333>=</span> <span style=color:#60e;font-weight:700>0</span> &lt;0.000029&gt;
</span></span><span style=display:flex><span>exit_group<span style=color:#333>(</span>0<span style=color:#333>)</span>                           <span style=color:#333>=</span> ?
</span></span><span style=display:flex><span>+++ exited with <span style=color:#60e;font-weight:700>0</span> +++
</span></span></code></pre></div><p>为了从strace的输出中提取到每个系统调用的名称和执行时间，我们可以使用正则表达式进行匹配。</p><h3 id=实现sperf>实现sperf</h3><p>根据实验说明，我们可以得到sperf程序的整体结构如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>(<span style=color:#339;font-weight:700>int</span> argc, <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>argv[]) {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> fd[<span style=color:#00d;font-weight:700>2</span>];
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (pipe(fd) <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 创建管道失败
</span></span></span><span style=display:flex><span><span style=color:#888></span>  }
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> pid <span style=color:#333>=</span> fork();
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 子进程创建失败
</span></span></span><span style=display:flex><span><span style=color:#888></span>  }<span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 子进程，执行strace命令
</span></span></span><span style=display:flex><span><span style=color:#888></span>    execve(...);
</span></span><span style=display:flex><span>    <span style=color:#888>// 不应该执行此处代码，否则execve失败，出错处理
</span></span></span><span style=display:flex><span><span style=color:#888></span>  } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#888>// 父进程，读取strace输出并统计
</span></span></span><span style=display:flex><span><span style=color:#888></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>子进程</strong>：</p><p>对于子进程来说，只需要将管道写入端重定向到标准输出并且向execve传入正确的参数即可：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>(<span style=color:#339;font-weight:700>int</span> argc, <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>argv[])  {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 子进程创建失败
</span></span></span><span style=display:flex><span><span style=color:#888></span>    debug_printf(<span style=background-color:#fff0f0>&#34;fork failed</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>  } <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 关闭管道读取端，并将管道写入端重定向到标准输出
</span></span></span><span style=display:flex><span><span style=color:#888></span>    close(fd[<span style=color:#00d;font-weight:700>0</span>]);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (dup2(fd[<span style=color:#00d;font-weight:700>1</span>], STDERR_FILENO) <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#888>// 重定向失败
</span></span></span><span style=display:flex><span><span style=color:#888></span>      debug_printf(<span style=background-color:#fff0f0>&#34;dup2 failed!</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>      close(fd[<span style=color:#00d;font-weight:700>1</span>]);
</span></span><span style=display:flex><span>      exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#888>// 执行strace
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>exec_argv[argc <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>2</span>];
</span></span><span style=display:flex><span>    exec_argv[<span style=color:#00d;font-weight:700>0</span>] <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#34;strace&#34;</span>;
</span></span><span style=display:flex><span>    exec_argv[<span style=color:#00d;font-weight:700>1</span>] <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#34;-T&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>; i <span style=color:#333>&lt;</span> argc; i<span style=color:#333>++</span>) {
</span></span><span style=display:flex><span>      exec_argv[i <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>1</span>] <span style=color:#333>=</span> argv[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    exec_argv[argc <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>1</span>] <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>exec_envp[] <span style=color:#333>=</span> {
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;PATH=/bin&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#007020>NULL</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    execve(<span style=background-color:#fff0f0>&#34;strace&#34;</span>, exec_argv, exec_envp);
</span></span><span style=display:flex><span>    execve(<span style=background-color:#fff0f0>&#34;/bin/strace&#34;</span>, exec_argv, exec_envp);
</span></span><span style=display:flex><span>    execve(<span style=background-color:#fff0f0>&#34;/usr/bin/strace&#34;</span>, exec_argv, exec_envp);
</span></span><span style=display:flex><span>    perror(argv[<span style=color:#00d;font-weight:700>0</span>]);
</span></span><span style=display:flex><span>    close(fd[<span style=color:#00d;font-weight:700>1</span>]);
</span></span><span style=display:flex><span>    exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>  } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#888>// 父进程，读取strace输出并统计
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#888>// ...
</span></span></span><span style=display:flex><span><span style=color:#888></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>父进程</strong>：</p><p>对于父进程而言，除了使用正则表达式是从strace的输出提取所需信息之外，我们还要考虑如何存储这些信息。这里我使用的是链表，具体实现如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// 链表
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>typedef</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>list_node</span> {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>name;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>double</span> time;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>list_node</span> <span style=color:#333>*</span>next;
</span></span><span style=display:flex><span>} list_node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 链表插入节点，同时保证时间始终从大到小排序
</span></span></span><span style=display:flex><span><span style=color:#888></span>list_node <span style=color:#333>*</span><span style=color:#06b;font-weight:700>insert_list_node</span>(list_node <span style=color:#333>*</span>head, list_node <span style=color:#333>*</span>node) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (node <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> head;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (head <span style=color:#333>==</span> <span style=color:#007020>NULL</span> <span style=color:#333>||</span> head<span style=color:#333>-&gt;</span>time <span style=color:#333>&lt;</span> node<span style=color:#333>-&gt;</span>time) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (head <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>      node<span style=color:#333>-&gt;</span>next <span style=color:#333>=</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> node;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  list_node <span style=color:#333>*</span>prev <span style=color:#333>=</span> head;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>for</span> (list_node <span style=color:#333>*</span>curr <span style=color:#333>=</span> head<span style=color:#333>-&gt;</span>next; curr <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>; curr <span style=color:#333>=</span> curr<span style=color:#333>-&gt;</span>next) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (curr<span style=color:#333>-&gt;</span>time <span style=color:#333>&lt;</span> node<span style=color:#333>-&gt;</span>time) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    prev <span style=color:#333>=</span> curr;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  node<span style=color:#333>-&gt;</span>next <span style=color:#333>=</span> prev<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>  prev<span style=color:#333>-&gt;</span>next <span style=color:#333>=</span> node;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> head;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 释放链表内存
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>free_list</span>(list_node <span style=color:#333>*</span>head) {
</span></span><span style=display:flex><span>  list_node <span style=color:#333>*</span>curr <span style=color:#333>=</span> head;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>while</span> (curr <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>    list_node <span style=color:#333>*</span>next <span style=color:#333>=</span> curr<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (curr<span style=color:#333>-&gt;</span>name <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>      free(curr<span style=color:#333>-&gt;</span>name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    curr<span style=color:#333>-&gt;</span>name <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>    free(curr);
</span></span><span style=display:flex><span>    curr <span style=color:#333>=</span> next;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有了这个链表之后，再去实现父进程的逻辑就比较简单了。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>(<span style=color:#339;font-weight:700>int</span> argc, <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>argv[])  {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 子进程创建失败
</span></span></span><span style=display:flex><span><span style=color:#888></span>    debug_printf(<span style=background-color:#fff0f0>&#34;fork failed</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>    exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>  } <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 子进程，执行strace
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#888>// ...
</span></span></span><span style=display:flex><span><span style=color:#888></span>  } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#888>// 定义正则表达式
</span></span></span><span style=display:flex><span><span style=color:#888></span>    regex_t reg1, reg2;
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (regcomp(<span style=color:#333>&amp;</span>reg1, <span style=background-color:#fff0f0>&#34;[^</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\\</span><span style=background-color:#fff0f0>(</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n\r\b\t</span><span style=background-color:#fff0f0>]*</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\\</span><span style=background-color:#fff0f0>(&#34;</span>, REG_EXTENDED) <span style=color:#333>||</span>
</span></span><span style=display:flex><span>        regcomp(<span style=color:#333>&amp;</span>reg2, <span style=background-color:#fff0f0>&#34;&lt;.*&gt;&#34;</span>, REG_EXTENDED)) {
</span></span><span style=display:flex><span>      debug_printf(<span style=background-color:#fff0f0>&#34;regcomp failed!</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>      exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#888>// 链表记录各项调用时间信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>    list_node <span style=color:#333>*</span>head <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>    <span style=color:#888>// 调用总时间
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#339;font-weight:700>double</span> total_time <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#888>// 管道读取缓存
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#339;font-weight:700>char</span> buffer[BUFFER_SIZE];
</span></span><span style=display:flex><span>    <span style=color:#888>// 关闭管道写入端，并从管道中读取数据
</span></span></span><span style=display:flex><span><span style=color:#888></span>    close(fd[<span style=color:#00d;font-weight:700>1</span>]);
</span></span><span style=display:flex><span>    FILE <span style=color:#333>*</span>fp <span style=color:#333>=</span> fdopen(fd[<span style=color:#00d;font-weight:700>0</span>], <span style=background-color:#fff0f0>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#888>// 当前时间
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#339;font-weight:700>int</span> curr_time <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#888>// 运行标志
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#339;font-weight:700>int</span> run_flag <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>while</span> (run_flag) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>while</span> (fgets(buffer, BUFFER_SIZE, fp) <span style=color:#333>&gt;</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#888>// 读取到 +++ exited with 1/0 +++ 退出
</span></span></span><span style=display:flex><span><span style=color:#888></span>        <span style=color:#080;font-weight:700>if</span> (strstr(buffer, <span style=background-color:#fff0f0>&#34;+++ exited with 0 +++&#34;</span>) <span style=color:#333>!=</span> <span style=color:#007020>NULL</span> <span style=color:#333>||</span>
</span></span><span style=display:flex><span>            strstr(buffer, <span style=background-color:#fff0f0>&#34;+++ exited with 1 +++&#34;</span>) <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>          run_flag <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#888>// 使用正则表达式获取信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>        regmatch_t regmat1, regmat2;
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (regexec(<span style=color:#333>&amp;</span>reg1, buffer, <span style=color:#00d;font-weight:700>1</span>, <span style=color:#333>&amp;</span>regmat1, <span style=color:#00d;font-weight:700>0</span>) <span style=color:#333>||</span>
</span></span><span style=display:flex><span>            regexec(<span style=color:#333>&amp;</span>reg2, buffer, <span style=color:#00d;font-weight:700>1</span>, <span style=color:#333>&amp;</span>regmat2, <span style=color:#00d;font-weight:700>0</span>)) {
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#888>// 读取调用名称信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>        <span style=color:#339;font-weight:700>int</span> len <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        len <span style=color:#333>=</span> regmat1.rm_eo <span style=color:#333>-</span> regmat1.rm_so;
</span></span><span style=display:flex><span>        <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>name <span style=color:#333>=</span> (<span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>)malloc(<span style=color:#080;font-weight:700>sizeof</span>(<span style=color:#339;font-weight:700>char</span>) <span style=color:#333>*</span> len);
</span></span><span style=display:flex><span>        strncpy(name, buffer <span style=color:#333>+</span> regmat1.rm_so, len);
</span></span><span style=display:flex><span>        name[len <span style=color:#333>-</span> <span style=color:#00d;font-weight:700>1</span>] <span style=color:#333>=</span> <span style=color:#04d;background-color:#fff0f0>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#888>// 读取时间信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>        len <span style=color:#333>=</span> regmat2.rm_eo <span style=color:#333>-</span> regmat2.rm_so <span style=color:#333>-</span> <span style=color:#00d;font-weight:700>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>value <span style=color:#333>=</span> (<span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>)malloc(<span style=color:#080;font-weight:700>sizeof</span>(<span style=color:#339;font-weight:700>char</span>) <span style=color:#333>*</span> len);
</span></span><span style=display:flex><span>        strncpy(value, buffer <span style=color:#333>+</span> regmat2.rm_so <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>1</span>, len);
</span></span><span style=display:flex><span>        <span style=color:#339;font-weight:700>double</span> spent_time <span style=color:#333>=</span> atof(value);
</span></span><span style=display:flex><span>        <span style=color:#888>// 及时释放value内存
</span></span></span><span style=display:flex><span><span style=color:#888></span>        free(value);
</span></span><span style=display:flex><span>        value <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>        <span style=color:#888>// 更新总时间
</span></span></span><span style=display:flex><span><span style=color:#888></span>        total_time <span style=color:#333>+=</span> spent_time;
</span></span><span style=display:flex><span>        <span style=color:#888>// 将信息保存到链表中
</span></span></span><span style=display:flex><span><span style=color:#888></span>        list_node <span style=color:#333>*</span>node <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>        <span style=color:#339;font-weight:700>int</span> find_flag <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        list_node <span style=color:#333>*</span>prev <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>for</span> (list_node <span style=color:#333>*</span>curr <span style=color:#333>=</span> head; curr <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>; curr <span style=color:#333>=</span> curr<span style=color:#333>-&gt;</span>next) {
</span></span><span style=display:flex><span>          <span style=color:#888>// 若信息已存在，则将其更新后，重新插入
</span></span></span><span style=display:flex><span><span style=color:#888></span>          <span style=color:#080;font-weight:700>if</span> (strcmp(curr<span style=color:#333>-&gt;</span>name, name) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>            find_flag <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>if</span> (prev <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>              head <span style=color:#333>=</span> curr<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>            } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>              prev<span style=color:#333>-&gt;</span>next <span style=color:#333>=</span> curr<span style=color:#333>-&gt;</span>next;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            node <span style=color:#333>=</span> curr;
</span></span><span style=display:flex><span>            <span style=color:#888>// 信息存在，及时释放name内存
</span></span></span><span style=display:flex><span><span style=color:#888></span>            free(name);
</span></span><span style=display:flex><span>            name <span style=color:#333>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          prev <span style=color:#333>=</span> curr;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (find_flag) {
</span></span><span style=display:flex><span>          <span style=color:#888>// 更新信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>          node<span style=color:#333>-&gt;</span>time <span style=color:#333>+=</span> spent_time;
</span></span><span style=display:flex><span>        } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>          <span style=color:#888>// 新建节点，初始化信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>          node <span style=color:#333>=</span> (list_node <span style=color:#333>*</span>)malloc(<span style=color:#080;font-weight:700>sizeof</span>(list_node));
</span></span><span style=display:flex><span>          node<span style=color:#333>-&gt;</span>name <span style=color:#333>=</span> name;
</span></span><span style=display:flex><span>          node<span style=color:#333>-&gt;</span>time <span style=color:#333>=</span> spent_time;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#888>// 插入链表
</span></span></span><span style=display:flex><span><span style=color:#888></span>        head <span style=color:#333>=</span> insert_list_node(head, node);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#888>// 格式化打印前五占比调用信息
</span></span></span><span style=display:flex><span><span style=color:#888></span>      printf(<span style=background-color:#fff0f0>&#34;Time: %ds</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, curr_time);
</span></span><span style=display:flex><span>      <span style=color:#339;font-weight:700>int</span> k <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>for</span> (list_node <span style=color:#333>*</span>node <span style=color:#333>=</span> head; node <span style=color:#333>!=</span> <span style=color:#007020>NULL</span>; node <span style=color:#333>=</span> node<span style=color:#333>-&gt;</span>next) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (k<span style=color:#333>++</span> <span style=color:#333>&gt;=</span> PRINT_NUM) {
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        printf(<span style=background-color:#fff0f0>&#34;%s (%0.1f%%)</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, node<span style=color:#333>-&gt;</span>name, node<span style=color:#333>-&gt;</span>time <span style=color:#333>/</span> total_time <span style=color:#333>*</span> <span style=color:#00d;font-weight:700>100</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      printf(<span style=background-color:#fff0f0>&#34;=============</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>      curr_time <span style=color:#333>+=</span> TIME_INTERVAL_SEC;
</span></span><span style=display:flex><span>      sleep(TIME_INTERVAL_SEC);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#888>// 关闭管道读取端，释放相关资源
</span></span></span><span style=display:flex><span><span style=color:#888></span>    regfree(<span style=color:#333>&amp;</span>reg1);
</span></span><span style=display:flex><span>    regfree(<span style=color:#333>&amp;</span>reg2);
</span></span><span style=display:flex><span>    fclose(fp);
</span></span><span style=display:flex><span>    close(fd[<span style=color:#00d;font-weight:700>0</span>]);
</span></span><span style=display:flex><span>    free_list(head);
</span></span><span style=display:flex><span>    exit(EXIT_SUCCESS);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=m4c-real-eval-print-loop-crepl>M4：C Real-Eval-Print-Loop crepl</h2><p>M4要求我们实现一个类似Python Shell的“交互式Shell”程序crepl。具体来说，crepl逐行读取标准输入，根据内容进行处理：</p><ul><li>如果输入的一行定义了一个函数，则把函数编译并加载到进程的地址空间中；</li><li>如果输入是一个表达式，则把它的值输出。</li></ul><p>为了简化问题，实验还额外添加了两条限制：</p><ul><li>函数总是以int开头，即：函数返回类型始终为int。</li><li>如果一行不是以int开头，我们就认为这一行是一个C语言的表达式。</li></ul><p>这个实验也是比较有趣的一个，做完之后会对动态加载有更好的理解。</p><h3 id=解释器>解释器</h3><p><strong>表达式wrapper</strong>：</p><p>每当我们收到一个表达式，例如：gcd(256, 144) 的时候，我们都可以 “人工生成” 一段 C 代码，即生成一个wrapper函数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>char</span> line[<span style=color:#00d;font-weight:700>4096</span>];
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>while</span> (<span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    printf(<span style=background-color:#fff0f0>&#34;crepl&gt; &#34;</span>);
</span></span><span style=display:flex><span>    fflush(stdout);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (<span style=color:#333>!</span>fgets(line, <span style=color:#080;font-weight:700>sizeof</span>(line), stdin)) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#888>// 除去空白
</span></span></span><span style=display:flex><span><span style=color:#888></span>    actual_line <span style=color:#333>=</span> strip(line);
</span></span><span style=display:flex><span>    <span style=color:#888>// 打开文件
</span></span></span><span style=display:flex><span><span style=color:#888></span>    FILE <span style=color:#333>*</span>fp <span style=color:#333>=</span> fopen(<span style=background-color:#fff0f0>&#34;/tmp/a.c&#34;</span>, <span style=background-color:#fff0f0>&#34;a+&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (fp <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>      fprintf(stderr, <span style=background-color:#fff0f0>&#34;fopen error: %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, strerror(errno));
</span></span><span style=display:flex><span>      exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (strncmp(actual_line, <span style=background-color:#fff0f0>&#34;int &#34;</span>, <span style=color:#00d;font-weight:700>4</span>) <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#888>// int开头为函数，函数直接写入文件，等待后续编译即可
</span></span></span><span style=display:flex><span><span style=color:#888></span>      fputs(actual_line, fp);
</span></span><span style=display:flex><span>    } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#888>// 非函数（表达式），使用包装器写入文件，同样等待后续编译即可
</span></span></span><span style=display:flex><span><span style=color:#888></span>      is_expr <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>      fprintf(fp, <span style=background-color:#fff0f0>&#34;int __expr_wrapper_%d() { return %s; }&#34;</span>, expr_count<span style=color:#333>++</span>,
</span></span><span style=display:flex><span>              actual_line);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#888>// 关闭文件
</span></span></span><span style=display:flex><span><span style=color:#888></span>    fclose(fp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#888>// ...
</span></span></span><span style=display:flex><span><span style=color:#888></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>编译和加载</strong>：</p><p>为了增加实验难度，禁止使用C标准库system和popen函数。因此，我们使用类似M2中的方法，即fork配合exec family的系统调用，将传入的函数编译为共享库。其中，子进程负责编译；父进程根据传入内容，计算出输出结果。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>while</span>(<span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#888>// 写入文件
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#888>// ...
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#339;font-weight:700>int</span> pid <span style=color:#333>=</span> fork();
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#888>// 子进程创建失败
</span></span></span><span style=display:flex><span><span style=color:#888></span>      fprintf(stderr, <span style=background-color:#fff0f0>&#34;fork error: %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, strerror(errno));
</span></span><span style=display:flex><span>      exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>    } <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> (pid <span style=color:#333>==</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#888>// 子进程使用execve执行gcc
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>exec_argv[] <span style=color:#333>=</span> {
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;gcc&#34;</span>,
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;-fPIC&#34;</span>, 
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;-shared&#34;</span>, 
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;/tmp/a.c&#34;</span>,
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;-o&#34;</span>,
</span></span><span style=display:flex><span>        <span style=background-color:#fff0f0>&#34;liba.so&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#007020>NULL</span>,
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>      execve(<span style=background-color:#fff0f0>&#34;/usr/bin/gcc&#34;</span>, exec_argv, <span style=color:#007020>NULL</span>);
</span></span><span style=display:flex><span>      <span style=color:#888>// execve()仅执行失败返回
</span></span></span><span style=display:flex><span><span style=color:#888></span>      perror(<span style=background-color:#fff0f0>&#34;execve&#34;</span>);   
</span></span><span style=display:flex><span>      exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>    } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#888>// 父进程等待子进程结束
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#339;font-weight:700>int</span> status;
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (waitpid(pid, <span style=color:#333>&amp;</span>status, <span style=color:#00d;font-weight:700>0</span>) <span style=color:#333>==</span> <span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>        fprintf(stderr, <span style=background-color:#fff0f0>&#34;waitpid error: %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, strerror(errno));
</span></span><span style=display:flex><span>        exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>if</span> (WEXITSTATUS(status) <span style=color:#333>!=</span> <span style=color:#00d;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#888>// 子进程编译失败
</span></span></span><span style=display:flex><span><span style=color:#888></span>        printf(<span style=background-color:#fff0f0>&#34;compile error</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#888>// 如果是表达式，则需要加载库，并计算输出结果
</span></span></span><span style=display:flex><span><span style=color:#888></span>      <span style=color:#080;font-weight:700>if</span> (is_expr) {
</span></span><span style=display:flex><span>        <span style=color:#888>// 加载库
</span></span></span><span style=display:flex><span><span style=color:#888></span>        <span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>handle <span style=color:#333>=</span> dlopen(<span style=background-color:#fff0f0>&#34;/tmp/liba.so&#34;</span>, RTLD_LAZY);
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (handle <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>          fprintf(stderr, <span style=background-color:#fff0f0>&#34;dlopen error: %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, dlerror());
</span></span><span style=display:flex><span>          exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#888>// 获取表达式wrapper名称
</span></span></span><span style=display:flex><span><span style=color:#888></span>        <span style=color:#339;font-weight:700>int</span> expr_count_len <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>for</span> (<span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> expr_count; i <span style=color:#333>&gt;</span> <span style=color:#00d;font-weight:700>0</span>; i <span style=color:#333>/=</span> <span style=color:#00d;font-weight:700>10</span>) {
</span></span><span style=display:flex><span>          expr_count_len<span style=color:#333>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#339;font-weight:700>char</span> expr_name[expr_prefix_len <span style=color:#333>+</span> expr_count_len];
</span></span><span style=display:flex><span>        sprintf(expr_name, <span style=background-color:#fff0f0>&#34;__expr_wrapper_%d&#34;</span>, expr_count <span style=color:#333>-</span> <span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#888>// 获取表达式wrapper的函数指针
</span></span></span><span style=display:flex><span><span style=color:#888></span>        <span style=color:#339;font-weight:700>int</span> (<span style=color:#333>*</span>func)() <span style=color:#333>=</span> dlsym(handle, expr_name);
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (func <span style=color:#333>==</span> <span style=color:#007020>NULL</span>) {
</span></span><span style=display:flex><span>          fprintf(stderr, <span style=background-color:#fff0f0>&#34;dlsym error: %s</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, dlerror());
</span></span><span style=display:flex><span>          dlclose(handle);
</span></span><span style=display:flex><span>          exit(EXIT_FAILURE);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#888>// 运行表达式wrapper
</span></span></span><span style=display:flex><span><span style=color:#888></span>        <span style=color:#339;font-weight:700>int</span> result <span style=color:#333>=</span> func();
</span></span><span style=display:flex><span>        printf(<span style=background-color:#fff0f0>&#34;%d</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, result);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#888>// 关闭库
</span></span></span><span style=display:flex><span><span style=color:#888></span>        dlclose(handle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#888>// 重置is_expr
</span></span></span><span style=display:flex><span><span style=color:#888></span>        is_expr <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>      } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#888>// 定义函数成功
</span></span></span><span style=display:flex><span><span style=color:#888></span>        printf(<span style=background-color:#fff0f0>&#34;ok</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>坑</strong>：</p><p>这个实验整体来说比较简单，但我还是碰到一个坑，就是通过execve使用gcc时始终报错<code>gcc: fatal error: cannot execute 'cc1': execvp: No such file or directory</code>。起初，我判断是，execve函数的envp参数没设置对，补加了cc1所在的路径到环境变量PATH中去，但仍然报错。后续查阅资料，根据StackOverflow的这个<a href=https://stackoverflow.com/questions/11912878/gcc-error-gcc-error-trying-to-exec-cc1-execvp-no-such-file-or-directory target=_blank>帖子</a>，又尝试了在gcc所在目录添加一个cc1的软链接，这时候报错信息变成了<code>gcc: fatal error: '-fuse-linker-plugin', but liblto_plugin.so not found</code>，仍然不能正常运行。最后我尝试了以下命令去重新安装gcc。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install --reinstall build-essential
</span></span></code></pre></div><p>在apt进行update的时候始终报错<code>E: Release file for http://archive.ubuntu.com/ubuntu/dists/jammy-updates/InRelease is not valid yet (invalid for another 2h 54min 29s). Updates for this repository will not be applied.</code>。查阅资料后，发现这是因为wsl的时间不正确，可以使用<code>sudo hwclock --hctosys </code>命令进行校准。在校准后，再去重新安装gcc之后，问题就解决了。</p><h2 id=m5实现文件恢复工具-frecov>M5：实现文件恢复工具 frecov</h2><h2 id=参考>参考</h2><p><strong>M2</strong>：</p><ul><li><a href=https://www.linkedin.com/pulse/process-thread-coroutines-amit-nadiger/ target=_blank>Process , Thread and Coroutines</a></li><li><a href=https://zhuanlan.zhihu.com/p/27339191 target=_blank>x86系统调用及栈帧原理</a></li></ul></div></div></article></div></main><footer>© Copyright <a href=https://github.com/Zhytou target=_blank>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae target=_blank>Vitae</a> theme for <a href=https://gohugo.io target=_blank>Hugo</a></footer><script src=/js/dark-mode.js></script></body></html>
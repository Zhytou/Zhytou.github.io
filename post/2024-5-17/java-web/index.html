<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<title>Java Web开发技术 | Zhytou</title>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=generator content="Hugo 0.91.2">
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel="shortcut icon" href=/favicon.ico>
<link rel=stylesheet type=text/css media=screen href=/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=/css/main.css>
<link rel=stylesheet type=text/css media=screen href=/css/all.css>
<meta property="og:title" content="Java Web开发技术">
<meta property="og:description" content="History CGI & Servlet：
早期的动态网页技术主要包括CGI（通用网关接口，Common Gateway Interface）和Servlet。其中，CGI通过定义Web服务器与外部程序的标准接口，使得外部程序能够根据Web请求生成动态内容。CGI模式的具体工作流程如图1所示。
 
相比之下，尽管两者的整体工作架构类似，但Servlet模式把服务器中接收请求和返回响应的部分封装起来了，免去了开发者重复造轮子的工作。开发者只需要根据JDK中Servlet API实现业务逻辑即可。换句话说，开发者编写的Servlet程序其实就类似CGI模式下的外部程序。此外，Servlet拥有更好的可移植性和更高的运行效率，因为Servlet对象运行在JVM上且由Servlet容器管理，可以持久驻留在内存中为多个请求服务，而不需要像CGI一样每次请求都启动一个新进程来执行外部程序。
JSP：HTML Template：
在CGI和Servlet的模式下，服务代码往往和HTML大量杂糅在一起。为了处理更复杂的应用并且方便后期维护，人们开始尝试把HTML返回中固定的部分存起来（我们称之为模版），把动态的部分标记出来。当Web请求处理的时候，程序先获取动态数据，再把模版读入进来，把动态数据填充进去，形成最终返回。因此，各种服务器端脚本语言开始出现:
 ASP(1996) - 微软推出 Active Server Pages，使用 VBScript 等语言来渲染动态页面。 PHP(1995 发布，2000 年代开始流行) - 简单的服务器端脚本语言，适用于构建动态网站。 JSP/Servlet(1997) - Sun 公司发布 Java Server Pages，使用 Java 语言开发 Web 应用。  其中，JSP(JavaServer Pages)是一种基于Java的Web开发技术，它使HTML页面具备动态内容生成能力。JSP本质上也是一种Servlet，它将Java代码和HTML标签混合编写，然后由Web容器将其转译为一个Servlet类并执行。
MVC: J2EE vs ASP.NET:
随着网络应用复杂度不断提高，尤其是在构造大型应用是在可扩展性、容错性等方面的需求催生了J2EE和ASP.NET的平台。事实上，前文所提到的Java Servlet和JSP正是J2EE中的核心组件。
这个时期，人们开始考虑将Servlet和JSP的优势结合起来，分别使用Servlet和JSP实现各种复杂的业务逻辑和编写HTML，也就是后续在Web开发中广泛应用的MVC模式。MVC模式最早由Trygve Reenskaug在1978年提出。它是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：
 模型（Model）：负责数据访问和算法实现； 视图（View）：负责界面显示； 控制器（Controller）：负责处理请求。  在J2EE Web应用的体系中，Servlet和JSP分别承担了Controller和View的职责，而Model则是由J2EE的另一个重要组件EJB（Enterprise Java Bean）负责。类似的，由微软推出的ASP.NET平台也同样采用了MVC架构模式。
JavaScript Popularity And AJAX Occurrence ：Frontend Backend Split：
随着JavaScript在浏览器中的广泛应用以及AJAX(Asynchronous JavaScript and XML)技术的出现，Web应用程序架构发生了重大转变。因为JavaScript能够直接操作DOM局部更新页面内容，而AJAX技术又使得其能与服务器进行异步通信获取所需数据。这种新模式逐渐取代了传统的JSP技术，改善了服务端大包大揽的状况，使得交互和显示的任务从服务端被剥离出来，进一步形成了前端负责界面显示和用户交互而后端专注于业务逻辑处理的现代Web应用架构。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhytou.github.io/post/2024-5-17/java-web/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2024-05-17T20:36:27+08:00">
<meta property="article:modified_time" content="2024-05-17T20:36:27+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Java Web开发技术">
<meta name=twitter:description content="History CGI & Servlet：
早期的动态网页技术主要包括CGI（通用网关接口，Common Gateway Interface）和Servlet。其中，CGI通过定义Web服务器与外部程序的标准接口，使得外部程序能够根据Web请求生成动态内容。CGI模式的具体工作流程如图1所示。
 
相比之下，尽管两者的整体工作架构类似，但Servlet模式把服务器中接收请求和返回响应的部分封装起来了，免去了开发者重复造轮子的工作。开发者只需要根据JDK中Servlet API实现业务逻辑即可。换句话说，开发者编写的Servlet程序其实就类似CGI模式下的外部程序。此外，Servlet拥有更好的可移植性和更高的运行效率，因为Servlet对象运行在JVM上且由Servlet容器管理，可以持久驻留在内存中为多个请求服务，而不需要像CGI一样每次请求都启动一个新进程来执行外部程序。
JSP：HTML Template：
在CGI和Servlet的模式下，服务代码往往和HTML大量杂糅在一起。为了处理更复杂的应用并且方便后期维护，人们开始尝试把HTML返回中固定的部分存起来（我们称之为模版），把动态的部分标记出来。当Web请求处理的时候，程序先获取动态数据，再把模版读入进来，把动态数据填充进去，形成最终返回。因此，各种服务器端脚本语言开始出现:
 ASP(1996) - 微软推出 Active Server Pages，使用 VBScript 等语言来渲染动态页面。 PHP(1995 发布，2000 年代开始流行) - 简单的服务器端脚本语言，适用于构建动态网站。 JSP/Servlet(1997) - Sun 公司发布 Java Server Pages，使用 Java 语言开发 Web 应用。  其中，JSP(JavaServer Pages)是一种基于Java的Web开发技术，它使HTML页面具备动态内容生成能力。JSP本质上也是一种Servlet，它将Java代码和HTML标签混合编写，然后由Web容器将其转译为一个Servlet类并执行。
MVC: J2EE vs ASP.NET:
随着网络应用复杂度不断提高，尤其是在构造大型应用是在可扩展性、容错性等方面的需求催生了J2EE和ASP.NET的平台。事实上，前文所提到的Java Servlet和JSP正是J2EE中的核心组件。
这个时期，人们开始考虑将Servlet和JSP的优势结合起来，分别使用Servlet和JSP实现各种复杂的业务逻辑和编写HTML，也就是后续在Web开发中广泛应用的MVC模式。MVC模式最早由Trygve Reenskaug在1978年提出。它是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：
 模型（Model）：负责数据访问和算法实现； 视图（View）：负责界面显示； 控制器（Controller）：负责处理请求。  在J2EE Web应用的体系中，Servlet和JSP分别承担了Controller和View的职责，而Model则是由J2EE的另一个重要组件EJB（Enterprise Java Bean）负责。类似的，由微软推出的ASP.NET平台也同样采用了MVC架构模式。
JavaScript Popularity And AJAX Occurrence ：Frontend Backend Split：
随着JavaScript在浏览器中的广泛应用以及AJAX(Asynchronous JavaScript and XML)技术的出现，Web应用程序架构发生了重大转变。因为JavaScript能够直接操作DOM局部更新页面内容，而AJAX技术又使得其能与服务器进行异步通信获取所需数据。这种新模式逐渐取代了传统的JSP技术，改善了服务端大包大揽的状况，使得交互和显示的任务从服务端被剥离出来，进一步形成了前端负责界面显示和用户交互而后端专注于业务逻辑处理的现代Web应用架构。">
<meta itemprop=name content="Java Web开发技术">
<meta itemprop=description content="History CGI & Servlet：
早期的动态网页技术主要包括CGI（通用网关接口，Common Gateway Interface）和Servlet。其中，CGI通过定义Web服务器与外部程序的标准接口，使得外部程序能够根据Web请求生成动态内容。CGI模式的具体工作流程如图1所示。
 
相比之下，尽管两者的整体工作架构类似，但Servlet模式把服务器中接收请求和返回响应的部分封装起来了，免去了开发者重复造轮子的工作。开发者只需要根据JDK中Servlet API实现业务逻辑即可。换句话说，开发者编写的Servlet程序其实就类似CGI模式下的外部程序。此外，Servlet拥有更好的可移植性和更高的运行效率，因为Servlet对象运行在JVM上且由Servlet容器管理，可以持久驻留在内存中为多个请求服务，而不需要像CGI一样每次请求都启动一个新进程来执行外部程序。
JSP：HTML Template：
在CGI和Servlet的模式下，服务代码往往和HTML大量杂糅在一起。为了处理更复杂的应用并且方便后期维护，人们开始尝试把HTML返回中固定的部分存起来（我们称之为模版），把动态的部分标记出来。当Web请求处理的时候，程序先获取动态数据，再把模版读入进来，把动态数据填充进去，形成最终返回。因此，各种服务器端脚本语言开始出现:
 ASP(1996) - 微软推出 Active Server Pages，使用 VBScript 等语言来渲染动态页面。 PHP(1995 发布，2000 年代开始流行) - 简单的服务器端脚本语言，适用于构建动态网站。 JSP/Servlet(1997) - Sun 公司发布 Java Server Pages，使用 Java 语言开发 Web 应用。  其中，JSP(JavaServer Pages)是一种基于Java的Web开发技术，它使HTML页面具备动态内容生成能力。JSP本质上也是一种Servlet，它将Java代码和HTML标签混合编写，然后由Web容器将其转译为一个Servlet类并执行。
MVC: J2EE vs ASP.NET:
随着网络应用复杂度不断提高，尤其是在构造大型应用是在可扩展性、容错性等方面的需求催生了J2EE和ASP.NET的平台。事实上，前文所提到的Java Servlet和JSP正是J2EE中的核心组件。
这个时期，人们开始考虑将Servlet和JSP的优势结合起来，分别使用Servlet和JSP实现各种复杂的业务逻辑和编写HTML，也就是后续在Web开发中广泛应用的MVC模式。MVC模式最早由Trygve Reenskaug在1978年提出。它是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：
 模型（Model）：负责数据访问和算法实现； 视图（View）：负责界面显示； 控制器（Controller）：负责处理请求。  在J2EE Web应用的体系中，Servlet和JSP分别承担了Controller和View的职责，而Model则是由J2EE的另一个重要组件EJB（Enterprise Java Bean）负责。类似的，由微软推出的ASP.NET平台也同样采用了MVC架构模式。
JavaScript Popularity And AJAX Occurrence ：Frontend Backend Split：
随着JavaScript在浏览器中的广泛应用以及AJAX(Asynchronous JavaScript and XML)技术的出现，Web应用程序架构发生了重大转变。因为JavaScript能够直接操作DOM局部更新页面内容，而AJAX技术又使得其能与服务器进行异步通信获取所需数据。这种新模式逐渐取代了传统的JSP技术，改善了服务端大包大揽的状况，使得交互和显示的任务从服务端被剥离出来，进一步形成了前端负责界面显示和用户交互而后端专注于业务逻辑处理的现代Web应用架构。"><meta itemprop=datePublished content="2024-05-17T20:36:27+08:00">
<meta itemprop=dateModified content="2024-05-17T20:36:27+08:00">
<meta itemprop=wordCount content="836">
<meta itemprop=keywords content>
</head>
<body>
<header>
<div id=avatar>
<a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a>
</div>
<div id=titletext>
<h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2>
</div>
<div id=title-description>
<p id=subtitle>May the force be with me.</p>
<div id=social>
<nav><ul>
<li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id=mainmenu>
<nav>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/post>Posts</a></li>
<li><a href=/about>About</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class=post>
<article>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>17</span>
<span class=rest>May 2024</span>
</div>
</div>
<div class=matter>
<h1 class=title>Java Web开发技术</h1>
<p class=post-meta>
<span class=post-meta>
</span>
</p>
</div>
</div>
<div class=markdown>
<h2 id=history>History</h2>
<p><strong>CGI & Servlet</strong>：</p>
<p>早期的动态网页技术主要包括CGI（通用网关接口，Common Gateway Interface）和Servlet。其中，CGI通过定义Web服务器与外部程序的标准接口，使得外部程序能够根据Web请求生成动态内容。CGI模式的具体工作流程如图1所示。</p>
<p><figure>
<img src=https://lushunjian.github.io/blog/2019/01/21/web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E5%8F%98/CGI.png alt="图1 CGI工作流程">
</figure></p>
<p>相比之下，尽管两者的整体工作架构类似，但Servlet模式把服务器中接收请求和返回响应的部分封装起来了，免去了开发者重复造轮子的工作。开发者只需要根据JDK中Servlet API实现业务逻辑即可。换句话说，开发者编写的Servlet程序其实就类似CGI模式下的外部程序。此外，Servlet拥有更好的可移植性和更高的运行效率，因为Servlet对象运行在JVM上且由Servlet容器管理，可以持久驻留在内存中为多个请求服务，而不需要像CGI一样每次请求都启动一个新进程来执行外部程序。</p>
<p><strong>JSP：HTML Template</strong>：</p>
<p>在CGI和Servlet的模式下，服务代码往往和HTML大量杂糅在一起。为了处理更复杂的应用并且方便后期维护，人们开始尝试把HTML返回中固定的部分存起来（我们称之为模版），把动态的部分标记出来。当Web请求处理的时候，程序先获取动态数据，再把模版读入进来，把动态数据填充进去，形成最终返回。因此，各种服务器端脚本语言开始出现:</p>
<ul>
<li>ASP(1996) - 微软推出 Active Server Pages，使用 VBScript 等语言来渲染动态页面。</li>
<li>PHP(1995 发布，2000 年代开始流行) - 简单的服务器端脚本语言，适用于构建动态网站。</li>
<li>JSP/Servlet(1997) - Sun 公司发布 Java Server Pages，使用 Java 语言开发 Web 应用。</li>
</ul>
<p>其中，JSP(JavaServer Pages)是一种基于Java的Web开发技术，它使HTML页面具备动态内容生成能力。JSP本质上也是一种Servlet，它将Java代码和HTML标签混合编写，然后由Web容器将其转译为一个Servlet类并执行。</p>
<p><strong>MVC: J2EE vs ASP.NET</strong>:</p>
<p>随着网络应用复杂度不断提高，尤其是在构造大型应用是在可扩展性、容错性等方面的需求催生了J2EE和ASP.NET的平台。事实上，前文所提到的Java Servlet和JSP正是J2EE中的核心组件。</p>
<p>这个时期，人们开始考虑将Servlet和JSP的优势结合起来，分别使用Servlet和JSP实现各种复杂的业务逻辑和编写HTML，也就是后续在Web开发中广泛应用的MVC模式。MVC模式最早由Trygve Reenskaug在1978年提出。它是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：</p>
<ul>
<li>模型（Model）：负责数据访问和算法实现；</li>
<li>视图（View）：负责界面显示；</li>
<li>控制器（Controller）：负责处理请求。</li>
</ul>
<p>在J2EE Web应用的体系中，Servlet和JSP分别承担了Controller和View的职责，而Model则是由J2EE的另一个重要组件EJB（Enterprise Java Bean）负责。类似的，由微软推出的ASP.NET平台也同样采用了MVC架构模式。</p>
<p><strong>JavaScript Popularity And AJAX Occurrence ：Frontend Backend Split</strong>：</p>
<p>随着JavaScript在浏览器中的广泛应用以及AJAX(Asynchronous JavaScript and XML)技术的出现，Web应用程序架构发生了重大转变。因为JavaScript能够直接操作DOM局部更新页面内容，而AJAX技术又使得其能与服务器进行异步通信获取所需数据。这种新模式逐渐取代了传统的JSP技术，改善了服务端大包大揽的状况，使得交互和显示的任务从服务端被剥离出来，进一步形成了前端负责界面显示和用户交互而后端专注于业务逻辑处理的现代Web应用架构。</p>
<p><strong>More Framework</strong>:</p>
<p>此后，前后端分离的格局形成，大量Web框架涌现。在前端领域，Vue和React等现代JavaScript框架应运而生，提供了更高效、组件化的方式构建用户界面。与此同时，Node.js的出现使JavaScript可以运行在服务器端，开发人员能够使用同一种语言编写前后端代码，提高了开发效率，也催生了以MERN（MongoDB+Express+Node+React）等为代表的全栈工程师。</p>
<p>在后端领域，各种语言的框架百花齐放。其中，Python有Flask和Django，JavaScript有Express，而在Java阵营中，Spring框架则凭借其轻量、模块化的设计，成为了最主要和流行的企业级Web应用开发框架之一。</p>
<h2 id=servlet>Servlet</h2>
<p>Java Servlet的全称是Java Server Applet，也就是Java服务器小程序。利用它开发者能根据业务逻辑动态生成内容返回给客户端。</p>
<p>Servlet技术是2000年代重要的动态网页技术之一，直至今天也仍然作为大型Java Web框架的中重要组成部分而存在（Spring的核心组件DispatcherServlet）。因此，了解Servlet工作原理是学习Java Web是绕不开的话题。</p>
<h3 id=helloservleta-simple-servlet-example>HelloServlet：A simple servlet example</h3>
<p>一个最简单的HelloServlet程序如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>HelloServlet</span> <span style=color:#080;font-weight:700>extends</span> HttpServlet <span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>doGet</span><span style=color:#333>(</span>HttpServletRequest req<span style=color:#333>,</span> HttpServletResponse res<span style=color:#333>)</span> <span style=color:#080;font-weight:700>throws</span> ServletException<span style=color:#333>,</span> IOException <span style=color:#333>{</span>
        res<span style=color:#333>.</span><span style=color:#00c>setContentType</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;text/html&#34;</span><span style=color:#333>);</span>
        <span style=color:#888>//We need printwriter object to write html content
</span><span style=color:#888></span>        PrintWriter pw <span style=color:#333>=</span> res<span style=color:#333>.</span><span style=color:#00c>getWriter</span><span style=color:#333>();</span>

        <span style=color:#888>// writing html in the stream
</span><span style=color:#888></span>        pw<span style=color:#333>.</span><span style=color:#00c>println</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;html&gt;&lt;body&gt;&#34;</span><span style=color:#333>);</span>
        pw<span style=color:#333>.</span><span style=color:#00c>println</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;Welcome to my first servlet&#34;</span><span style=color:#333>);</span>
        pw<span style=color:#333>.</span><span style=color:#00c>println</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;/body&gt;&lt;/html&gt;&#34;</span><span style=color:#333>);</span>

        pw<span style=color:#333>.</span><span style=color:#00c>close</span><span style=color:#333>();</span><span style=color:#888>// close the stream
</span><span style=color:#888></span>    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><p>将它打包并部署到Tomcat的webapps目录中，并修改Tomcat的web.xml配置文件如下。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#579>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style=color:#070>&lt;web-app</span> <span style=color:#00c>version=</span><span style=background-color:#fff0f0>&#34;2.5&#34;</span>
         <span style=color:#00c>xmlns:xsi=</span><span style=background-color:#fff0f0>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
         <span style=color:#00c>xmlns=</span><span style=background-color:#fff0f0>&#34;http://java.sun.com/xml/ns/javaee&#34;</span>
         <span style=color:#00c>xsi:schemaLocation=</span><span style=background-color:#fff0f0>&#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&#34;</span><span style=color:#070>&gt;</span>
    <span style=color:#070>&lt;display-name&gt;</span>Java Creed | How To Run Embedded Tomcat with Maven<span style=color:#070>&lt;/display-name&gt;</span>

    <span style=color:#070>&lt;servlet&gt;</span>
        <span style=color:#070>&lt;servlet-name&gt;</span>hello<span style=color:#070>&lt;/servlet-name&gt;</span>
        <span style=color:#070>&lt;servlet-class&gt;</span>org.example.HelloServlet<span style=color:#070>&lt;/servlet-class&gt;</span>
    <span style=color:#070>&lt;/servlet&gt;</span>

    <span style=color:#070>&lt;servlet-mapping&gt;</span>
        <span style=color:#070>&lt;servlet-name&gt;</span>hello<span style=color:#070>&lt;/servlet-name&gt;</span>
        <span style=color:#070>&lt;url-pattern&gt;</span>/hello<span style=color:#070>&lt;/url-pattern&gt;</span>
    <span style=color:#070>&lt;/servlet-mapping&gt;</span>
<span style=color:#070>&lt;/web-app&gt;</span>
</code></pre></div><p>最终，我们可以得到图2所示效果。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-5-17/hello_servlet.png alt="图2 HelloServlet效果">
</figure></p>
<h3 id=servlet-basis>Servlet Basis</h3>
<p><strong>Servlet API</strong>:</p>
<p>在这个示例中，HelloServlet类继承于HttpServlet类，并实现了doGet方法来处理HTTP GET请求。而HttpServlet正是一个重要的Servlet接口类，可见Servlet程序就是使用JDK中Servlet API根据业务逻辑实现的一个类。</p>
<p>Java Servlet API是一套用于在服务器上实现响应请求的标准。它由javax.servlet和javax.servlet.http两个核心包组成，定义了Servlet组件的生命周期方法和客户端请求响应处理等规范。常用的Servlet接口和类包括:</p>
<ul>
<li>GenericServlet类</li>
<li>HttpServlet类</li>
<li>Request对象</li>
<li>Response对象</li>
<li>ServletConfig对象</li>
<li>ServletContext对象</li>
</ul>
<p><strong>Servlet Container</strong>:</p>
<p>Servlet程序并没有main函数，需要部署在Servlet容器(如Tomcat)中运行。Servlet容器负责创建、管理和销毁Servlet对象，并根据HTTP请求调用相应的Servlet程序。整个调用过程如图3所示:</p>
<p><figure>
<img src="https://picx.zhimg.com/v2-ce6e39bb02e3c6a2f4eb1e5afaa6e4e6_r.jpg?source=2c26e567" alt="图3 Tomcat调用">
</figure></p>
<p>除了提供通信支持和资源管理之外，使用Servlet容器还提供多线程支持。容器会自动为它所接收的每个Servlet请求创建一个新的线程，并且当运行完相应的http服务方法，这个线程就会自动结束。当然，这并不是说开发者就不再不需要考虑线程安全性，只不过这样能减少做很多重复的工作。</p>
<p><strong>Servlet Lifecycle</strong>:</p>
<p>查看JDK中提供的Servlet接口我们发现，其中最核心的就是三个函数init、service和destroy，这也正好对应了一个Servlet对象的生命周期。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>interface</span> <span style=color:#b06;font-weight:700>Servlet</span> <span style=color:#333>{</span>
    <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>init</span><span style=color:#333>(</span>ServletConfig var1<span style=color:#333>)</span> <span style=color:#080;font-weight:700>throws</span> ServletException<span style=color:#333>;</span>

    ServletConfig <span style=color:#06b;font-weight:700>getServletConfig</span><span style=color:#333>();</span>

    <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>service</span><span style=color:#333>(</span>ServletRequest var1<span style=color:#333>,</span> ServletResponse var2<span style=color:#333>)</span> <span style=color:#080;font-weight:700>throws</span> ServletException<span style=color:#333>,</span> IOException<span style=color:#333>;</span>

    String <span style=color:#06b;font-weight:700>getServletInfo</span><span style=color:#333>();</span>

    <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>destroy</span><span style=color:#333>();</span>
<span style=color:#333>}</span>
</code></pre></div><p>以下是 Servlet 遵循的过程：</p>
<ul>
<li>Servlet 初始化后调用 init () 方法。</li>
<li>Servlet 调用 service() 方法来处理客户端的请求。</li>
<li>Servlet 销毁前调用 destroy() 方法。</li>
<li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ul>
<h3 id=filter>Filter</h3>
<p>在一个比较复杂的Web应用程序中，通常都有很多URL映射，对应的，也会有多个Servlet来处理URL。假设现在有一个论坛Web 应用，它有5个Servlet。其中，ProfileServlet、PostServlet和ReplyServlet都需要用户登录后才能操作，否则，应当直接跳转到登录页面。我们可以直接把判断登录的逻辑写到这3个Servlet中，但是，同样的逻辑重复3次没有必要，并且，如果后续继续加Servlet并且也需要验证登录时，还需要继续重复这个检查逻辑。</p>
<p>为了把一些公用逻辑从各个Servlet中抽离出来，JavaEE的Servlet规范还提供了一种Filter组件，即过滤器，它的作用是，在HTTP请求到达Servlet之前，可以被一个或多个Filter预处理，类似打印日志、登录检查等逻辑，完全可以放到Filter中。</p>
<h3 id=listener>Listener</h3>
<p>除了Servlet和Filter外，JavaEE的Servlet规范还提供了第三种组件：Listener。Listener顾名思义就是监听器，用于监听Web应用中的事件，以实现一些全局操作。如监听Web应用的启动和停止，会话对象的创建和销毁等。比如，下面这个例子就实现了一个ServletContextListener接口的类。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#555;font-weight:700>@WebListener</span>
<span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>AppListener</span> <span style=color:#080;font-weight:700>implements</span> ServletContextListener <span style=color:#333>{</span>
    <span style=color:#888>// 在此初始化WebApp,例如打开数据库连接池等:
</span><span style=color:#888></span>    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>contextInitialized</span><span style=color:#333>(</span>ServletContextEvent sce<span style=color:#333>)</span> <span style=color:#333>{</span>
        System<span style=color:#333>.</span><span style=color:#00c>out</span><span style=color:#333>.</span><span style=color:#00c>println</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;WebApp initialized.&#34;</span><span style=color:#333>);</span>
    <span style=color:#333>}</span>

    <span style=color:#888>// 在此清理WebApp,例如关闭数据库连接池等:
</span><span style=color:#888></span>    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>contextDestroyed</span><span style=color:#333>(</span>ServletContextEvent sce<span style=color:#333>)</span> <span style=color:#333>{</span>
        System<span style=color:#333>.</span><span style=color:#00c>out</span><span style=color:#333>.</span><span style=color:#00c>println</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;WebApp destroyed.&#34;</span><span style=color:#333>);</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><p>任何标注为@WebListener，且实现了特定接口的类会被Web服务器自动初始化。上述AppListener实现了ServletContextListener接口，它会在整个Web应用程序初始化完成后，以及Web应用程序关闭后获得回调通知。我们可以把初始化数据库连接池等工作放到contextInitialized()回调方法中，把清理资源的工作放到contextDestroyed()回调方法中，因为Web服务器保证在contextInitialized()执行后，才会接受用户的HTTP请求。</p>
<h2 id=jsp>JSP</h2>
<p>正如前面历史介绍中所提到的那样，JSP（Java服务端网页，Java Server Page）是一种基于HTML模板的动态网页技术。早期Servlet程序是将HTML语句拆成一行一行嵌入Java源文件，并用ServletResponse中PrintWriter写入返回响应之中，而JSP则是在需要动态输出的地方使用JSP标签将Java代码嵌入HTML文件中。</p>
<h3 id=welcomejsp-a-simple-jsp-example>Welcome.jsp: A simple JSP example</h3>
<p>有一个简单的Welcome.jsp内容如下，将其放置在Tomcat的webapps目录下。其中，out是JSP内置的变量，表示当前HttpServletResponse的PrintWriter。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#333>&lt;%</span><span style=color:red;background-color:#faa>@</span> page contentType<span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;text/html;charset=UTF-8&#34;</span> language<span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;java&#34;</span> <span style=color:#333>%&gt;</span>
<span style=color:#333>&lt;</span>html<span style=color:#333>&gt;</span>
<span style=color:#333>&lt;</span>head<span style=color:#333>&gt;</span>
    <span style=color:#333>&lt;</span>title<span style=color:#333>&gt;</span>Welcome<span style=color:#333>&lt;/</span>title<span style=color:#333>&gt;</span>
<span style=color:#333>&lt;/</span>head<span style=color:#333>&gt;</span>
<span style=color:#333>&lt;</span>body<span style=color:#333>&gt;</span>
    <span style=color:#333>&lt;</span>h1<span style=color:#333>&gt;&lt;%</span>
        out<span style=color:#333>.</span><span style=color:#00c>println</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;Hello &#34;</span><span style=color:#333>+</span>request<span style=color:#333>.</span><span style=color:#00c>getParameter</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;name&#34;</span><span style=color:#333>)+</span><span style=background-color:#fff0f0>&#34;!&#34;</span><span style=color:#333>);</span>
    <span style=color:#333>%&gt;&lt;/</span>h1<span style=color:#333>&gt;</span>
<span style=color:#333>&lt;/</span>body<span style=color:#333>&gt;</span>
<span style=color:#333>&lt;/</span>html<span style=color:#333>&gt;</span>
</code></pre></div><p>接着，访问<a href="http://localhost:9090/welcome.jsp?name=Zhytou" target=_blank>http://localhost:9090/welcome.jsp?name=Zhytou</a>这个链接，即可得到如图4所示效果。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-5-17/welcome_jsp.png alt="图4 Welcome.jsp">
</figure></p>
<h3 id=jsp-workflow>JSP Workflow</h3>
<p>JSP的工作流程是怎么样的呢？我们可以在Tomcat的工作目录下找到一个名为welcome_jsp.java的文件，其内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#888>/*
</span><span style=color:#888> * Generated by the Jasper component of Apache Tomcat
</span><span style=color:#888> * Version: Apache Tomcat/7.0.47
</span><span style=color:#888> * Generated at: 2024-05-07 17:05:35 UTC
</span><span style=color:#888> * Note: The last modified time of this file was set to
</span><span style=color:#888> *       the last modified time of the source file after
</span><span style=color:#888> *       generation to assist with modification tracking.
</span><span style=color:#888> */</span>
<span style=color:#080;font-weight:700>package</span> <span style=color:#0e84b5;font-weight:700>org.apache.jsp</span><span style=color:#333>;</span>

<span style=color:#080;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>javax.servlet.*</span><span style=color:#333>;</span>
<span style=color:#080;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>javax.servlet.http.*</span><span style=color:#333>;</span>
<span style=color:#080;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>javax.servlet.jsp.*</span><span style=color:#333>;</span>

<span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>final</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>welcome_jsp</span> <span style=color:#080;font-weight:700>extends</span> org<span style=color:#333>.</span><span style=color:#00c>apache</span><span style=color:#333>.</span><span style=color:#00c>jasper</span><span style=color:#333>.</span><span style=color:#00c>runtime</span><span style=color:#333>.</span><span style=color:#00c>HttpJspBase</span>
    <span style=color:#080;font-weight:700>implements</span> org<span style=color:#333>.</span><span style=color:#00c>apache</span><span style=color:#333>.</span><span style=color:#00c>jasper</span><span style=color:#333>.</span><span style=color:#00c>runtime</span><span style=color:#333>.</span><span style=color:#00c>JspSourceDependent</span> <span style=color:#333>{</span>

  <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>final</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>jsp</span><span style=color:#333>.</span><span style=color:#00c>JspFactory</span> _jspxFactory <span style=color:#333>=</span>
          javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>jsp</span><span style=color:#333>.</span><span style=color:#00c>JspFactory</span><span style=color:#333>.</span><span style=color:#00c>getDefaultFactory</span><span style=color:#333>();</span>

  <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> java<span style=color:#333>.</span><span style=color:#00c>util</span><span style=color:#333>.</span><span style=color:#00c>Map</span><span style=color:#333>&lt;</span>java<span style=color:#333>.</span><span style=color:#00c>lang</span><span style=color:#333>.</span><span style=color:#00c>String</span><span style=color:#333>,</span>java<span style=color:#333>.</span><span style=color:#00c>lang</span><span style=color:#333>.</span><span style=color:#00c>Long</span><span style=color:#333>&gt;</span> _jspx_dependants<span style=color:#333>;</span>

  <span style=color:#080;font-weight:700>private</span> javax<span style=color:#333>.</span><span style=color:#00c>el</span><span style=color:#333>.</span><span style=color:#00c>ExpressionFactory</span> _el_expressionfactory<span style=color:#333>;</span>
  <span style=color:#080;font-weight:700>private</span> org<span style=color:#333>.</span><span style=color:#00c>apache</span><span style=color:#333>.</span><span style=color:#00c>tomcat</span><span style=color:#333>.</span><span style=color:#00c>InstanceManager</span> _jsp_instancemanager<span style=color:#333>;</span>

  <span style=color:#080;font-weight:700>public</span> java<span style=color:#333>.</span><span style=color:#00c>util</span><span style=color:#333>.</span><span style=color:#00c>Map</span><span style=color:#333>&lt;</span>java<span style=color:#333>.</span><span style=color:#00c>lang</span><span style=color:#333>.</span><span style=color:#00c>String</span><span style=color:#333>,</span>java<span style=color:#333>.</span><span style=color:#00c>lang</span><span style=color:#333>.</span><span style=color:#00c>Long</span><span style=color:#333>&gt;</span> <span style=color:#06b;font-weight:700>getDependants</span><span style=color:#333>()</span> <span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>return</span> _jspx_dependants<span style=color:#333>;</span>
  <span style=color:#333>}</span>

  <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>_jspInit</span><span style=color:#333>()</span> <span style=color:#333>{</span>
    _el_expressionfactory <span style=color:#333>=</span> _jspxFactory<span style=color:#333>.</span><span style=color:#00c>getJspApplicationContext</span><span style=color:#333>(</span>getServletConfig<span style=color:#333>().</span><span style=color:#00c>getServletContext</span><span style=color:#333>()).</span><span style=color:#00c>getExpressionFactory</span><span style=color:#333>();</span>
    _jsp_instancemanager <span style=color:#333>=</span> org<span style=color:#333>.</span><span style=color:#00c>apache</span><span style=color:#333>.</span><span style=color:#00c>jasper</span><span style=color:#333>.</span><span style=color:#00c>runtime</span><span style=color:#333>.</span><span style=color:#00c>InstanceManagerFactory</span><span style=color:#333>.</span><span style=color:#00c>getInstanceManager</span><span style=color:#333>(</span>getServletConfig<span style=color:#333>());</span>
  <span style=color:#333>}</span>

  <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>_jspDestroy</span><span style=color:#333>()</span> <span style=color:#333>{</span>
  <span style=color:#333>}</span>

  <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>_jspService</span><span style=color:#333>(</span><span style=color:#080;font-weight:700>final</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>http</span><span style=color:#333>.</span><span style=color:#00c>HttpServletRequest</span> request<span style=color:#333>,</span> <span style=color:#080;font-weight:700>final</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>http</span><span style=color:#333>.</span><span style=color:#00c>HttpServletResponse</span> response<span style=color:#333>)</span>
        <span style=color:#080;font-weight:700>throws</span> java<span style=color:#333>.</span><span style=color:#00c>io</span><span style=color:#333>.</span><span style=color:#00c>IOException</span><span style=color:#333>,</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>ServletException</span> <span style=color:#333>{</span>

    <span style=color:#080;font-weight:700>final</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>jsp</span><span style=color:#333>.</span><span style=color:#00c>PageContext</span> pageContext<span style=color:#333>;</span>
    javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>http</span><span style=color:#333>.</span><span style=color:#00c>HttpSession</span> session <span style=color:#333>=</span> <span style=color:#080;font-weight:700>null</span><span style=color:#333>;</span>
    <span style=color:#080;font-weight:700>final</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>ServletContext</span> application<span style=color:#333>;</span>
    <span style=color:#080;font-weight:700>final</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>ServletConfig</span> config<span style=color:#333>;</span>
    javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>jsp</span><span style=color:#333>.</span><span style=color:#00c>JspWriter</span> out <span style=color:#333>=</span> <span style=color:#080;font-weight:700>null</span><span style=color:#333>;</span>
    <span style=color:#080;font-weight:700>final</span> java<span style=color:#333>.</span><span style=color:#00c>lang</span><span style=color:#333>.</span><span style=color:#00c>Object</span> page <span style=color:#333>=</span> <span style=color:#080;font-weight:700>this</span><span style=color:#333>;</span>
    javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>jsp</span><span style=color:#333>.</span><span style=color:#00c>JspWriter</span> _jspx_out <span style=color:#333>=</span> <span style=color:#080;font-weight:700>null</span><span style=color:#333>;</span>
    javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>jsp</span><span style=color:#333>.</span><span style=color:#00c>PageContext</span> _jspx_page_context <span style=color:#333>=</span> <span style=color:#080;font-weight:700>null</span><span style=color:#333>;</span>


    <span style=color:#080;font-weight:700>try</span> <span style=color:#333>{</span>
      response<span style=color:#333>.</span><span style=color:#00c>setContentType</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;text/html;charset=UTF-8&#34;</span><span style=color:#333>);</span>
      pageContext <span style=color:#333>=</span> _jspxFactory<span style=color:#333>.</span><span style=color:#00c>getPageContext</span><span style=color:#333>(</span><span style=color:#080;font-weight:700>this</span><span style=color:#333>,</span> request<span style=color:#333>,</span> response<span style=color:#333>,</span> <span style=color:#080;font-weight:700>null</span><span style=color:#333>,</span> <span style=color:#080;font-weight:700>true</span><span style=color:#333>,</span> 8192<span style=color:#333>,</span> <span style=color:#080;font-weight:700>true</span><span style=color:#333>);</span>
      _jspx_page_context <span style=color:#333>=</span> pageContext<span style=color:#333>;</span>
      application <span style=color:#333>=</span> pageContext<span style=color:#333>.</span><span style=color:#00c>getServletContext</span><span style=color:#333>();</span>
      config <span style=color:#333>=</span> pageContext<span style=color:#333>.</span><span style=color:#00c>getServletConfig</span><span style=color:#333>();</span>
      session <span style=color:#333>=</span> pageContext<span style=color:#333>.</span><span style=color:#00c>getSession</span><span style=color:#333>();</span>
      out <span style=color:#333>=</span> pageContext<span style=color:#333>.</span><span style=color:#00c>getOut</span><span style=color:#333>();</span>
      _jspx_out <span style=color:#333>=</span> out<span style=color:#333>;</span>

      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;html&gt;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;head&gt;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;    &lt;title&gt;Welcome&lt;/title&gt;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;/head&gt;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;body&gt;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;    &lt;h1&gt;&#34;</span><span style=color:#333>);</span>

        out<span style=color:#333>.</span><span style=color:#00c>println</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;Hello &#34;</span><span style=color:#333>+</span>request<span style=color:#333>.</span><span style=color:#00c>getParameter</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;name&#34;</span><span style=color:#333>)+</span><span style=background-color:#fff0f0>&#34;!&#34;</span><span style=color:#333>);</span>
    
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;/h1&gt;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;/body&gt;\r\n&#34;</span><span style=color:#333>);</span>
      out<span style=color:#333>.</span><span style=color:#00c>write</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;&lt;/html&gt;\r\n&#34;</span><span style=color:#333>);</span>
    <span style=color:#333>}</span> <span style=color:#080;font-weight:700>catch</span> <span style=color:#333>(</span>java<span style=color:#333>.</span><span style=color:#00c>lang</span><span style=color:#333>.</span><span style=color:#00c>Throwable</span> t<span style=color:#333>)</span> <span style=color:#333>{</span>
      <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(!(</span>t <span style=color:#080;font-weight:700>instanceof</span> javax<span style=color:#333>.</span><span style=color:#00c>servlet</span><span style=color:#333>.</span><span style=color:#00c>jsp</span><span style=color:#333>.</span><span style=color:#00c>SkipPageException</span><span style=color:#333>)){</span>
        out <span style=color:#333>=</span> _jspx_out<span style=color:#333>;</span>
        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>out <span style=color:#333>!=</span> <span style=color:#080;font-weight:700>null</span> <span style=color:#333>&amp;&amp;</span> out<span style=color:#333>.</span><span style=color:#00c>getBufferSize</span><span style=color:#333>()</span> <span style=color:#333>!=</span> 0<span style=color:#333>)</span>
          <span style=color:#080;font-weight:700>try</span> <span style=color:#333>{</span> out<span style=color:#333>.</span><span style=color:#00c>clearBuffer</span><span style=color:#333>();</span> <span style=color:#333>}</span> <span style=color:#080;font-weight:700>catch</span> <span style=color:#333>(</span>java<span style=color:#333>.</span><span style=color:#00c>io</span><span style=color:#333>.</span><span style=color:#00c>IOException</span> e<span style=color:#333>)</span> <span style=color:#333>{}</span>
        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>_jspx_page_context <span style=color:#333>!=</span> <span style=color:#080;font-weight:700>null</span><span style=color:#333>)</span> _jspx_page_context<span style=color:#333>.</span><span style=color:#00c>handlePageException</span><span style=color:#333>(</span>t<span style=color:#333>);</span>
        <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>throw</span> <span style=color:#080;font-weight:700>new</span> ServletException<span style=color:#333>(</span>t<span style=color:#333>);</span>
      <span style=color:#333>}</span>
    <span style=color:#333>}</span> <span style=color:#080;font-weight:700>finally</span> <span style=color:#333>{</span>
      _jspxFactory<span style=color:#333>.</span><span style=color:#00c>releasePageContext</span><span style=color:#333>(</span>_jspx_page_context<span style=color:#333>);</span>
    <span style=color:#333>}</span>
  <span style=color:#333>}</span>
<span style=color:#333>}</span>

</code></pre></div><p>可见JSP文件会在执行前首先被编译成一个Servlet程序，所以我们访问welcome.jsp时其实是在访问welcome_jsp.java中的Servlet。</p>
<h2 id=tomcat>Tomcat</h2>
<p>Tomcat是一种轻量级的Web应用服务器，也是Servlet/JSP规范的参考实现。它不只是一个静态资源服务器，更是一个动态资源处理容器，能够管理Servlet/JSP应用程序的生命周期。</p>
<h3 id=standalone-tomcat>Standalone Tomcat</h3>
<h3 id=embedded-tomcat>Embedded Tomcat</h3>
<p>Java Web应用程序总是需要一个可以运行这些应用程序的Tomcat，但是在每台开发机器上都安装和配置一个本地Tomcat会非常耗时。此外，开发人员如果想要运行 Web 应用程序，则需要手动管理依赖项。</p>
<p>Maven 有一个 tomcat 插件，可以让我们运行嵌入式 tomcat 实例，而无需安装本地 tomcat 服务器。</p>
<h3 id=maven-tomcat-plugin>Maven Tomcat Plugin</h3>
<p><strong>Maven plugin config</strong>：</p>
<h2 id=data-access>Data Access</h2>
<p>在Web应用开发中，除了页面显示和URL请求处理外，数据存储和访问也是非常重要的一个环节。Java为开发者提供了多种数据访问方式，从低层次到高层次，从底层API到高级框架。</p>
<h3 id=jdbc>JDBC</h3>
<p>JDBC(Java Database Connectivity)是一套Java应用访问数据库的接口规范，主要由java.sql和javax.sql两个包组成。当Java程序尝试访问数据库时，实际上是通过使用该数据库公司提供的JDBC驱动进行访问的，其流程如图5所示。换句话说，第三方提供的JDBC驱动实现了JDBC接口，向上层Java应用隐藏了访问逻辑，从而简化了Java程序员的工作量。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-5-17/jdbc_workflow.png alt="图5 JDBC工作流程">
</figure></p>
<p><strong>JDBC Driver</strong>：</p>
<p>想要使用JDBC驱动，我们只需要在工程中添加一个Maven依赖即可，比如使用MySQL的JDBC驱动：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#070>&lt;dependency&gt;</span>
    <span style=color:#070>&lt;groupId&gt;</span>mysql<span style=color:#070>&lt;/groupId&gt;</span>
    <span style=color:#070>&lt;artifactId&gt;</span>mysql-connector-java<span style=color:#070>&lt;/artifactId&gt;</span>
    <span style=color:#070>&lt;version&gt;</span>5.1.47<span style=color:#070>&lt;/version&gt;</span>
    <span style=color:#070>&lt;scope&gt;</span>runtime<span style=color:#070>&lt;/scope&gt;</span>
<span style=color:#070>&lt;/dependency&gt;</span>
</code></pre></div><p><strong>JDBC Connection</strong>:</p>
<p>使用JDBC时，首先需要加载驱动并建立与数据库的连接。连接过程中需要提供数据库URL、用户名和密码等信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#888>// JDBC连接的URL, 不同数据库有不同的格式:
</span><span style=color:#888></span>String JDBC_URL <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#34;jdbc:mysql://localhost:3306/test&#34;</span><span style=color:#333>;</span>
String JDBC_USER <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#34;root&#34;</span><span style=color:#333>;</span>
String JDBC_PASSWORD <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#34;password&#34;</span><span style=color:#333>;</span>
<span style=color:#888>// 获取连接:
</span><span style=color:#888></span>Connection conn <span style=color:#333>=</span> DriverManager<span style=color:#333>.</span><span style=color:#00c>getConnection</span><span style=color:#333>(</span>JDBC_URL<span style=color:#333>,</span> JDBC_USER<span style=color:#333>,</span> JDBC_PASSWORD<span style=color:#333>);</span>
<span style=color:#888>// TODO: 访问数据库...
</span><span style=color:#888>// 关闭连接:
</span><span style=color:#888></span>conn<span style=color:#333>.</span><span style=color:#00c>close</span><span style=color:#333>();</span>
</code></pre></div><p><strong>JDBC Query</strong>:</p>
<p>建立连接后，可以通过执行SQL语句来查询数据。JDBC提供了 Statement 和 PreparedStatement 两种方式执行SQL语句。比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>java Statement stmt <span style=color:#333>=</span> conn<span style=color:#333>.</span><span style=color:#00c>createStatement</span><span style=color:#333>();</span>
ResultSet rs <span style=color:#333>=</span> stmt<span style=color:#333>.</span><span style=color:#00c>executeQuery</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;SELECT * FROM users&#34;</span><span style=color:#333>);</span>
</code></pre></div><p>相比Statement，PreparedStatement会对SQL语句进行预编译处理，而这条预编译的SQL查询语句能在将来的查询中重用，这样一来，在重复查询时，它将比Statement对象生成的查询速度快很多。</p>
<p><strong>JDBC CURD</strong>:</p>
<p>除了查询，JDBC还可以执行增删改操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#888>// 插入
</span><span style=color:#888></span>PreparedStatement pstmt <span style=color:#333>=</span> conn<span style=color:#333>.</span><span style=color:#00c>prepareStatement</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;INSERT INTO users(name, age) VALUES(?, ?)&#34;</span><span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>setString</span><span style=color:#333>(</span>1<span style=color:#333>,</span> <span style=background-color:#fff0f0>&#34;John&#34;</span><span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>setInt</span><span style=color:#333>(</span>2<span style=color:#333>,</span> 30<span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>executeUpdate</span><span style=color:#333>();</span>

<span style=color:#888>// 更新
</span><span style=color:#888></span>pstmt <span style=color:#333>=</span> conn<span style=color:#333>.</span><span style=color:#00c>prepareStatement</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;UPDATE users SET age = ? WHERE id = ?&#34;</span><span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>setInt</span><span style=color:#333>(</span>1<span style=color:#333>,</span> 31<span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>setInt</span><span style=color:#333>(</span>2<span style=color:#333>,</span> 1<span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>executeUpdate</span><span style=color:#333>();</span>

<span style=color:#888>// 删除
</span><span style=color:#888></span>pstmt <span style=color:#333>=</span> conn<span style=color:#333>.</span><span style=color:#00c>prepareStatement</span><span style=color:#333>(</span><span style=background-color:#fff0f0>&#34;DELETE FROM users WHERE id = ?&#34;</span><span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>setInt</span><span style=color:#333>(</span>1<span style=color:#333>,</span> 1<span style=color:#333>);</span>
pstmt<span style=color:#333>.</span><span style=color:#00c>executeUpdate</span><span style=color:#333>();</span>
</code></pre></div><p><strong>JDBC Transcation</strong>:</p>
<p>数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的synchronized同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性：</p>
<ul>
<li>Atomicity：原子性</li>
<li>Consistency：一致性</li>
<li>Isolation：隔离性</li>
<li>Durability：持久性</li>
</ul>
<p>要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。</p>
<h3 id=jpa>JPA</h3>
<p>JPA(Java Persistence API，Java持久层API)是一种对象关系映射(Object-Relational Mapping，ORM)的标准规范，旨在简化Java对象与关系数据库之间的持久化操作。它定义了一组注解和接口，用于描述对象与数据库表之间的映射关系，以及执行持久化操作(如创建、查询、更新和删除)所需的API。</p>
<p>2006，JPA1.0首次作为EJB3.0规范的一部分提出。从J2EE6开始，JPA2.0已发展成单独的规范。值得注意的是，JPA是只针对RDBMS的，对于NoSQL没有作用。</p>
<p><strong>Entity</strong>:</p>
<p>JPA基于<a href=https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model target=_blank>E-R模型</a>，即一个关系型数据库可以使用实体、属性和关系进行描述。其中，实体可以是有形的、实际存在的事物(如每个员工)，也可以是抽象的、概念上的事物(如一个部门)。</p>
<p>在实际开发中，实体类往往是一个POJO（Plain Old Java Object），比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>javax.persistence.*</span><span style=color:#333>;</span>  
<span style=color:#555;font-weight:700>@Entity</span>  
<span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Student</span> <span style=color:#333>{</span>  
    <span style=color:#555;font-weight:700>@Id</span>  
    <span style=color:#080;font-weight:700>private</span> <span style=color:#339;font-weight:700>int</span> id<span style=color:#333>;</span>  
    <span style=color:#080;font-weight:700>private</span> String name<span style=color:#333>;</span>  
    <span style=color:#080;font-weight:700>public</span> <span style=color:#06b;font-weight:700>Student</span><span style=color:#333>()</span> <span style=color:#333>{}</span>  
    <span style=color:#080;font-weight:700>public</span> <span style=color:#06b;font-weight:700>Student</span><span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> id<span style=color:#333>)</span>   
    <span style=color:#333>{</span>  
      <span style=color:#080;font-weight:700>this</span><span style=color:#333>.</span><span style=color:#00c>id</span> <span style=color:#333>=</span> id<span style=color:#333>;</span>  
    <span style=color:#333>}</span>  
    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>getId</span><span style=color:#333>()</span>   
    <span style=color:#333>{</span>  
      <span style=color:#080;font-weight:700>return</span> id<span style=color:#333>;</span>  
    <span style=color:#333>}</span>  
    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>setId</span><span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> id<span style=color:#333>)</span>   
    <span style=color:#333>{</span>  
      <span style=color:#080;font-weight:700>this</span><span style=color:#333>.</span><span style=color:#00c>id</span> <span style=color:#333>=</span> id<span style=color:#333>;</span>  
    <span style=color:#333>}</span>  
    <span style=color:#080;font-weight:700>public</span> String <span style=color:#06b;font-weight:700>getName</span><span style=color:#333>()</span>  
    <span style=color:#333>{</span>  
      <span style=color:#080;font-weight:700>return</span> name<span style=color:#333>;</span>   
    <span style=color:#333>}</span>  
    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>setName</span><span style=color:#333>(</span>String name<span style=color:#333>)</span>   
    <span style=color:#333>{</span>  
      <span style=color:#080;font-weight:700>this</span><span style=color:#333>.</span><span style=color:#00c>name</span> <span style=color:#333>=</span> name<span style=color:#333>;</span>  
    <span style=color:#333>}</span>  
<span style=color:#333>}</span>  
</code></pre></div><p><strong>Entity Manager</strong>:</p>
<p>在 JPA 规范中, EntityManager 是完成持久化操作的核心对象。</p>
<p><strong>JPQL</strong>：</p>
<p>Java持久化查询语言（Java Persistence query language，简称 JPQL）定义实体及其持久状态的查询。 查询语言允许您编写可用的查询语句，而不用管底层数据是如何实现存储的。</p>
<p>查询语言使用实体的抽象持久化模式（包括其关系）作为其数据模型，并基于此数据模型定义运算符和表达式。查询的范围跨越包装在同一持久单元中的相关实体的抽象模式。查询语言使用类似SQL的语法来基于实体抽象模式类型和它们之间的关系来选择对象或值。</p>
<h3 id=orm-framework>ORM Framework</h3>
<p>ORM 框架是一种对象关系映射技术，它提供了一种将面向对象的对象模型与关系型数据库中的数据模型相互映射的机制。ORM 框架的主要目标是简化数据持久化操作，使开发人员可以像操作对象一样操作数据库中的数据，而无需直接编写 SQL 语句。常见的 ORM 框架有 Hibernate、MyBatis、EclipseLink 等。</p>
<h2 id=ejb>EJB</h2>
<p>Enterprise JavaBean(EJB)是用于执行应用程序业务逻辑的服务器端组件。EJB是业务层的一部分，通常与Servlet和JSP结合使用。</p>
<p>EJB由容器加载和管理，容器提供事务管理、安全性和线程等服务。EJB通常使用javax.ejb包来实现，该包提供了三种类型的EJB，包括：</p>
<ul>
<li>会话Bean：会话Bean用于为客户端执行特定任务。</li>
<li>实体Bean：实体Bean用于表示持久数据并存储在数据库中。</li>
<li>消息驱动Bean：消息驱动Bean用于异步处理消息。</li>
</ul>
<h2 id=mvc>MVC</h2>
<p>MVC(模型-视图-控制器)是一种软件架构模式。它将应用程序划分为模型(Model)、视图(View)和控制器(Controller)三个部分，各自负责不同的功能。</p>
<h3 id=j2ee-web-application>J2EE Web Application</h3>
<p>在传统的J2EE架构中，EJB扮演模型的角色，负责业务逻辑和数据访问；JSP扮演视图的角色，负责呈现页面内容；而Servlet则扮演控制器的角色，接收请求，调用模型进行业务处理，并选择合适的视图进行响应。在这种结构下，一个请求首先根据映射规则到达相应的Servlet，接着该Servlet执行业务逻辑(通常委托给EJB)，最后根据返回值，将相应的JSP文件渲染并返回给客户端。</p>
<p><figure>
<img src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS8yMjljZjlmZjViMTcyOWVhZjQwOGZhYzU2MjM4ZWViM19iLnBuZw alt="图5 J2EE架构">
</figure></p>
<h3 id=ssm>SSM</h3>
<p>使用Servlet/JSP/EJB开发Web应用仍有缺点，比如：</p>
<ul>
<li>Servlet提供的接口仍然偏底层，需要实现Servlet调用相关接口；</li>
<li>JSP对页面开发不友好，更好的替代品是模板引擎；</li>
<li>业务逻辑最好由纯粹的Java类实现，而不是强迫继承自Servlet。</li>
</ul>
<p>这些缺陷也催生了大量优秀的MVC框架。它们能提供更高层次的抽象，使得开发人员可以专注于业务逻辑的实现，而不必过多关注底层的Web容器细节。其中，最流行的正是Spring MVC框架。和大多数MVC框架类似，Spring MVC也是请求驱动并围绕一个DispatcherServlet设计的。这个DispatcherServlet负责接收HTTP请求并将其分发到合适的控制器(Controller)进行处理。对于一个使用Spring MVC开发的Web应用来说，用户的请求按如下顺序处理:</p>
<ul>
<li>前端控制器DispatcherServlet接收到请求后，根据请求映射信息，找到对应处理该请求的控制器方法；</li>
<li>执行该方法，得到一个视图名称；</li>
<li>根据配置的视图解析器，将控制器返回的视图名称解析为实际的视图对象，比如JSP文件；</li>
<li>视图解析器将模型数据渲染到视图对象中；</li>
<li>将渲染后的视图内容返回给客户端进行展示。</li>
</ul>
<p><figure>
<img src=https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/images/mvc.png alt="图6 Spring MVC Workflow">
</figure></p>
<p>随着前后端分离架构的兴起，Web应用开发模式也发生了变化。传统的JSP视图已经被淘汰，取而代之的是前端框架(如React、Vue、Angular)构建的单页面应用(SPA)。此时，Web应用后端的架构通常采用Controller+Service+DAL的模式，控制器(Controller)负责接收请求和响应，服务层(Service)负责实现业务逻辑，数据访问层(Data Access Layer，DAL)负责与数据库交互。这也正是目前流行的SSM(Spring+Spring MVC+MyBatis)框架所体现的架构模式。</p>
<h2 id=design-style>Design Style</h2>
<h3 id=data-access-layer>Data Access Layer</h3>
<ul>
<li><a href=https://stackoverflow.com/questions/8550124/what-is-the-difference-between-dao-and-repository-patterns target=_blank>DAO vs Repository</a></li>
<li><a href=https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans target=_blank>DTO, VO, POJO, Entity, JavaBean</a></li>
</ul>
<h3 id=domain-driven-design>Domain Driven Design</h3>
<p><a href=https://blog.pragmatists.com/domain-driven-design-vs-anemic-model-how-do-they-differ-ffdee9371a86 target=_blank>Domain-Driven Design vs. anemic model. How do they differ?</a></p>
</div>
</div>
</article>
</div>
</main>
<footer>
© Copyright <a href=https://github.com/Zhytou>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae>Vitae</a> theme for <a href=https://gohugo.io>Hugo</a>
</footer><script src=/js/dark-mode.js></script>
</body>
</html>
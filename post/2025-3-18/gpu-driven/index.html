<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<title>GPU-Driven Pipeline | Zhytou</title>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=generator content="Hugo 0.91.2">
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel="shortcut icon" href=/favicon.ico>
<link rel=stylesheet type=text/css media=screen href=/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=/css/main.css>
<link rel=stylesheet type=text/css media=screen href=/css/all.css>
<meta property="og:title" content="GPU-Driven Pipeline">
<meta property="og:description" content="Bottleneck of Traditional Rendering Pipeline Key Ideas of GPU-Driven Pipeline  Indirect Draw Compute Shader GPU-Driven Culling Mesh Cluster Rendering   Nanite: State-of-the-Art in GPU-Driven Pipeline Architecture  Geometory Represetation Runtime LoD Selection Nanite Rasterization    GPU驱动管线（GPU-Driven Pipeline）是一种将原本由CPU承担的大量渲染任务转移到GPU上进行处理的渲染管线架构。在传统渲染管线中，CPU负责管理场景中的大量数据，如模型的加载、裁剪、排序以及绘制调用的提交等，这使得CPU成为渲染流程中的瓶颈。而GPU驱动管线则通过Indirect Draw、Compute Shader等机制让GPU能够更自主地处理这些任务，充分发挥其强大的并行计算能力，从而突破了渲染性能。
Bottleneck of Traditional Rendering Pipeline  High CPU overload   视锥/遮挡裁剪 准备drawcall   CPU can not follow up GPU
  GPU state exchange overhead when solving large amount of drawcalls">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhytou.github.io/post/2025-3-18/gpu-driven/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2025-03-18T19:46:08+08:00">
<meta property="article:modified_time" content="2025-03-18T19:46:08+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="GPU-Driven Pipeline">
<meta name=twitter:description content="Bottleneck of Traditional Rendering Pipeline Key Ideas of GPU-Driven Pipeline  Indirect Draw Compute Shader GPU-Driven Culling Mesh Cluster Rendering   Nanite: State-of-the-Art in GPU-Driven Pipeline Architecture  Geometory Represetation Runtime LoD Selection Nanite Rasterization    GPU驱动管线（GPU-Driven Pipeline）是一种将原本由CPU承担的大量渲染任务转移到GPU上进行处理的渲染管线架构。在传统渲染管线中，CPU负责管理场景中的大量数据，如模型的加载、裁剪、排序以及绘制调用的提交等，这使得CPU成为渲染流程中的瓶颈。而GPU驱动管线则通过Indirect Draw、Compute Shader等机制让GPU能够更自主地处理这些任务，充分发挥其强大的并行计算能力，从而突破了渲染性能。
Bottleneck of Traditional Rendering Pipeline  High CPU overload   视锥/遮挡裁剪 准备drawcall   CPU can not follow up GPU
  GPU state exchange overhead when solving large amount of drawcalls">
<meta itemprop=name content="GPU-Driven Pipeline">
<meta itemprop=description content="Bottleneck of Traditional Rendering Pipeline Key Ideas of GPU-Driven Pipeline  Indirect Draw Compute Shader GPU-Driven Culling Mesh Cluster Rendering   Nanite: State-of-the-Art in GPU-Driven Pipeline Architecture  Geometory Represetation Runtime LoD Selection Nanite Rasterization    GPU驱动管线（GPU-Driven Pipeline）是一种将原本由CPU承担的大量渲染任务转移到GPU上进行处理的渲染管线架构。在传统渲染管线中，CPU负责管理场景中的大量数据，如模型的加载、裁剪、排序以及绘制调用的提交等，这使得CPU成为渲染流程中的瓶颈。而GPU驱动管线则通过Indirect Draw、Compute Shader等机制让GPU能够更自主地处理这些任务，充分发挥其强大的并行计算能力，从而突破了渲染性能。
Bottleneck of Traditional Rendering Pipeline  High CPU overload   视锥/遮挡裁剪 准备drawcall   CPU can not follow up GPU
  GPU state exchange overhead when solving large amount of drawcalls"><meta itemprop=datePublished content="2025-03-18T19:46:08+08:00">
<meta itemprop=dateModified content="2025-03-18T19:46:08+08:00">
<meta itemprop=wordCount content="175">
<meta itemprop=keywords content>
</head>
<body>
<header>
<div id=avatar>
<a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a>
</div>
<div id=titletext>
<h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2>
</div>
<div id=title-description>
<p id=subtitle>May the force be with me.</p>
<div id=social>
<nav><ul>
<li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id=mainmenu>
<nav>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/post>Posts</a></li>
<li><a href=/about>About</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class=post>
<article>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>18</span>
<span class=rest>Mar 2025</span>
</div>
</div>
<div class=matter>
<h1 class=title>GPU-Driven Pipeline</h1>
<p class=post-meta>
<span class=post-meta>
</span>
</p>
</div>
</div>
<div class=markdown>
<ul>
<li><a href=#bottleneck-of-traditional-rendering-pipeline>Bottleneck of Traditional Rendering Pipeline</a></li>
<li><a href=#key-ideas-of-gpu-driven-pipeline>Key Ideas of GPU-Driven Pipeline</a>
<ul>
<li><a href=#indirect-draw>Indirect Draw</a></li>
<li><a href=#compute-shader>Compute Shader</a></li>
<li><a href=#gpu-driven-culling>GPU-Driven Culling</a></li>
<li><a href=#mesh-cluster-rendering>Mesh Cluster Rendering</a></li>
</ul>
</li>
<li><a href=#nanite-state-of-the-art-in-gpu-driven-pipeline-architecture>Nanite: State-of-the-Art in GPU-Driven Pipeline Architecture</a>
<ul>
<li><a href=#geometory-represetation>Geometory Represetation</a></li>
<li><a href=#runtime-lod-selection>Runtime LoD Selection</a></li>
<li><a href=#nanite-rasterization>Nanite Rasterization</a></li>
</ul>
</li>
</ul>
<p>GPU驱动管线（GPU-Driven Pipeline）是一种将原本由CPU承担的大量渲染任务转移到GPU上进行处理的渲染管线架构。在传统渲染管线中，CPU负责管理场景中的大量数据，如模型的加载、裁剪、排序以及绘制调用的提交等，这使得CPU成为渲染流程中的瓶颈。而GPU驱动管线则通过Indirect Draw、Compute Shader等机制让GPU能够更自主地处理这些任务，充分发挥其强大的并行计算能力，从而突破了渲染性能。</p>
<h2 id=bottleneck-of-traditional-rendering-pipeline>Bottleneck of Traditional Rendering Pipeline</h2>
<ol>
<li><strong>High CPU overload</strong></li>
</ol>
<ul>
<li>视锥/遮挡裁剪</li>
<li>准备drawcall</li>
</ul>
<ol start=2>
<li>
<p><strong>CPU can not follow up GPU</strong></p>
</li>
<li>
<p><strong>GPU state exchange overhead when solving large amount of drawcalls</strong></p>
</li>
</ol>
<h2 id=key-ideas-of-gpu-driven-pipeline>Key Ideas of GPU-Driven Pipeline</h2>
<h3 id=indirect-draw>Indirect Draw</h3>
<p><strong>Draw from GPU buffer</strong></p>
<p>GPU驱动管线的核心目标是最小化CPU参与渲染流程的频率。传统绘制方式（如 glDrawArray/glDrawElements）需由CPU直接传递绘制参数（如图元数量、索引范围等），这会导致CPU-GPU通信开销较高。间接绘制则将这些参数存储在GPU可访问的缓冲区中，由GPU自行读取参数并执行绘制，从而大幅减少CPU的介入。</p>
<p><strong>Api support</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#888>// CPU直接传递参数
</span><span style=color:#888></span>glDrawElements(GL_TRIANGLES, <span style=color:#00d;font-weight:700>6</span>, GL_UNSIGNED_INT, <span style=color:#00d;font-weight:700>0</span>); 

<span style=color:#888>// 参数来自GPU缓冲区
</span><span style=color:#888></span>glDrawElementsIndirect(GL_TRIANGLES, GL_UNSIGNED_INT, buffer_offset);
</code></pre></div><h3 id=compute-shader>Compute Shader</h3>
<p><strong>High-speed general purpose computing</strong></p>
<p>为了动态生成间接绘制的参数，现代渲染管线又引入了另一项关键技术，也即通用计算着色器Compute Shader。与传统的Vertex Shader和Fragment Shader不同，Compute shader不直接参与图形渲染，而是专注于利用GPU的大规模并行计算能力执行非图形渲染任务。比如，根据场景数据来决定实际需要绘制的图元数量，从而避免不必要的渲染操作。</p>
<p><strong>Key Features</strong></p>
<ul>
<li>Parallel Processing：Compute Shader可以同时处理数千个线程，极大地提高了数据处理效率。</li>
<li>Shared Memory：支持线程组内的快速数据共享，减少全局内存访问。</li>
<li>Barriers：提供线程同步机制，确保数据一致性。</li>
<li>Atomic Operations：支持原子操作，如递增、比较和交换等。</li>
</ul>
<p><strong>Typical Use Cases</strong></p>
<ul>
<li>Tessellation Control：根据 LOD 需求动态生成网格细分级别。</li>
<li>Culling：执行视锥体剔除、遮挡剔除等操作，筛选可见物体。</li>
<li>Physics Simulation：实现流体模拟、布料模拟等物理效果。</li>
</ul>
<h3 id=gpu-driven-culling>GPU-Driven Culling</h3>
<p>裁剪（Culling）是根据观察区域确定图形对象可见部分并移除不可见部分的过程。它通过减少冗余数据处理，显著提升渲染效率。</p>
<p><strong>Conventional culling</strong></p>
<p>在传统渲染管线中，可用于裁剪的时间点包括：</p>
<ul>
<li>加载或更新模型时；</li>
<li>光栅化之间；</li>
<li>光栅化之后片元着色之前。</li>
</ul>
<p>其中，将数据传入顶点着色器之前的裁剪任务由CPU驱动，它包括：</p>
<ul>
<li>细节剔除（Detail Culling）：根据物体与相机的距离，选择不同细节程度的模型进行渲染。这一过程中，CPU负责根据物体的距离和其他条件来选择合适的层次细节（Level of Detail, LoD）模型，然后将其传递给GPU进行渲染。</li>
<li>遮挡裁剪（Soft Occlusion Culling）：预处理判断物体遮挡关系，并以剔除。这一操作可以在CPU端进行预处理，通过一些算法（如八叉树、层次包围盒等）来快速判断，也可以在GPU端使用硬件加速算法如Early-Z等来实现。</li>
</ul>
<p>而由GPU硬件完成的裁剪则包括：</p>
<ul>
<li>视锥剔除（Frustum Culling）：检测物体是否位于视锥体内，直接剔除或裁剪视锥体外部的图元。</li>
<li>背面剔除（Backface Culling）：基于三角形面的法线方向（如右手定则）剔除不可见的背面图元，减少无效渲染计算。</li>
</ul>
<p><strong>Compute based culling</strong></p>
<p>随着GPU计算能力的提升，GPU-Driven Culling技术逐渐成为主流。它将裁剪任务从CPU转移到GPU上进行处理，充分发挥GPU的并行计算能力，提升渲染效率。具体而言，它常常和间接绘制参数生成的逻辑放在一起，由Compute Shader一并实现。</p>
<h3 id=mesh-cluster-rendering>Mesh Cluster Rendering</h3>
<p><strong>Mesh clustering</strong></p>
<p>通过将场景中具有​​相似渲染属性​​（如材质、着色器、纹理、渲染状态等）的网格对象动态划分为若干​​集群（Cluster）​​，每个集群内的子网格（Sub-Mesh）共享相同的渲染资源。</p>
<p><strong>Avoid frequent state switch</strong></p>
<p>通过批量处理同一集群内的网格数据，从而最小化CPU与GPU之间的状态切换开销，实现高效批量渲染。</p>
<h2 id=nanite-state-of-the-art-in-gpu-driven-pipeline-architecture>Nanite: State-of-the-Art in GPU-Driven Pipeline Architecture</h2>
<p>Nanite是虚幻引擎5引入的​​虚拟化几何系统​​，旨在实现​​电影级高精度模型​​的实时渲染。其核心思想是通过智能的​​数据流式加载​和​​GPU驱动的渲染管线​​，动态适应不同视角下的几何细节需求，从而突破传统渲染的三角形数量限制。</p>
<h3 id=geometory-represetation>Geometory Represetation</h3>
<h3 id=runtime-lod-selection>Runtime LoD Selection</h3>
<h3 id=nanite-rasterization>Nanite Rasterization</h3>
<p><strong>Hardware Rasterization</strong></p>
</div>
</div>
</article>
</div>
</main>
<footer>
© Copyright <a href=https://github.com/Zhytou>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae>Vitae</a> theme for <a href=https://gohugo.io>Hugo</a>
</footer><script src=/js/dark-mode.js></script>
</body>
</html>
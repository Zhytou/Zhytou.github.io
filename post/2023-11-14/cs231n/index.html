<!doctype html><html lang=en><head><meta charset=UTF-8><title>CS231n笔记 | Zhytou</title>
<meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Hugo 0.121.1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><meta property="og:title" content="CS231n笔记"><meta property="og:description" content="这篇博客流水线的记录一下自己学习CS231n的笔记。
Image Classification 图像分类是CV领域中最核心任务之一。它指的是，给定一些标签并将图片预测为一个或多个预定义类别中的过程。
一些潜在的挑战包括：
Viewpoint variation Illumination Background Clutter Occlusion Deformation Machine Learning: Data-Driven Approach 使用机器学习解决图像分类的流程是：
收集数据并定义标签； 使用机器学习算法训练分类器； 在测试集上评估分类器的准确率。 Nearest Neighbor Classifier 邻近算法的核心思想就是:
确定测试实例与每个训练实例的距离(相似程度); 从中选择距离最小的那个训练实例，称为&#34;最近的邻居&#34;; 将测试实例预测为这个&#34;最近邻居&#34;的类别。 值得注意的是，近邻算法是&#34;惰性学习&#34;模型家族的一部分，这意味着它不会根据训练集主动学习或者拟合出一个函数来对新进入的样本进行判断，而是单纯的记住训练集中所有的样本，所以它实际上没有所谓的&#34;训练&#34;过程，而是在需要进行预测的时候从自己的训练集样本中查找与新进入样本最相似的样本，即寻找最近邻来获得预测结果。
Distance Metric：
一些常见的距离度量方法包括：
L1 Manhattan distance: $d_{L1}(x, y) = \sum_{i=1}^n |x_i - y_i|$ L2 Euclidean distance: $d_{L2}(x, y) = \sqrt{\sum_{i=1}^n (x_i - y_i)^2}$ k-Nearest Neighbor Classifier：
k邻近算法是使用离待测试点k个最近邻的点来对分类进行预测的一种算法。相比普通最近邻算法只考虑测试实例的单一最近邻居，而k邻域算法考虑测试实例的k个最近邻居。
对于分类问题，k邻域算法通过majority voting的方式从k个最近邻居中获得最常见的类别作为预测类别，即：选择k个邻居中频率最高的类别作为返回值。
Validation sets for Hyperparameter tuning Hyperparameters：
在机器学习中，超参数是在开始学习过程之前设置用于控制学习过程的参数，而不是通过训练得到的参数数据。比如，在kNN算法中，使用邻居点的数量k和计算距离的distance metric就是超参数。
Cross-validation：
交叉验证在训练集和测试集的基础上，通过进一步将训练数据集随机平均划分为K个互不重叠的子集，然后将其中一个子集作为验证集，其余K-1个子集作为临时训练集。这样循环K次，每次选择一个不同的验证集，其余作为临时训练集，取平均值作为最终估计值。
因为交叉验证可以重复利用原始数据集，较好地评估不同超参数设置下的泛化能力，所以它一般常用来确认和选择模型的超参数。
Linear Classifier 线性分类的方法一般由2个部分组成：决策函数和损失函数。同时，它也是神经网络和卷积神经网络的基础。"><meta property="og:type" content="article"><meta property="og:url" content="https://zhytou.github.io/post/2023-11-14/cs231n/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-11-14T09:58:05+08:00"><meta property="article:modified_time" content="2023-11-14T09:58:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CS231n笔记"><meta name=twitter:description content="这篇博客流水线的记录一下自己学习CS231n的笔记。
Image Classification 图像分类是CV领域中最核心任务之一。它指的是，给定一些标签并将图片预测为一个或多个预定义类别中的过程。
一些潜在的挑战包括：
Viewpoint variation Illumination Background Clutter Occlusion Deformation Machine Learning: Data-Driven Approach 使用机器学习解决图像分类的流程是：
收集数据并定义标签； 使用机器学习算法训练分类器； 在测试集上评估分类器的准确率。 Nearest Neighbor Classifier 邻近算法的核心思想就是:
确定测试实例与每个训练实例的距离(相似程度); 从中选择距离最小的那个训练实例，称为&#34;最近的邻居&#34;; 将测试实例预测为这个&#34;最近邻居&#34;的类别。 值得注意的是，近邻算法是&#34;惰性学习&#34;模型家族的一部分，这意味着它不会根据训练集主动学习或者拟合出一个函数来对新进入的样本进行判断，而是单纯的记住训练集中所有的样本，所以它实际上没有所谓的&#34;训练&#34;过程，而是在需要进行预测的时候从自己的训练集样本中查找与新进入样本最相似的样本，即寻找最近邻来获得预测结果。
Distance Metric：
一些常见的距离度量方法包括：
L1 Manhattan distance: $d_{L1}(x, y) = \sum_{i=1}^n |x_i - y_i|$ L2 Euclidean distance: $d_{L2}(x, y) = \sqrt{\sum_{i=1}^n (x_i - y_i)^2}$ k-Nearest Neighbor Classifier：
k邻近算法是使用离待测试点k个最近邻的点来对分类进行预测的一种算法。相比普通最近邻算法只考虑测试实例的单一最近邻居，而k邻域算法考虑测试实例的k个最近邻居。
对于分类问题，k邻域算法通过majority voting的方式从k个最近邻居中获得最常见的类别作为预测类别，即：选择k个邻居中频率最高的类别作为返回值。
Validation sets for Hyperparameter tuning Hyperparameters：
在机器学习中，超参数是在开始学习过程之前设置用于控制学习过程的参数，而不是通过训练得到的参数数据。比如，在kNN算法中，使用邻居点的数量k和计算距离的distance metric就是超参数。
Cross-validation：
交叉验证在训练集和测试集的基础上，通过进一步将训练数据集随机平均划分为K个互不重叠的子集，然后将其中一个子集作为验证集，其余K-1个子集作为临时训练集。这样循环K次，每次选择一个不同的验证集，其余作为临时训练集，取平均值作为最终估计值。
因为交叉验证可以重复利用原始数据集，较好地评估不同超参数设置下的泛化能力，所以它一般常用来确认和选择模型的超参数。
Linear Classifier 线性分类的方法一般由2个部分组成：决策函数和损失函数。同时，它也是神经网络和卷积神经网络的基础。"><meta itemprop=name content="CS231n笔记"><meta itemprop=description content="这篇博客流水线的记录一下自己学习CS231n的笔记。
Image Classification 图像分类是CV领域中最核心任务之一。它指的是，给定一些标签并将图片预测为一个或多个预定义类别中的过程。
一些潜在的挑战包括：
Viewpoint variation Illumination Background Clutter Occlusion Deformation Machine Learning: Data-Driven Approach 使用机器学习解决图像分类的流程是：
收集数据并定义标签； 使用机器学习算法训练分类器； 在测试集上评估分类器的准确率。 Nearest Neighbor Classifier 邻近算法的核心思想就是:
确定测试实例与每个训练实例的距离(相似程度); 从中选择距离最小的那个训练实例，称为&#34;最近的邻居&#34;; 将测试实例预测为这个&#34;最近邻居&#34;的类别。 值得注意的是，近邻算法是&#34;惰性学习&#34;模型家族的一部分，这意味着它不会根据训练集主动学习或者拟合出一个函数来对新进入的样本进行判断，而是单纯的记住训练集中所有的样本，所以它实际上没有所谓的&#34;训练&#34;过程，而是在需要进行预测的时候从自己的训练集样本中查找与新进入样本最相似的样本，即寻找最近邻来获得预测结果。
Distance Metric：
一些常见的距离度量方法包括：
L1 Manhattan distance: $d_{L1}(x, y) = \sum_{i=1}^n |x_i - y_i|$ L2 Euclidean distance: $d_{L2}(x, y) = \sqrt{\sum_{i=1}^n (x_i - y_i)^2}$ k-Nearest Neighbor Classifier：
k邻近算法是使用离待测试点k个最近邻的点来对分类进行预测的一种算法。相比普通最近邻算法只考虑测试实例的单一最近邻居，而k邻域算法考虑测试实例的k个最近邻居。
对于分类问题，k邻域算法通过majority voting的方式从k个最近邻居中获得最常见的类别作为预测类别，即：选择k个邻居中频率最高的类别作为返回值。
Validation sets for Hyperparameter tuning Hyperparameters：
在机器学习中，超参数是在开始学习过程之前设置用于控制学习过程的参数，而不是通过训练得到的参数数据。比如，在kNN算法中，使用邻居点的数量k和计算距离的distance metric就是超参数。
Cross-validation：
交叉验证在训练集和测试集的基础上，通过进一步将训练数据集随机平均划分为K个互不重叠的子集，然后将其中一个子集作为验证集，其余K-1个子集作为临时训练集。这样循环K次，每次选择一个不同的验证集，其余作为临时训练集，取平均值作为最终估计值。
因为交叉验证可以重复利用原始数据集，较好地评估不同超参数设置下的泛化能力，所以它一般常用来确认和选择模型的超参数。
Linear Classifier 线性分类的方法一般由2个部分组成：决策函数和损失函数。同时，它也是神经网络和卷积神经网络的基础。"><meta itemprop=datePublished content="2023-11-14T09:58:05+08:00"><meta itemprop=dateModified content="2023-11-14T09:58:05+08:00"><meta itemprop=wordCount content="209"><meta itemprop=keywords content></head><body><header><div id=avatar><a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a></div><div id=titletext><h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2></div><div id=title-description><p id=subtitle>May the force be with me.</p><div id=social><nav><ul><li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li><li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>Posts</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>14</span>
<span class=rest>Nov 2023</span></div></div><div class=matter><h1 class=title>CS231n笔记</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><p>这篇博客流水线的记录一下自己学习<a href=https://cs231n.github.io/ target=_blank>CS231n</a>的笔记。</p><h2 id=image-classification>Image Classification</h2><p>图像分类是CV领域中最核心任务之一。它指的是，给定一些标签并将图片预测为一个或多个预定义类别中的过程。</p><p>一些潜在的挑战包括：</p><ul><li>Viewpoint variation</li><li>Illumination</li><li>Background Clutter</li><li>Occlusion</li><li>Deformation</li></ul><h3 id=machine-learning-data-driven-approach>Machine Learning: Data-Driven Approach</h3><p>使用机器学习解决图像分类的流程是：</p><ul><li>收集数据并定义标签；</li><li>使用机器学习算法训练分类器；</li><li>在测试集上评估分类器的准确率。</li></ul><h3 id=nearest-neighbor-classifier>Nearest Neighbor Classifier</h3><p>邻近算法的核心思想就是:</p><ul><li>确定测试实例与每个训练实例的距离(相似程度);</li><li>从中选择距离最小的那个训练实例，称为"最近的邻居";</li><li>将测试实例预测为这个"最近邻居"的类别。</li></ul><p>值得注意的是，近邻算法是"惰性学习"模型家族的一部分，这意味着它不会根据训练集主动学习或者拟合出一个函数来对新进入的样本进行判断，而是单纯的记住训练集中所有的样本，所以它实际上没有所谓的"训练"过程，而是在需要进行预测的时候从自己的训练集样本中查找与新进入样本最相似的样本，即寻找最近邻来获得预测结果。</p><p><strong>Distance Metric</strong>：</p><p>一些常见的距离度量方法包括：</p><ul><li>L1 Manhattan distance: $d_{L1}(x, y) = \sum_{i=1}^n |x_i - y_i|$</li><li>L2 Euclidean distance: $d_{L2}(x, y) = \sqrt{\sum_{i=1}^n (x_i - y_i)^2}$</li></ul><p><strong>k-Nearest Neighbor Classifier</strong>：</p><p>k邻近算法是使用离待测试点k个最近邻的点来对分类进行预测的一种算法。相比普通最近邻算法只考虑测试实例的单一最近邻居，而k邻域算法考虑测试实例的k个最近邻居。</p><p>对于分类问题，k邻域算法通过majority voting的方式从k个最近邻居中获得最常见的类别作为预测类别，即：选择k个邻居中频率最高的类别作为返回值。</p><h3 id=validation-sets-for-hyperparameter-tuning>Validation sets for Hyperparameter tuning</h3><p><strong>Hyperparameters</strong>：</p><p>在机器学习中，超参数是在开始学习过程之前设置用于控制学习过程的参数，而不是通过训练得到的参数数据。比如，在kNN算法中，使用邻居点的数量k和计算距离的distance metric就是超参数。</p><p><strong>Cross-validation</strong>：</p><p>交叉验证在训练集和测试集的基础上，通过进一步将训练数据集随机平均划分为K个互不重叠的子集，然后将其中一个子集作为验证集，其余K-1个子集作为临时训练集。这样循环K次，每次选择一个不同的验证集，其余作为临时训练集，取平均值作为最终估计值。</p><p>因为交叉验证可以重复利用原始数据集，较好地评估不同超参数设置下的泛化能力，所以它一般常用来确认和选择模型的超参数。</p><h2 id=linear-classifier>Linear Classifier</h2><p><figure><img src=https://zhytou.github.io/post/2023-11-14/linear_model.PNG alt="图1 线性分类器"></figure></p><p>线性分类的方法一般由2个部分组成：决策函数和损失函数。同时，它也是神经网络和卷积神经网络的基础。</p><p><strong>Score Function</strong>：</p><p>决策函数用于对样本进行评分，得到每个类的得分。比如：最简单的线性分类器使用函数$f(x) = w^T x + b$</p><p><strong>Loss Function</strong>：</p><p>损失函数一般是每个样本的平均预测值与真实值的差值，比如：$L = \frac{1}{N} \sum_{i} L_i(f_i(x_i, W), y)$</p><p><strong>How To Choose A Good Linear Classifier</strong>：</p><ul><li>定义一个损失函数，用于反映模型预测效果；</li><li>优化模型参数来减小损失函数的值。</li></ul><h3 id=multiclass-svm-loss>Multiclass SVM Loss</h3><p>SVM的损失函数想要SVM在正确分类上的得分始终比不正确分类上的得分高出一个边界值$\Delta$，即：如果正确分类得分大于其余类最高得分+$\Delta$，那么损失函数输出为0；反之，输出。</p><p>比如，第i个数据中包含图像$x_i$的像素和代表正确类别的标签$y_i$，其评分函数为$f(x_i, W)$，输出针对所有类别得分的向量。即：第i个数据针对第j个类别的得分就是第j个元素：$s_j = f(x_i, W)_j$。那么，针对第i个数据的多类SVM的损失函数定义如下：</p><p>$L_i = \sum_{j\ne y_i}max(0, s_j - s_{y_i} + \Delta)$</p><p>一个更直接的例子是，假设一个数据集有三个分类，其中第i个数据经过决策函数得到了分值[13, -7, 11]。已知第i个数据的正确类别是第一个类别，且$\Delta$为10，那么它的损失值为</p><p>$L_i = max(0, -7 - 13 + 10) + max(0, 11 - 13 + 10)$</p><h3 id=softmax-classifier>Softmax Classifier</h3><blockquote><p>回归 vs 分类：定量输出称为回归，或者说是连续变量预测； 定性输出称为分类，或者说是离散变量预测。</p></blockquote><p>Softmax的作用就是将分类器输出的数值转化为一个概率分布。具体来说：普通分类器的最后一层为线性层，输出为每个类的得分。而Softmax函数将这些得分映射到(0,1)范围内，且保证各类得分和为1。具体公式如下：</p><p>$L_i=-f_{y_i} + log(\sum{j}e^{f_i})$</p><h2 id=optimization>Optimization</h2><p>优化的目标就是找到能够最小化损失函数值的权重W。</p><h3 id=gradient>Gradient</h3><p>梯度是一个向量，它能指出目标函数在各个方向上增长最快的方向。其中每个元素表示某个变量对目标函数的变化影响程度，即：偏导数。对于目标函数F(w)来说，它的梯度可以表示为∇F(w)。</p><p><strong>Gradient calculation</strong>：</p><p>一个是缓慢的近似方法（数值梯度法），但实现相对简单。另一个方法（分析梯度法）计算迅速，结果精确，但是实现时容易出错，且需要使用微分。</p><h3 id=gradient-descent>Gradient Descent</h3><h2 id=backpropagation>Backpropagation</h2><p>回忆之前计算神经网络模型梯度的方法，都涉及到大量微积分计算，并且替换其中某层就需要重新计算。显然，我们需要一种更高效的方法。反向传播正是工程师们给出的答案，它是利用链式法则递归计算表达式的梯度的方法。</p><h2 id=neural-networks>Neural Networks</h2><p>神经网络通常也被称为全连接网络（Fully Connected Network），它指的是神经元层与层之间都是完全连接的，一个层的每个节点都会连接到下一层的每个节点的结构。</p><p>一个最基础的两层神经网络可以由线性模型变化而来，比如：</p><ul><li>Linear function: $f = Wx$</li><li>2-layer Neural Networks: $f = W_2max(0, W_1x)$</li></ul><p><strong>Activation functions</strong>：</p><p>上面的两层神经网络表达式中的max函数也被称为激活函数。它是神经网络区别与普通模型的关键，如果缺少这个函数，上面的模型就变成$f = W_2W_1x$。</p><p>一些常见的激活函数包括：</p><ul><li>Sigmoid</li><li>tanh</li><li>ReLU</li><li>Leaky ReLU</li><li>Maxout</li><li>ELU</li></ul><h2 id=convolutional-neural-networks>Convolutional Neural Networks</h2><p>卷积神经网络和上一章讲的常规神经网络非常相似：它们都是由神经元组成，神经元中有具有学习能力的权重和偏差。每个神经元都得到一些输入数据，进行内积运算后再进行激活函数运算。整个网络依旧是一个可导的评分函数：该函数的输入是原始的图像像素，输出是不同类别的评分。在最后一层（往往是全连接层），网络依旧有一个损失函数（比如SVM或Softmax），并且在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。</p><p>它与常规神经网络的不同之处在于卷积神经网络的结构基于一个假设，即输入数据是图像，基于该假设，我们就向结构中添加了一些特有的性质。这些特有属性使得前向传播函数实现起来更高效，并且大幅度降低了网络中参数的数量。</p><h3 id=convotional-layer>Convotional Layer</h3><p>卷积层是构建卷积神经网络的核心层，它产生了网络中大部分的计算量。</p><p>卷积层的深度总是和输入相同。</p><h3 id=pooling-layer>Pooling Layer</h3><p>与卷积层类似，汇聚层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口（有时称为汇聚窗口）遍历的每个位置计算一个输出。 然而，不同于卷积层中的输入与卷积核之间的互相关计算，汇聚层不包含参数。 相反，池运算是确定性的，我们通常计算汇聚窗口中所有元素的最大值或平均值。这些操作分别称为最大汇聚层（maximum pooling）和平均汇聚层（average pooling）。</p><p><a href=https://pic4.zhimg.com/80/641c8846abcb02d35938660cf96cef1b_720w.webp target=_blank>2*2 最大汇聚</a></p><p>比如，上图就是一个2*2的最大汇聚操作，以步长为2来对每个深度切片进行降采样，只保留汇聚窗口中的最大值。</p><p>它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。</p><h3 id=full-connected-layer>Full Connected Layer</h3><p>在全连接层中，神经元对于前一层中的所有激活数据是全部连接的，这个常规神经网络中一样。它们的激活可以先用矩阵乘法，再加上偏差。更多细节请查看神经网络章节。</p></div></div></article></div></main><footer>© Copyright <a href=https://github.com/Zhytou target=_blank>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae target=_blank>Vitae</a> theme for <a href=https://gohugo.io target=_blank>Hugo</a></footer><script src=/js/dark-mode.js></script></body></html>
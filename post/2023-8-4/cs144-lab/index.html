<!doctype html><html lang=en><head><meta charset=utf-8><title>CS144-Minnow Lab总结 | Zhytou</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><meta property="og:title" content="CS144-Minnow Lab总结"><meta property="og:description" content="课程地址CS144: Introduction to Computer Networking
个人感觉，虽然整个CS144的Lab难度不算特别大（认认真真做一周时间应该是够了），但还是非常有收获的。反正我做完就感觉死去的计网记忆在攻击我:(。难度排序的话，应该是 TCP Sender > TCP receiver ≈Network Interface > IP router > Webget & ByteStream。
0 Networking Warmup 实验0的前几个部分主要以使用命令进行发Http请求或邮件并观察响应为主，只有最后两个部分需要写代码。下面介绍一下我的环境以及配置方法。
WSL安装：
首先，在确保虚拟化以及WSL功能正确开启后，前往微软商店下载Windows Subsystem For Linux。我使用的发行版是Ubuntu 22.04.2 LTS。更详细的下载方法，可以查看我的另一篇博客[搭建自己的生产环境]中的WSL部分。
接着，在WSL下载cmake、make、git和clang-format。其中，cmake和make是用于项目构建和编译的；git则是用于版本管理；clang-format则是一个格式化工具。它都会在后续使用到。具体下载方法如下：
sudo apt install cmake make git clang-format 远程仓库：
首先，在github中创建一个名为minnow的空仓库，作为我们的远程备份仓库。注意，为了遵守课程规定，我们需要将该仓库设为私有。
其次，克隆课程项目，并将其推送到自己的远程仓库上，完成仓库的初始化。具体方法如下：
# clone the bare git proj git clone --bare https://github.com/cs144/minnow # cd the bare git directory and push everything to your own repo cd minnow.git; git remote add mine git@github."><meta property="og:type" content="article"><meta property="og:url" content="https://zhytou.github.io/post/2023-8-4/cs144-lab/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-08-04T22:18:06+08:00"><meta property="article:modified_time" content="2023-08-04T22:18:06+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CS144-Minnow Lab总结"><meta name=twitter:description content="课程地址CS144: Introduction to Computer Networking
个人感觉，虽然整个CS144的Lab难度不算特别大（认认真真做一周时间应该是够了），但还是非常有收获的。反正我做完就感觉死去的计网记忆在攻击我:(。难度排序的话，应该是 TCP Sender > TCP receiver ≈Network Interface > IP router > Webget & ByteStream。
0 Networking Warmup 实验0的前几个部分主要以使用命令进行发Http请求或邮件并观察响应为主，只有最后两个部分需要写代码。下面介绍一下我的环境以及配置方法。
WSL安装：
首先，在确保虚拟化以及WSL功能正确开启后，前往微软商店下载Windows Subsystem For Linux。我使用的发行版是Ubuntu 22.04.2 LTS。更详细的下载方法，可以查看我的另一篇博客[搭建自己的生产环境]中的WSL部分。
接着，在WSL下载cmake、make、git和clang-format。其中，cmake和make是用于项目构建和编译的；git则是用于版本管理；clang-format则是一个格式化工具。它都会在后续使用到。具体下载方法如下：
sudo apt install cmake make git clang-format 远程仓库：
首先，在github中创建一个名为minnow的空仓库，作为我们的远程备份仓库。注意，为了遵守课程规定，我们需要将该仓库设为私有。
其次，克隆课程项目，并将其推送到自己的远程仓库上，完成仓库的初始化。具体方法如下：
# clone the bare git proj git clone --bare https://github.com/cs144/minnow # cd the bare git directory and push everything to your own repo cd minnow.git; git remote add mine git@github."><meta itemprop=name content="CS144-Minnow Lab总结"><meta itemprop=description content="课程地址CS144: Introduction to Computer Networking
个人感觉，虽然整个CS144的Lab难度不算特别大（认认真真做一周时间应该是够了），但还是非常有收获的。反正我做完就感觉死去的计网记忆在攻击我:(。难度排序的话，应该是 TCP Sender > TCP receiver ≈Network Interface > IP router > Webget & ByteStream。
0 Networking Warmup 实验0的前几个部分主要以使用命令进行发Http请求或邮件并观察响应为主，只有最后两个部分需要写代码。下面介绍一下我的环境以及配置方法。
WSL安装：
首先，在确保虚拟化以及WSL功能正确开启后，前往微软商店下载Windows Subsystem For Linux。我使用的发行版是Ubuntu 22.04.2 LTS。更详细的下载方法，可以查看我的另一篇博客[搭建自己的生产环境]中的WSL部分。
接着，在WSL下载cmake、make、git和clang-format。其中，cmake和make是用于项目构建和编译的；git则是用于版本管理；clang-format则是一个格式化工具。它都会在后续使用到。具体下载方法如下：
sudo apt install cmake make git clang-format 远程仓库：
首先，在github中创建一个名为minnow的空仓库，作为我们的远程备份仓库。注意，为了遵守课程规定，我们需要将该仓库设为私有。
其次，克隆课程项目，并将其推送到自己的远程仓库上，完成仓库的初始化。具体方法如下：
# clone the bare git proj git clone --bare https://github.com/cs144/minnow # cd the bare git directory and push everything to your own repo cd minnow.git; git remote add mine git@github."><meta itemprop=datePublished content="2023-08-04T22:18:06+08:00"><meta itemprop=dateModified content="2023-08-04T22:18:06+08:00"><meta itemprop=wordCount content="814"><meta itemprop=keywords content></head><body><header><div id=avatar><a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a></div><div id=titletext><h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2></div><div id=title-description><p id=subtitle>May the force be with me.</p><div id=social><nav><ul><li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li><li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>Posts</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>04</span>
<span class=rest>Aug 2023</span></div></div><div class=matter><h1 class=title>CS144-Minnow Lab总结</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><blockquote><p>课程地址<a href=https://cs144.github.io/ target=_blank>CS144: Introduction to Computer Networking</a></p></blockquote><p><a href=https://wakatime.com/badge/user/a7b329b7-d489-40d2-9239-8be7cf83b65e/project/b892df03-90fb-40ca-a3a3-f14a57f9a941 target=_blank><figure><img src=https://wakatime.com/badge/user/a7b329b7-d489-40d2-9239-8be7cf83b65e/project/b892df03-90fb-40ca-a3a3-f14a57f9a941.svg alt=wakatime></figure></a></p><p>个人感觉，虽然整个CS144的Lab难度不算特别大（认认真真做一周时间应该是够了），但还是非常有收获的。反正我做完就感觉死去的计网记忆在攻击我:(。难度排序的话，应该是 TCP Sender > TCP receiver ≈Network Interface > IP router > Webget & ByteStream。</p><h2 id=0-networking-warmup>0 Networking Warmup</h2><p>实验0的前几个部分主要以使用命令进行发Http请求或邮件并观察响应为主，只有最后两个部分需要写代码。下面介绍一下我的环境以及配置方法。</p><p><strong>WSL安装</strong>：</p><p>首先，在确保虚拟化以及WSL功能正确开启后，前往微软商店下载Windows Subsystem For Linux。我使用的发行版是Ubuntu 22.04.2 LTS。更详细的下载方法，可以查看我的另一篇博客[搭建自己的生产环境]中的WSL部分。</p><p>接着，在WSL下载cmake、make、git和clang-format。其中，cmake和make是用于项目构建和编译的；git则是用于版本管理；clang-format则是一个格式化工具。它都会在后续使用到。具体下载方法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt install cmake make git clang-format
</span></span></code></pre></div><p><strong>远程仓库</strong>：</p><p>首先，在github中创建一个名为<code>minnow</code>的空仓库，作为我们的远程备份仓库。注意，为了遵守课程规定，我们需要将该仓库设为私有。</p><p>其次，克隆课程项目，并将其推送到自己的远程仓库上，完成仓库的初始化。具体方法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888># clone the bare git proj</span>
</span></span><span style=display:flex><span>git clone --bare https://github.com/cs144/minnow
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888># cd the bare git directory and push everything to your own repo</span>
</span></span><span style=display:flex><span><span style=color:#007020>cd</span> minnow.git; git remote add mine git@github.com:Zhytou/minnow.git
</span></span><span style=display:flex><span>git push --all mine
</span></span><span style=display:flex><span>git push --tags mine
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888># remove the bare git directory and see your own repo</span>
</span></span><span style=display:flex><span>rm -rf minnow.git
</span></span><span style=display:flex><span>git clone git@github.com:Zhytou/minnow.git
</span></span></code></pre></div><p><strong>编译运行</strong>：</p><p>CS144课程实验使用cmake构架和编译，方法如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#007020>cd</span> minnow
</span></span><span style=display:flex><span><span style=color:#888># 编译</span>
</span></span><span style=display:flex><span>cmake -S . -B build
</span></span><span style=display:flex><span><span style=color:#888># 运行</span>
</span></span><span style=display:flex><span>cmake --build build --target check_Webget
</span></span></code></pre></div><h3 id=writing-webget>Writing webget</h3><p>这部分要求我们在<code>apps/webget.cc</code>里面实现<code>void get_URL( const string& host, const string& path )</code>函数，最终完成抓取网页并写入到标准输出的功能。</p><p><strong>Socket编程</strong>：</p><p>这个任务在理解了套接字的通信流程之后就会变得非常简单。一个常见的客户端使用套接字向服务器发送信息的API调用顺序如下：</p><ul><li>首先，服务器创建一个套接字，并使用bind将其绑定到某IP和端口，接着使用listen使其监听该端口的连接请求。</li><li>接着，客户端创建一个套接字，并使用connect尝试连接服务器。成功后，使用send向其发送请求。</li><li>此时，服务器介绍到客户端请求，使用accept得到一个新套接字，先使用recv读取请求，接着使用send发送回复。</li><li>接着，客户端使用recv接收到回复，使用close关闭连接。</li><li>最后，服务器使用close关闭连接。</li></ul><p>此外，还需要注意的就是在写Http请求时，换行是<code>\r\n</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>get_URL</span>( <span style=color:#080;font-weight:700>const</span> string<span style=color:#333>&amp;</span> host, <span style=color:#080;font-weight:700>const</span> string<span style=color:#333>&amp;</span> path )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  TCPSocket sock;
</span></span><span style=display:flex><span>  Address addr( host, <span style=background-color:#fff0f0>&#34;http&#34;</span> );
</span></span><span style=display:flex><span>  sock.connect( addr );
</span></span><span style=display:flex><span>  sock.write( <span style=background-color:#fff0f0>&#34;GET &#34;</span> <span style=color:#333>+</span> path <span style=color:#333>+</span> <span style=background-color:#fff0f0>&#34; HTTP/1.1</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\r\n</span><span style=background-color:#fff0f0>&#34;</span> );
</span></span><span style=display:flex><span>  sock.write( <span style=background-color:#fff0f0>&#34;Host: &#34;</span> <span style=color:#333>+</span> host <span style=color:#333>+</span> <span style=background-color:#fff0f0>&#34; </span><span style=color:#666;background-color:#fff0f0;font-weight:700>\r\n</span><span style=background-color:#fff0f0>&#34;</span> );
</span></span><span style=display:flex><span>  sock.write( <span style=background-color:#fff0f0>&#34;Connection: close </span><span style=color:#666;background-color:#fff0f0;font-weight:700>\r\n\r\n</span><span style=background-color:#fff0f0>&#34;</span> );
</span></span><span style=display:flex><span>  string buf;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>do</span> {
</span></span><span style=display:flex><span>    sock.read( buf );
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> ( buf.empty() ) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      cout <span style=color:#333>&lt;&lt;</span> buf;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#080;font-weight:700>while</span> ( <span style=color:#00d;font-weight:700>1</span> );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>测试结果</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>zhytou@LAPTOP-Q0M4I2VQ:~/minnow/build$ make check_webget
</span></span><span style=display:flex><span>Test project /home/zhytou/minnow/build
</span></span><span style=display:flex><span>    Start 1: compile with bug-checkers
</span></span><span style=display:flex><span>1/2 Test <span style=color:#888>#1: compile with bug-checkers ........   Passed    0.17 sec</span>
</span></span><span style=display:flex><span>    Start 2: t_webget
</span></span><span style=display:flex><span>2/2 Test <span style=color:#888>#2: t_webget .........................   Passed    1.21 sec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>100% tests passed, <span style=color:#60e;font-weight:700>0</span> tests failed out of <span style=color:#60e;font-weight:700>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Total Test <span style=color:#007020>time</span> <span style=color:#333>(</span>real<span style=color:#333>)</span> <span style=color:#333>=</span>   1.38 sec
</span></span><span style=display:flex><span>Built target check_webget
</span></span></code></pre></div><h3 id=an-in-memory-reliable-byte-stream>An in-memory reliable byte stream</h3><p>这个部分要求我们在<code>src/byte_stream.hh</code>和<code>src/byte_stream.cc</code>文件中，完成<code>ByteStream</code>以及其派生类接口，实现可以读写的字节流。</p><p><strong>string_view Reader::peek()</strong>：</p><p>我一开始想到使用队列作为底层数据结构来实现这个类，但后面考虑到其派生类<code>Reader</code>中的<code>peek</code>接口要求返回string_view类型，于是便使用字符串作为底层结构实现。</p><p>因为，如果使用队列作为实际存储数据的结构，在实现<code>peek</code>时必然会使用一个临时字符串存储队列中数据，并使用这个字符串构造<code>string_view</code>返回。这样一定会报错，因为，<code>string_view</code>一种只读的字符串视图，它并没有这段内存的所有权，所以在返回后临时字符串被销毁，那么就会有<code>string_view</code>悬空引用和访问无效内存的问题。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>ByteStream</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>protected</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>uint64_t</span> capacity_;
</span></span><span style=display:flex><span>  std<span style=color:#333>::</span>string buffer_;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>bool</span> is_closed_;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>bool</span> has_error_;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>uint64_t</span> bytes_pushed_;
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>uint64_t</span> bytes_popped_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>public</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>explicit</span> ByteStream( <span style=color:#339;font-weight:700>uint64_t</span> capacity );
</span></span><span style=display:flex><span>  <span style=color:#888>// Helper functions (provided) to access the ByteStream&#39;s Reader and Writer interfaces
</span></span></span><span style=display:flex><span><span style=color:#888></span>  Reader<span style=color:#333>&amp;</span> reader();
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>const</span> Reader<span style=color:#333>&amp;</span> reader() <span style=color:#080;font-weight:700>const</span>;
</span></span><span style=display:flex><span>  Writer<span style=color:#333>&amp;</span> writer();
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>const</span> Writer<span style=color:#333>&amp;</span> writer() <span style=color:#080;font-weight:700>const</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>测试结果</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>zhytou@LAPTOP-Q0M4I2VQ:~/minnow/build$ make check0
</span></span><span style=display:flex><span>Test project /home/zhytou/minnow/build
</span></span><span style=display:flex><span>      Start  1: compile with bug-checkers
</span></span><span style=display:flex><span> 1/10 Test  <span style=color:#888>#1: compile with bug-checkers ........   Passed    0.17 sec</span>
</span></span><span style=display:flex><span>      Start  2: t_webget
</span></span><span style=display:flex><span> 2/10 Test  <span style=color:#888>#2: t_webget .........................   Passed    1.21 sec</span>
</span></span><span style=display:flex><span>      Start  3: byte_stream_basics
</span></span><span style=display:flex><span> 3/10 Test  <span style=color:#888>#3: byte_stream_basics ...............   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  4: byte_stream_capacity
</span></span><span style=display:flex><span> 4/10 Test  <span style=color:#888>#4: byte_stream_capacity .............   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  5: byte_stream_one_write
</span></span><span style=display:flex><span> 5/10 Test  <span style=color:#888>#5: byte_stream_one_write ............   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  6: byte_stream_two_writes
</span></span><span style=display:flex><span> 6/10 Test  <span style=color:#888>#6: byte_stream_two_writes ...........   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  7: byte_stream_many_writes
</span></span><span style=display:flex><span> 7/10 Test  <span style=color:#888>#7: byte_stream_many_writes ..........   Passed    0.03 sec</span>
</span></span><span style=display:flex><span>      Start  8: byte_stream_stress_test
</span></span><span style=display:flex><span> 8/10 Test  <span style=color:#888>#8: byte_stream_stress_test ..........   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start 37: compile with optimization
</span></span><span style=display:flex><span> 9/10 Test <span style=color:#888>#37: compile with optimization ........   Passed    3.98 sec</span>
</span></span><span style=display:flex><span>      Start 38: byte_stream_speed_test
</span></span><span style=display:flex><span>             ByteStream throughput: 6.56 Gbit/s
</span></span><span style=display:flex><span>10/10 Test <span style=color:#888>#38: byte_stream_speed_test ...........   Passed    0.07 sec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>100% tests passed, <span style=color:#60e;font-weight:700>0</span> tests failed out of <span style=color:#60e;font-weight:700>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Total Test <span style=color:#007020>time</span> <span style=color:#333>(</span>real<span style=color:#333>)</span> <span style=color:#333>=</span>   5.49 sec
</span></span><span style=display:flex><span>Built target check0
</span></span></code></pre></div><h2 id=1-stitching-substrings-into-a-byte-stream>1 Stitching Substrings Into A Byte Stream</h2><p><strong>Reassembler数据结构</strong>：</p><p><code>Reassembler</code>中最关键的一点就是如何临时存储可能重叠的子字符串。我选择的是使用<code>map&lt;uint64_t, char></code>来存储，有一点滑动窗口的思想。可能更常规的做法是用<code>map&lt;uint64_t, string></code>来存储，但我考虑到传入substr重叠可能会导致维护这个map变得比较复杂，索性直接存索引到字符的映射，但会导致效率严重下降（test13有可能超时）。具体如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Reassembler</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>private</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>  <span style=color:#888>// Bytes stored temorarily in ther Reassembler whose indexes are in the available capacity
</span></span></span><span style=display:flex><span><span style=color:#888></span>  std<span style=color:#333>::</span>map<span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>uint64_t</span>, <span style=color:#339;font-weight:700>char</span><span style=color:#333>&gt;</span> sliding_window_;
</span></span><span style=display:flex><span>  <span style=color:#888>// The index of next byte expected to write in the outbounded stream
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>uint64_t</span> expected_index_;
</span></span><span style=display:flex><span>  <span style=color:#888>// The index of last byte expected to write in the outbounded stream
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>uint64_t</span> expected_last_index_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>public</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>  Reassembler();
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>insert</span>( <span style=color:#339;font-weight:700>uint64_t</span> first_index, std<span style=color:#333>::</span>string data, <span style=color:#339;font-weight:700>bool</span> is_last_substring, Writer<span style=color:#333>&amp;</span> output );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888>// The number of bytes stored in the Reassembler itself
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>uint64_t</span> <span style=color:#06b;font-weight:700>bytes_pending</span>() <span style=color:#080;font-weight:700>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#888>// The index of next byte epected
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>uint64_t</span> <span style=color:#06b;font-weight:700>index_expected</span>() <span style=color:#080;font-weight:700>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#888>// The index of last byte expected
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#339;font-weight:700>uint64_t</span> <span style=color:#06b;font-weight:700>last_index_expected</span>() <span style=color:#080;font-weight:700>const</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>测试结果</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>zhytou@LAPTOP-Q0M4I2VQ:~/minnow/build$ make check1
</span></span><span style=display:flex><span>Test project /home/zhytou/minnow/build
</span></span><span style=display:flex><span>      Start  1: compile with bug-checkers
</span></span><span style=display:flex><span> 1/17 Test  <span style=color:#888>#1: compile with bug-checkers ........   Passed    0.22 sec</span>
</span></span><span style=display:flex><span>      Start  3: byte_stream_basics
</span></span><span style=display:flex><span> 2/17 Test  <span style=color:#888>#3: byte_stream_basics ...............   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  4: byte_stream_capacity
</span></span><span style=display:flex><span> 3/17 Test  <span style=color:#888>#4: byte_stream_capacity .............   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  5: byte_stream_one_write
</span></span><span style=display:flex><span> 4/17 Test  <span style=color:#888>#5: byte_stream_one_write ............   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  6: byte_stream_two_writes
</span></span><span style=display:flex><span> 5/17 Test  <span style=color:#888>#6: byte_stream_two_writes ...........   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  7: byte_stream_many_writes
</span></span><span style=display:flex><span> 6/17 Test  <span style=color:#888>#7: byte_stream_many_writes ..........   Passed    0.03 sec</span>
</span></span><span style=display:flex><span>      Start  8: byte_stream_stress_test
</span></span><span style=display:flex><span> 7/17 Test  <span style=color:#888>#8: byte_stream_stress_test ..........   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start  9: reassembler_single
</span></span><span style=display:flex><span> 8/17 Test  <span style=color:#888>#9: reassembler_single ...............   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start 10: reassembler_cap
</span></span><span style=display:flex><span> 9/17 Test <span style=color:#888>#10: reassembler_cap ..................   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start 11: reassembler_seq
</span></span><span style=display:flex><span>10/17 Test <span style=color:#888>#11: reassembler_seq ..................   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start 12: reassembler_dup
</span></span><span style=display:flex><span>11/17 Test <span style=color:#888>#12: reassembler_dup ..................   Passed    0.02 sec</span>
</span></span><span style=display:flex><span>      Start 13: reassembler_holes
</span></span><span style=display:flex><span>12/17 Test <span style=color:#888>#13: reassembler_holes ................   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start 14: reassembler_overlapping
</span></span><span style=display:flex><span>13/17 Test <span style=color:#888>#14: reassembler_overlapping ..........   Passed    0.01 sec</span>
</span></span><span style=display:flex><span>      Start 15: reassembler_win
</span></span><span style=display:flex><span>14/17 Test <span style=color:#888>#15: reassembler_win ..................   Passed    5.64 sec</span>
</span></span><span style=display:flex><span>      Start 37: compile with optimization
</span></span><span style=display:flex><span>15/17 Test <span style=color:#888>#37: compile with optimization ........   Passed    0.08 sec</span>
</span></span><span style=display:flex><span>      Start 38: byte_stream_speed_test
</span></span><span style=display:flex><span>             ByteStream throughput: 6.30 Gbit/s
</span></span><span style=display:flex><span>16/17 Test <span style=color:#888>#38: byte_stream_speed_test ...........   Passed    0.07 sec</span>
</span></span><span style=display:flex><span>      Start 39: reassembler_speed_test
</span></span><span style=display:flex><span>             Reassembler throughput: 14.16 Gbit/s
</span></span><span style=display:flex><span>17/17 Test <span style=color:#888>#39: reassembler_speed_test ...........   Passed    0.11 sec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>100% tests passed, <span style=color:#60e;font-weight:700>0</span> tests failed out of <span style=color:#60e;font-weight:700>17</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Total Test <span style=color:#007020>time</span> <span style=color:#333>(</span>real<span style=color:#333>)</span> <span style=color:#333>=</span>   6.26 sec
</span></span><span style=display:flex><span>Built target check1
</span></span></code></pre></div><h2 id=2-the-tcp-receiver>2 The TCP Receiver</h2><h2 id=3-the-tcp-sender>3 The TCP Sender</h2><h2 id=4-the-network-interface>4 The Network Interface</h2><h2 id=5-the-ip-router>5 The IP Router</h2></div></div></article></div></main><footer>© Copyright <a href=https://github.com/Zhytou target=_blank>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae target=_blank>Vitae</a> theme for <a href=https://gohugo.io target=_blank>Hugo</a></footer><script src=/js/dark-mode.js></script></body></html>
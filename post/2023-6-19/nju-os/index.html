<!doctype html><html lang=en><head><meta charset=utf-8><title>NJU-OS笔记 | Zhytou</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.115.3"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><meta property="og:title" content="NJU-OS笔记"><meta property="og:description" content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
3 多处理器编程 并发 并发的基本单位——线程：
共享内存的多个执行流：
执行流拥有独立的堆栈/寄存器 共享全部的内存（指针可以相互引用） POSIX Threads
实现原子性
实现临界区之间的绝对串行化 程序其他部分依然并行执行
4 理解并发程序执行 5 并发控制：互斥 共享内存的互斥
自旋锁 Spinlock 自旋锁是一种基于忙等待的锁。
当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。
x86 LOCK指令前缀：
x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。
使用带LOCK前缀的指令能实现多种原子操作，如：
原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。 实现自旋锁：
// atomic exchange int xchg(volatile int *addr, int newval) { int result; asm volatile (&#34;lock xchg %0, %1&#34; : &#34;+m&#34;(*addr), &#34;=a&#34;(result) : &#34;1&#34;(newval)); return result; } int locked = 0; void lock() { while (xchg(&amp;locked, 1)) ; } void unlock() { xchg(&amp;locked, 0); } 原子操作与Bus Lock："><meta property="og:type" content="article"><meta property="og:url" content="https://zhytou.github.io/post/2023-6-19/nju-os/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-06-19T21:22:58+08:00"><meta property="article:modified_time" content="2023-06-19T21:22:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NJU-OS笔记"><meta name=twitter:description content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
3 多处理器编程 并发 并发的基本单位——线程：
共享内存的多个执行流：
执行流拥有独立的堆栈/寄存器 共享全部的内存（指针可以相互引用） POSIX Threads
实现原子性
实现临界区之间的绝对串行化 程序其他部分依然并行执行
4 理解并发程序执行 5 并发控制：互斥 共享内存的互斥
自旋锁 Spinlock 自旋锁是一种基于忙等待的锁。
当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。
x86 LOCK指令前缀：
x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。
使用带LOCK前缀的指令能实现多种原子操作，如：
原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。 实现自旋锁：
// atomic exchange int xchg(volatile int *addr, int newval) { int result; asm volatile (&#34;lock xchg %0, %1&#34; : &#34;+m&#34;(*addr), &#34;=a&#34;(result) : &#34;1&#34;(newval)); return result; } int locked = 0; void lock() { while (xchg(&amp;locked, 1)) ; } void unlock() { xchg(&amp;locked, 0); } 原子操作与Bus Lock："><meta itemprop=name content="NJU-OS笔记"><meta itemprop=description content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
3 多处理器编程 并发 并发的基本单位——线程：
共享内存的多个执行流：
执行流拥有独立的堆栈/寄存器 共享全部的内存（指针可以相互引用） POSIX Threads
实现原子性
实现临界区之间的绝对串行化 程序其他部分依然并行执行
4 理解并发程序执行 5 并发控制：互斥 共享内存的互斥
自旋锁 Spinlock 自旋锁是一种基于忙等待的锁。
当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。
x86 LOCK指令前缀：
x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。
使用带LOCK前缀的指令能实现多种原子操作，如：
原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。 实现自旋锁：
// atomic exchange int xchg(volatile int *addr, int newval) { int result; asm volatile (&#34;lock xchg %0, %1&#34; : &#34;+m&#34;(*addr), &#34;=a&#34;(result) : &#34;1&#34;(newval)); return result; } int locked = 0; void lock() { while (xchg(&amp;locked, 1)) ; } void unlock() { xchg(&amp;locked, 0); } 原子操作与Bus Lock："><meta itemprop=datePublished content="2023-06-19T21:22:58+08:00"><meta itemprop=dateModified content="2023-06-19T21:22:58+08:00"><meta itemprop=wordCount content="1033"><meta itemprop=keywords content></head><body><header><div id=avatar><a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a></div><div id=titletext><h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2></div><div id=title-description><p id=subtitle>May the force be with me.</p><div id=social><nav><ul><li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li><li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>Posts</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>19</span>
<span class=rest>Jun 2023</span></div></div><div class=matter><h1 class=title>NJU-OS笔记</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><p>这篇博客流水线的记录一下自己学习<a href=https://jyywiki.cn/OS/2022/ target=_blank>NJU-OS</a>的笔记。</p><h2 id=1-操作系统概述>1 操作系统概述</h2><blockquote><p>本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。</p></blockquote><h3 id=计算机历史>计算机历史</h3><h3 id=理解操作系统>理解操作系统</h3><p>理解操作系统，就是回答下面三个问题：</p><ul><li>操作系统服务谁？<ul><li>操作系统服务应用程序，而程序可以理解成状态机。</li><li>注：课程涉及多线程Linux应用程序。</li></ul></li><li>站在应用视角，操作系统能为程序提供什么服务？<ul><li>操作系统 = （可操作的）对象 + （可调用的）API</li><li>注：课程只涉及 POSIX + 部分Linux特性。</li></ul></li><li>站在硬件视角，如何实现操作系统并提供这些服务？<ul><li>操作系统 = C程序</li><li>注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。</li></ul></li></ul><blockquote><p>xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。</p></blockquote><h2 id=2-操作系统上的程序>2 操作系统上的程序</h2><h3 id=什么是程序>什么是程序</h3><h3 id=操作系统中的一般程序>操作系统中的一般程序</h3><blockquote><p>课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的<a href=/>tmux笔记</a>。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。</p></blockquote><h2 id=3-多处理器编程>3 多处理器编程</h2><h3 id=并发>并发</h3><p><strong>并发的基本单位——线程</strong>：</p><p>共享内存的多个执行流：</p><ul><li>执行流拥有独立的堆栈/寄存器</li><li>共享全部的内存（指针可以相互引用）</li></ul><p>POSIX Threads</p><p>实现原子性</p><p>实现临界区之间的绝对串行化
程序其他部分依然并行执行</p><h2 id=4-理解并发程序执行>4 理解并发程序执行</h2><h2 id=5-并发控制互斥>5 并发控制：互斥</h2><p>共享内存的互斥</p><h3 id=自旋锁-spinlock>自旋锁 Spinlock</h3><p>自旋锁是一种基于忙等待的锁。</p><p>当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。</p><p><strong>x86 LOCK指令前缀</strong>：</p><p>x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。</p><p>使用带LOCK前缀的指令能实现多种原子操作，如：</p><ul><li>原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。</li><li>原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。</li></ul><p><strong>实现自旋锁</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// atomic exchange
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>xchg</span>(<span style=color:#080;font-weight:700>volatile</span> <span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span>addr, <span style=color:#339;font-weight:700>int</span> newval) {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> result;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>asm</span> <span style=color:#080;font-weight:700>volatile</span> (<span style=background-color:#fff0f0>&#34;lock xchg %0, %1&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#333>:</span> <span style=background-color:#fff0f0>&#34;+m&#34;</span>(<span style=color:#333>*</span>addr), <span style=background-color:#fff0f0>&#34;=a&#34;</span>(result) <span style=color:#333>:</span> <span style=background-color:#fff0f0>&#34;1&#34;</span>(newval));
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> locked <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>lock</span>() { <span style=color:#080;font-weight:700>while</span> (xchg(<span style=color:#333>&amp;</span>locked, <span style=color:#00d;font-weight:700>1</span>)) ; }
</span></span><span style=display:flex><span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>unlock</span>() { xchg(<span style=color:#333>&amp;</span>locked, <span style=color:#00d;font-weight:700>0</span>); }
</span></span></code></pre></div><p><strong>原子操作与Bus Lock</strong>：</p><p>早期原子操作的实现依靠总线上锁来实现。具体如下，当一个处理器执行带有LOCK前缀的指令时，它会锁住内存总线，防止其他处理器同时对同一内存地址进行操作，从而确保了原子操作的正确性。</p><p><strong>原子操作的现代实现</strong>：</p><p>现代处理器中，原子操作通常是通过硬件支持来实现的，它们能够保证对内存的原子操作，而不需要锁住总线或者使用其他的软件实现方式，从而提高了系统的性能和并发能力。</p><p><strong>C++支持的原子操作</strong>：</p><p>详细信息可以阅读<a href=https://en.cppreference.com/w/cpp/atomic/atomic_exchange target=_blank>cppreference</a>。</p><p><strong>自旋锁的缺陷</strong>：</p><ul><li>自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加；</li><li>除了进入临界区的线程，其他处理器上的线程都在空转，且争抢锁的处理器越多，利用率越低；</li><li>获得自旋锁的线程可能被操作系统切换出去。</li></ul><p><strong>自旋锁适合的使用场景</strong>：</p><ul><li>临界区几乎不 “拥堵”；</li><li>持有自旋锁时禁止执行流切换。</li></ul><p>换句话说，自旋锁适用于短临界区的场景，比如操作系统内核的并发数据结构。</p><h3 id=互斥锁-mutex>互斥锁 Mutex</h3><p>互斥锁（mutex）是一种基于操作系统的同步原语，它使用了操作系统提供的系统调用来实现线程同步和互斥。</p><p>互斥锁的实现通常是基于一种叫做“睡眠-唤醒”机制的方式，当一个线程需要获取锁时，如果锁已经被占用，那么这个线程会被阻塞，直到锁被释放。当锁被释放时，操作系统会唤醒等待的线程，让它们竞争锁。</p><h3 id=快速用户空间互斥锁-futex>快速用户空间互斥锁 Futex</h3><p>Futex（Fast Userspace Mutex）是一种基于用户空间的同步原语。实际上，就是Spinlock和Mutex的混合。</p><p><strong>Futex的上锁过程</strong>：</p><ul><li>先在用户空间自旋。<ul><li>如果获得锁，直接进入；</li><li>未能获得锁，系统调用。</li></ul></li><li>解锁以后也需要系统调用。</li></ul><h3 id=5-总结>5 总结</h3><p>软件不够，硬件来凑 (自旋锁)
用户不够，内核来凑 (互斥锁)</p><h2 id=6-并发控制同步>6 并发控制：同步</h2><h3 id=线程同步>线程同步</h3><p>线程同步：在某个时间点共同达到互相已知的状态。</p><h3 id=条件变量>条件变量</h3><p>条件变量是一种用于线程间通信的同步原语，它允许一个线程等待另一个线程满足特定条件后再继续执行。</p><p>条件变量通常需要和互斥锁一起使用，以避免出现竞争和冲突。当一个线程需要等待特定条件时，它会释放互斥锁并进入等待状态，直到另一个线程满足条件并唤醒它。</p><h3 id=信号量>信号量</h3><p>信号量是一种计数器，用于控制同时可以访问共享资源的线程或进程数量。</p><p>在多个线程或进程竞争同一资源的情况下，信号量可以限制同时访问资源的线程或进程数量，避免竞争和冲突。</p><p>信号量有两种类型：二元信号量和计数信号量。</p><ul><li>二元信号量只有两种状态，0和1，用于实现互斥锁的功能；</li><li>计数信号量可以有多个状态，用于实现多个线程或进程之间的协作和同步。</li></ul><p>值得注意的是，虽然C++标准库中没有直接提供信号量的实现，但可以通过第三方库或者自己编写代码（互斥量+原子操作）来实现信号量。</p><h2 id=7-真实世界的并发编程>7 真实世界的并发编程</h2><p>并发编程的真实应用场景:</p><ul><li>高性能计算 (注重任务分解): 生产者-消费者 (MPI/OpenMP)</li><li>数据中心 (注重系统调用): 线程-协程 (Goroutine)</li><li>人机交互 (注重易用性): 事件-流图 (Promise)</li></ul><h2 id=8-并发bug和应对>8 并发Bug和应对</h2><h3 id=死锁-dead-lock>死锁 Dead Lock</h3><p><strong>死锁产生的条件</strong>：</p><ul><li>互斥：一个资源每次只能被一个进程使用</li><li>请求与保持：一个进程请求资阻塞时，不释放已获得的资源</li><li>不剥夺：进程已获得的资源不能强行剥夺</li><li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li></ul><h3 id=数据竞争-data-race>数据竞争 Data Race</h3><h2 id=9-操作系统的状态机模型>9 操作系统的状态机模型</h2><h2 id=10-状态机模型的应用>10 状态机模型的应用</h2><h2 id=11-操作系统上的进程>11 操作系统上的进程</h2><h3 id=回顾>回顾</h3><p><strong>定制Linux</strong>：</p><p>BusyBox: The Swiss Army Knife of embedded Linux</p><p>adb shell(toybox)</p><p><strong>Linux操作系统启动流程</strong>：</p><ul><li>CPU Reset</li><li>Firmware</li><li>Loader</li><li>Kernel_start</li><li>/bin/init</li><li>程序执行+系统调用</li></ul><p><strong>应用视角的操作系统</strong>：</p><p>操作系统为所有程序提供API</p><ul><li>进程&线程（状态机）管理<ul><li>fork,execve,exit - 进程的创建、改变和删除</li><li>pthread_create,pthread_join,pthread_exit - 线程的创建和退出</li></ul></li><li>存储（地址空间）管理<ul><li>mmap - 虚拟地址空间管理</li></ul></li><li>文件（数据对象）管理<ul><li>open,close,read,write - 文件访问管理</li><li>mkdir,link,unlink - 目录管理</li></ul></li></ul><h3 id=fork>fork()</h3><p><strong>理解操作系统是状态机管理者</strong>：</p><ul><li>操作系统在物理内存中保存多个状态机；</li><li>通过虚拟内存实现，拿一个来执行；</li><li>中断后进入操作系统代码，换一个执行。</li></ul><p><strong>状态机管理之创建状态机</strong>：</p><p>UNIX的答案是fork，即：做一份状态机的完整复制（内存、寄存器现场）。</p><p><strong>理解fork函数</strong>：</p><p><code>pid_t fork(void)</code></p><p>在fork函数返回后，会有两个进程同时运行，其中一个是父进程，另一个是新创建的子进程。</p><p>在子进程创建成功后，它会复制父进程的代码和数据段，并且开始执行从fork函数返回的位置。也就是说，子进程会从fork函数返回的地方开始执行，而不是从程序的起始位置开始执行。</p><p>需要注意的是，在子进程中，fork函数的返回值是0，而在父进程中，fork函数的返回值是新创建的子进程的进程ID。因此，在父进程中可以通过判断fork函数的返回值来区分当前进程是父进程还是子进程。</p><h3 id=execve>execve()</h3><p><strong>状态机管理之替换状态机</strong>：</p><p>UNIX的答案是execve，即：将当前运行的状态机重置成另一个程序的初始状态。</p><p><strong>理解execve函数</strong>：</p><p><code>int execve(const char *pathname, char *const argv[], char *const envp[]);</code></p><ul><li>pathname：指定要执行的程序的路径，可以是绝对路径或者相对路径。如果路径中不包含目录分隔符 /，则会从环境变量 PATH 中查找可执行文件。</li><li>argv：一个以 NULL 结尾的字符串数组，用于指定新程序的命令行参数。第一个元素通常是程序的名称，后面的元素是程序的参数。注意，第一个元素是程序的名称，而非路径名。</li><li>envp：一个以 NULL 结尾的字符串数组，用于指定新程序的环境变量。每个字符串都是一个形如 key=value 的键值对，表示一个环境变量的值。</li></ul><p>execve函数执行成功时，不会返回到调用进程，而是直接将当前进程替换为新程序的进程。如果执行失败，则会返回 -1，并设置相应的错误码。</p><h2 id=12-进程的地址空间>12 进程的地址空间</h2><p><strong>进程地址空间的组成</strong>：</p><ul><li>代码段（text segment）：存放可执行文件的指令，也称为二进制代码或可执行代码。</li><li>数据段（data segment）：存放程序中已经初始化的全局变量和静态变量。</li><li>BSS段（bss segment）：存放程序中未初始化的全局变量和静态变量，通常用0来填充。</li><li>堆（heap）：用于动态分配内存，例如使用C/C++中的malloc()函数或是C++中的new运算符申请内存。</li><li>栈（stack）：用于存放函数的局部变量、函数的参数以及函数调用时的返回地址等。</li><li>其他：还有一些用于存放动态链接库、共享内存、内存映射文件等的内存区域。</li></ul><h3 id=进程的地址空间管理>进程的地址空间管理</h3><ul><li>进程的地址空间 = 内存里若干连续的 “段”</li><li>每一段是可访问 (读/写/执行) 的内存</li><li>可能映射到某个文件和/或在进程间共享</li></ul><p><strong>管理进程地址空间的系统调用</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// 映射
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span><span style=color:#06b;font-weight:700>mmap</span>(<span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>addr, size_t length, <span style=color:#339;font-weight:700>int</span> prot, <span style=color:#339;font-weight:700>int</span> flags,
</span></span><span style=display:flex><span>           <span style=color:#339;font-weight:700>int</span> fd, off_t offset);
</span></span><span style=display:flex><span><span style=color:#888>// 取消映射
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>munmap</span>(<span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>addr, size_t length);
</span></span></code></pre></div><p><strong>内存映射一致性</strong>：</p><p>操作系统通过内存管理单元（MMU）来保证内存映射的一致性。MMU是一种硬件设备，用于将虚拟地址转换为物理地址，并执行访问权限控制。</p><p>当进程访问内存时，操作系统会将虚拟地址转换为物理地址，然后访问对应的物理地址。这个过程是由MMU完成的。MMU会通过页表或段表来进行地址转换，这些表会将虚拟地址映射到物理地址，并记录每个内存页或段的权限信息，例如读、写、执行等。</p><p>此外，操作系统还会使用一些技术来提高内存映射的一致性。例如，使用缓存（cache）来加速内存访问，并使用缓存一致性协议来确保多个缓存之间的数据一致性；使用TLB（Translation Lookaside Buffer）来缓存页表或段表的部分内容，加速地址转换。这些技术可以提高内存访问的效率，同时保证内存映射的一致性。</p><h3 id=地址空间的作用>地址空间的作用</h3><p><strong>实现进程隔离</strong>：</p><p>实现了操作系统最重要的功能：进程之间的隔离。</p><p><strong>代码注入</strong>：</p><p>我们可以改内存，也可以改代码！</p><h2 id=13-系统调用和unix-shell>13 系统调用和UNIX Shell</h2><h3 id=shell>Shell</h3><p><strong>简介</strong>：</p><p>Shell 是一种计算机程序，它将操作系统的服务暴露给人类用户或其他程序。</p><p>一般来说，操作系统的 Shell 使用命令行界面（CLI，Command Line Interface）或图形用户界面（GUI，Graphics User Interface），具体取决于计算机的角色和特定操作。</p><p>Shell Programming Language是一门把用户指令翻译成系统调用的编程语言。</p><p>Shell Scripts 是由 Shell Programming Language 编写的脚本文件，它们通常以 .sh 扩展名结尾，包含一系列的 Shell 命令和脚本语句，用于执行特定的操作和任务。</p><p><strong>功能</strong>：</p><ul><li>重定向: cmd > file &lt; file 2> /dev/null</li><li>顺序结构: cmd1; cmd2, cmd1 && cmd2, cmd1 || cmd2</li><li>管道: cmd1 | cmd2</li><li>预处理: $(), &lt;()</li><li>变量/环境变量、控制流……</li></ul><p><strong>未来展望</strong>：</p><ul><li>fish、zsh等用户友好、易用且美观的命令行界面</li><li><a href=https://tldr.sh/ target=_blank>tldr</a>、<a href=https://github.com/nvbn/thefuck target=_blank>thefuck</a>等自动补全工具</li><li>类似vscode的命令板块（Ctrl-Shift-P）</li><li><a href=https://dl.acm.org/doi/pdf/10.1145/3371111 target=_blank>Executable Formal Semantics for the POSIX Shell</a></li></ul><h3 id=终端和job-control>终端和Job Control</h3><p><strong>终端</strong>：</p><p>终端（Terminal）是一种计算机的输入/输出设备，用于与计算机进行交互，输入指令或命令，输出结果或信息。</p><p>在早期的计算机系统中，终端通常是一个物理设备，例如打字机或显示器。用户可以通过终端连接到计算机，并通过终端输入指令或命令，操作计算机。</p><p>在现代操作系统中，终端通常是软件模拟的。例如，在Unix或Linux系统中，终端通常是一个命令行界面，用户可以通过终端窗口输入命令，并在终端窗口中看到计算机的响应。</p><p><strong>终端与Shell</strong>：</p><p>终端和shell是计算机系统中密切相关的两个概念，它们之间有着紧密的关系。</p><p>当用户在终端中输入命令时，终端会将用户输入的内容传递给Shell，由Shell对其进行解释和执行，并将结果输出到终端中。</p><p><strong>Session & Process Group</strong>：</p><p>会话是一组相互关联的进程的集合。</p><p>在一个会话中，每个进程组都有一个唯一的进程组ID（PGID），并且每个进程都会属于一个进程组。进程可以通过setpgid系统调用来将自己或其他进程加入到指定的进程组中，也可以通过getpgid系统调用来获取自己或其他进程所在的进程组ID。</p><p>进程组和会话之间的关系如下：</p><ul><li>一个会话可以包含多个进程组。</li><li>每个进程组可以包含多个进程。</li><li>一个进程组可以与一个控制终端关联，也可以从控制终端中分离出来。</li></ul><p><figure><img src=https://jyywiki.cn/pages/OS/img/process-groups-sessions.png alt="process group &amp;amp; session"></figure></p><p><strong>Job Control</strong>：</p><p>The PGID (process-group ID) is preserved across an execve(2) and inherited in fork(2)&mldr;</p><p>Each process group is a member of a session.</p><p><figure><img src=https://jyywiki.cn/pages/OS/img/tty-session.png alt="job control"></figure></p><p>A session can have a controlling terminal.</p><ul><li>At any time, one (and only one) of the process groups in the session can be the foreground process group for the terminal; the remaining process groups are in the background.</li><li>If a signal is generated from the terminal (e.g., typing the interrupt key to generate SIGINT), that signal is sent to the foreground process group.</li><li>Only the foreground process group may read(2) from the terminal; if a background process group tries to read(2) from the terminal, then the group is sent a SIGTTIN signal, which suspends it.</li></ul><h2 id=14-c标准库的实现>14 C标准库的实现</h2><h3 id=libc>libc</h3><p>libc是一个C语言标准库，它包括大量的函数和头文件，提供了许多常用的系统调用和库函数，用于编写Unix和类Unix操作系统中的应用程序。</p><p>libc是操作系统中最基本的库之一，它为其他库和应用程序提供了基础的支持。</p><p><strong>为什么需要libc</strong>：</p><p>libc提供一层基础的封装，使得开发人员更方便了。</p><blockquote><p>在C语言标准中，有两种环境：hosted和freestanding。Hosted环境是指在操作系统上使用标准库的环境，这种环境下程序可以使用标准库提供的函数和语言特性。而Freestanding环境则是指在没有操作系统或标准库支持的情况下运行的环境，这种环境下程序必须自行处理底层硬件和系统资源。</p></blockquote><h3 id=libc组成>libc组成</h3><p><strong>封装1：存粹的计算</strong>：</p><ul><li>string.h: 字符串/数组操作</li><li>stdlib.h：atoi, atol, atoll, strtoull, rand</li><li>setjmp.h: 实现跨栈的非局部跳转</li><li>math.h: &mldr;</li></ul><p><strong>封装2：文件描述符</strong>：</p><p>以stdio.h为例，封装了FILE*和vprintf系列</p><p><strong>封装3：更多进程/操作系统功能</strong>：</p><p><strong>封装4：地址空间</strong>：</p><p>malloc 和 free</p><p><strong>实现malloc</strong>：</p><p><a href=https://www.microsoft.com/en-us/research/uploads/prod/2019/06/mimalloc-tr-v1.pdf target=_blank>mimalloc</a></p><h2 id=15-a-fork-in-the-road>15 a fork() in the road</h2><h3 id=fork行为的补充>fork()行为的补充</h3><ul><li>fork 状态机复制包括持有的所有操作系统对象</li><li>execve “重置” 状态机，但继承持有的所有操作系统对象</li></ul><p><strong>文件描述符</strong>：一个指向操作系统内对象的 “指针”</p><ul><li>从 0 开始编号 (0, 1, 2 分别是 stdin, stdout, stderr)</li><li>可以通过 open 取得；close 释放；dup “复制”</li><li>对于数据文件，文件描述符会 “记住” 上次访问文件的位置<ul><li>也就是说，操作系统必须正确管理文件的偏移量</li></ul></li></ul><p>值得注意的是，dup() 的两个文件描述符是共享偏移量的。因此，dup() 返回的新文件描述符和原文件描述符共享同一个文件偏移量，它们对文件读写操作是相互影响的。</p><h3 id=a-fork-in-the-roadhttpswwwmicrosoftcomen-usresearchuploadsprod201904fork-hotos19pdf><a href=https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf target=_blank>A fork() in the road</a></h3><p><strong>fork()是UNIX时代的遗产</strong>：</p><p>fork + execve：如果只有内存和文件描述符，这是十分优雅的方案</p><p>但在操作系统的演化过程中，为进程增加了更多的东西，比如：信号、线程等</p><h2 id=16-可执行文件>16 可执行文件</h2><p><strong>状态机的描述</strong>：</p><p>操作系统的诞生就是为了给应用程序提供执行环境，而可执行文件就是最重要的操作系统对象！</p><p>可执行文件是一个描述了状态机的初始状态 + 迁移的数据结构，包括：</p><ul><li>寄存器：大部分由 ABI 规定，操作系统负责设置，例如初始的 PC；</li><li>地址空间：二进制文件 + ABI 共同决定，例如 argv 和 envp (和其他信息) 的存储；</li><li>其他有用的信息 (例如便于调试和 core dump 的信息)。</li></ul><p><strong>可执行的条件</strong>：</p><ul><li>具有执行的权限；<ul><li>可以使用<code>chmod +x [file names]</code>为文件增添可执行权限。</li></ul></li><li>加载器能识别的可执行文件。</li></ul><p><strong>常见的可执行文件</strong>：</p><p>Windows:</p><ul><li>EXE</li><li>UEFI(Unified Extensible Firmware Interface)</li><li>PE(Portable Executable)</li></ul><p>UNIX/Linux:</p><ul><li>ELF(Executable Linkable Format)</li></ul><h3 id=解析可执行文件>解析可执行文件</h3><p><strong>GNU Binutils</strong>：</p><p>Binutils是一组开源工具集，用于创建、操作和转换二进制文件。可以按功能将Binutils分成两大部分，分别是</p><ul><li>帮助生成可执行文件的工具，比如：ld (linker), as (assembler), ar (archiver)；</li><li>帮助分析可执行文件的工具，比如：objcopy/objdump/readelf。</li></ul><h3 id=编译和链接>编译和链接</h3><p>编译器生成文本汇编代码 → 汇编器生成二进制指令序列。</p><p><strong>重定位 Relocation</strong>：</p><p>重定位是指将一个程序或库加载到内存中时，将它们在内存中的位置从编译时指定的地址（静态地址）调整为运行时实际的地址的过程。</p><p>重定位通常是由操作系统的动态链接器或加载器完成的，它们负责将程序或库加载到内存中，并修复程序或库中的所有引用，以便在运行时正确地执行。</p><p><strong>ELF文件</strong>：</p><p>ELF 就是一个 “容器数据结构”，包含了必要的信息。</p><p><strong>重新理解编译、链接流程</strong>：</p><p>编译器 (gcc)：High-level semantics (C 状态机) → low-level semantics (汇编)</p><p>汇编器 (as)：Low-level semantics → Binary semantics (状态机容器)</p><ul><li>“一一对应” 地翻译成二进制代码<ul><li>sections, symbols, debug info</li></ul></li><li>不能决定的要留下 “之后怎么办” 的信息<ul><li>relocations</li></ul></li></ul><p>链接器 (ld)：合并所有容器，得到 “一个完整的状态机”</p><ul><li>ldscript (-Wl,&ndash;verbose); 和 C Runtime Objects (CRT) 链接</li><li>missing/duplicate symbol 会出错</li></ul><h2 id=17-可执行文件的加载>17 可执行文件的加载</h2><h3 id=静态elf加载器>静态ELF加载器</h3><p><strong>加载器的功能</strong>：</p><ul><li>解析数据结构 + 复制到内存 + 跳转；</li><li>创建进程运行时初始状态 (argv, envp, &mldr;)。</li></ul><p><strong>Boot Block Loader</strong>：</p><p>Boot Block Loader也是也一个加载器，它能加载操作系统内核。此外，Boot Block Loader通常也称为引导扇区（boot sector），它的大小则一般为512字节。</p><p>具体来说，Boot Block Loader加载操作系统的工作流程是：</p><ul><li>首先，BIOS在启动盘第一个扇区，中查找引导程序，即：Boot Block Loader；</li><li>接着，BIOS会将该扇区中的512字节加载到内存中的0x7C00地址，并跳转到这个地址开始执行Boot Block Loader中的代码；</li><li>最后，由Boot Block Loader加载操作系统内核，并跳转到核心代码入口开始执行操作系统。</li></ul><h3 id=动态链接>动态链接</h3><p><strong>拆解应用程序的必要性</strong>：</p><p>随着库函数越来越大，希望项目能够 “运行时链接”。</p><p>动态链接能够减少库函数的磁盘和内存拷贝，如果每个可执行文件里都有所有库函数的拷贝那也太浪费了。</p><h2 id=18-x86代码导读>18 x86代码导读</h2><p>xv6是一个基于Unix V6操作系统的教学性质的操作系统，旨在帮助学生更好地理解操作系统的设计和实现。</p><h2 id=19-实现上下文切换>19 实现上下文切换</h2><h2 id=20-处理器调度>20 处理器调度</h2><h3 id=动态优先级>动态优先级</h3><h2 id=21-操作系统设计>21 操作系统设计</h2><h2 id=22-存储设备原理>22 存储设备原理</h2><p>持久存储介质：</p><ul><li>构成一切文件的基础<ul><li>逻辑上是一个 bit/byte array</li><li>根据局部性原理，允许我们按 “大块” 读写</li></ul></li><li>评价方法：价格、容量、速度、可靠性</li></ul><h3 id=存储介质磁>存储介质：磁</h3><p><strong>磁盘 Hard Disk</strong>：</p><p>通过在二维平面上放置许多磁带实现了1D → 2.5D (2D x n)。</p><p><figure><img src=https://jyywiki.cn/pages/OS/img/disk-mechanism.jpg alt=磁盘示意图></figure></p><p>特点：</p><ul><li>价格低：密度越高，成本越低；</li><li>容量高：因为平面上可以有数万个磁道；</li><li>读写速度：顺序读取速度较高，但随机读取速度比较勉强；</li><li>可靠性一般：存在机械部件，磁头划伤盘片导致数据损坏。</li></ul><p>今天的应用场景：计算机系统的主力数据存储 (海量数据：便宜才是王道)</p><p>读取硬盘某个扇区的流程：</p><ul><li>读写头需要到对应的磁道；</li><li>转轴将盘片旋转到读写头的位置。</li></ul><p>通过缓存/调度等策略优化读取：</p><ul><li>例如著名的 “电梯” 调度算法；</li><li>现代 HDD 都有很好的 firmware 管理磁盘 I/O 调度。</li></ul><p><strong>软盘 Floppy Disk</strong>：</p><p>把读写头和盘片分开——实现数据移动（计算机上的软盘驱动器 (drive) + 可移动的盘片）</p><p>特点：</p><ul><li>价格低</li><li>容量低</li><li>读写速度：顺序和随机读取速度均较低</li><li>可靠性也较低</li></ul><p>今天的应用场景：躺在博物馆供人参观</p><h3 id=存储介质坑>存储介质：坑</h3><p><strong>光盘 Compact Disk</strong>：</p><p>特点：</p><ul><li>价格很低</li><li>容量高</li><li>读写速度：顺序读取速度高，但随机读取速度比较勉强，此外写入速度极低</li><li>可靠性高</li></ul><h3 id=存储介质电>存储介质：电</h3><p><strong>固态硬盘 Solid State Drive</strong>：</p><p>特点：</p><ul><li>价格低</li><li>容量高</li><li>读写速度高</li><li>可靠性高</li></ul><p>但它有一个致命的缺点，放电做不到 100% 放干净。因此，可能会出现数据丢失或存储介质失效的情况，也被称为NAND Wear-Out。</p><blockquote><p>NAND Flash的全称是“Negative-AND Flash”，即“负与门闪存”。</p></blockquote><p><strong>NAND Wear-Out解决方案</strong>：软件定义磁盘</p><p>FTL（Flash Translation Layer）是一种在 NAND Flash 存储器上运行的软件层，用于管理和控制 NAND Flash 存储器中的数据读写和存储。</p><p>其中，Wear Leveling 是 FTL 技术中的一种重要技术，它通过软件管理 NAND Flash 存储器中的块，避免重复写入同一块，从而平衡存储介质中每个块的使用次数，延长 NAND Flash 存储器的使用寿命。</p><h2 id=23-输入输出设备>23 输入输出设备</h2><h3 id=总线中断控制器和-dma>总线、中断控制器和 DMA</h3><p><strong>总线 Bus</strong>：一个特殊的 I/O 设备</p><p>提供设备的注册和地址到设备的转发</p><p><strong>中断控制器 Interrupt Controller</strong>：</p><h3 id=gpu和异构计算>GPU和异构计算</h3><p><strong>现代GPU：一个通用计算设备</strong>：</p><p>一个完整的众核多处理器系统</p><ul><li>注重大量并行相似的任务<ul><li>程序使用例如 OpenGL, CUDA, OpenCL, &mldr; 书写</li></ul></li><li>程序保存在内存 (显存) 中<ul><li>nvcc (LLVM) 分两个部分<ul><li>main 编译/链接成本地可执行的 ELF</li><li>kernel 编译成 GPU 指令 (送给驱动)</li></ul></li></ul></li><li>数据也保存在内存 (显存) 中<ul><li>可以输出到视频接口 (DP, HDMI, &mldr;)</li><li>也可以通过 DMA 传回系统内存</li></ul></li></ul><h2 id=24-设备驱动程序>24 设备驱动程序</h2><h3 id=设备驱动程序的原理>设备驱动程序的原理</h3><p><strong>I/O设备的抽象</strong>：</p><p>I/O 设备的主要功能：能够读 (read) 写 (write) 的字节序列 (流或数组)</p><p>操作系统：设备 = 支持各类操作的对象 (文件)</p><ul><li>read - 从设备某个指定的位置读出数据</li><li>write - 向设备某个指定位置写入数据</li><li>ioctl（Input/Output Control）- 读取/设置设备的状态</li></ul><p>因此，设备驱动就是<strong>把 read/write/ioctl 等系统调用翻译成设备听得懂的协议</strong>。</p><h3 id=linux设备驱动程序>Linux设备驱动程序</h3><p>Linux驱动一般是以内核模块的形式存在。</p><blockquote><p>内核模块：一段可以被内核动态加载执行的代码</p></blockquote><p>总结：</p><ul><li>设备驱动将操作系统给上层应用提供的文件操作（read/write/ioctl）翻译成设备控制协议。</li><li>因为驱动是内核模块，所以设备在内核中初始化和注册。<ul><li>换句话说，系统调用直接以函数调用的方式执行驱动代码。</li></ul></li></ul><h3 id=gpu编程>GPU编程</h3><h3 id=存储设备的抽象>存储设备的抽象</h3><h2 id=25-文件系统api>25 文件系统API</h2><h3 id=文件系统的作用>文件系统的作用</h3><p><strong>文件系统的设计目标</strong>：</p><ul><li>提供合理的 API 使多个应用程序能共享数据</li><li>提供一定的隔离，使恶意/出错程序的伤害不能任意扩大</li></ul><p>一句话总结，文件系统能够实现存储设备的虚拟化。</p><p><strong>目录树</strong>：将虚拟磁盘 (文件) 组织形成的层次结构</p><p>树总得有个根结点</p><ul><li>对于Windows来说，每个设备（驱动器）是一棵树。<ul><li>其中，A:\ 和 B:\ 是早期操作系统中用来表示软盘驱动器。</li><li>对于其他设备，例如硬盘驱动器、光盘驱动器、USB 存储器等，它们通常被分配更高的卷标，例如 C:\、D:\ 等。</li></ul></li><li>对于UNIX/Linux来说，它们只有一个根/，其他目录都是以/为起点。</li></ul><p><strong>目录树的拼接</strong>：</p><p>UNIX: 允许任意目录 “挂载 (mount)” 一个设备代表的目录树</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>mount</span>(<span style=color:#080;font-weight:700>const</span> <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>source, <span style=color:#080;font-weight:700>const</span> <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>target,
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>const</span> <span style=color:#339;font-weight:700>char</span> <span style=color:#333>*</span>filesystemtype, <span style=color:#339;font-weight:700>unsigned</span> <span style=color:#339;font-weight:700>long</span> mountflags,
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>const</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#333>*</span>data);
</span></span></code></pre></div><p><strong>文件的挂载</strong>：</p><p><strong>Filesystem Hierarchy Standard (FHS)</strong>：</p><p>Filesystem Hierarchy Standard (FHS) 是一个定义了 Linux 和其他类 Unix 操作系统下的文件系统组织结构标准的规范</p><ul><li>/usr：用于存放系统级别的应用程序和相关文件。</li><li>/var：用于存放系统运行时的可变数据，如日志文件、缓存文件等。</li><li>/bin：包含一些必要的系统工具和命令。</li><li>/sbin：包含一些系统级别的管理工具和命令，只有管理员才有访问权限。</li><li>/lib：包含一些系统级别的库文件，供应用程序使用。</li><li>/etc：包含一些系统级别的配置文件。</li><li>/dev：包含一些设备文件，用于访问硬件设备。</li><li>/proc：包含一些进程相关的信息，可以动态访问。</li></ul><h3 id=目录api>目录API</h3><p><strong>硬链接 hard link</strong>：</p><p><strong>软链接 symbolic link</strong>：</p><h3 id=文件api>文件API</h3><h2 id=26-fat和unix文件系统>26 FAT和UNIX文件系统</h2><h3 id=file-allocation-table-fat>File Allocation Table (FAT)</h3><h3 id=ext2unix文件系统>ext2/UNIX文件系统</h3></div></div></article></div></main><footer>© Copyright <a href=https://github.com/Zhytou target=_blank>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae target=_blank>Vitae</a> theme for <a href=https://gohugo.io target=_blank>Hugo</a></footer><script src=/js/dark-mode.js></script></body></html>
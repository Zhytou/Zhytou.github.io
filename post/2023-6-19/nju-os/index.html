<!doctype html><html lang=en><head><meta charset=utf-8><title>NJU-OS笔记 | Zhytou</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.115.3"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><meta property="og:title" content="NJU-OS笔记"><meta property="og:description" content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
3 多处理器编程 并发 并发的基本单位——线程：
共享内存的多个执行流：
执行流拥有独立的堆栈/寄存器 共享全部的内存（指针可以相互引用） POSIX Threads
实现原子性
实现临界区之间的绝对串行化 程序其他部分依然并行执行
4 理解并发程序执行 5 并发控制：互斥 共享内存的互斥
自旋锁 Spinlock 自旋锁是一种基于忙等待的锁。
当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。
x86 LOCK指令前缀：
x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。
使用带LOCK前缀的指令能实现多种原子操作，如：
原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。 实现自旋锁：
// atomic exchange int xchg(volatile int *addr, int newval) { int result; asm volatile (&#34;lock xchg %0, %1&#34; : &#34;+m&#34;(*addr), &#34;=a&#34;(result) : &#34;1&#34;(newval)); return result; } int locked = 0; void lock() { while (xchg(&amp;locked, 1)) ; } void unlock() { xchg(&amp;locked, 0); } 原子操作与Bus Lock："><meta property="og:type" content="article"><meta property="og:url" content="https://zhytou.github.io/post/2023-6-19/nju-os/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-06-19T21:22:58+08:00"><meta property="article:modified_time" content="2023-06-19T21:22:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NJU-OS笔记"><meta name=twitter:description content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
3 多处理器编程 并发 并发的基本单位——线程：
共享内存的多个执行流：
执行流拥有独立的堆栈/寄存器 共享全部的内存（指针可以相互引用） POSIX Threads
实现原子性
实现临界区之间的绝对串行化 程序其他部分依然并行执行
4 理解并发程序执行 5 并发控制：互斥 共享内存的互斥
自旋锁 Spinlock 自旋锁是一种基于忙等待的锁。
当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。
x86 LOCK指令前缀：
x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。
使用带LOCK前缀的指令能实现多种原子操作，如：
原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。 实现自旋锁：
// atomic exchange int xchg(volatile int *addr, int newval) { int result; asm volatile (&#34;lock xchg %0, %1&#34; : &#34;+m&#34;(*addr), &#34;=a&#34;(result) : &#34;1&#34;(newval)); return result; } int locked = 0; void lock() { while (xchg(&amp;locked, 1)) ; } void unlock() { xchg(&amp;locked, 0); } 原子操作与Bus Lock："><meta itemprop=name content="NJU-OS笔记"><meta itemprop=description content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
3 多处理器编程 并发 并发的基本单位——线程：
共享内存的多个执行流：
执行流拥有独立的堆栈/寄存器 共享全部的内存（指针可以相互引用） POSIX Threads
实现原子性
实现临界区之间的绝对串行化 程序其他部分依然并行执行
4 理解并发程序执行 5 并发控制：互斥 共享内存的互斥
自旋锁 Spinlock 自旋锁是一种基于忙等待的锁。
当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。
x86 LOCK指令前缀：
x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。
使用带LOCK前缀的指令能实现多种原子操作，如：
原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。 实现自旋锁：
// atomic exchange int xchg(volatile int *addr, int newval) { int result; asm volatile (&#34;lock xchg %0, %1&#34; : &#34;+m&#34;(*addr), &#34;=a&#34;(result) : &#34;1&#34;(newval)); return result; } int locked = 0; void lock() { while (xchg(&amp;locked, 1)) ; } void unlock() { xchg(&amp;locked, 0); } 原子操作与Bus Lock："><meta itemprop=datePublished content="2023-06-19T21:22:58+08:00"><meta itemprop=dateModified content="2023-06-19T21:22:58+08:00"><meta itemprop=wordCount content="502"><meta itemprop=keywords content></head><body><header><div id=avatar><a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a></div><div id=titletext><h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2></div><div id=title-description><p id=subtitle>May the force be with me.</p><div id=social><nav><ul><li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li><li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>Posts</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>19</span>
<span class=rest>Jun 2023</span></div></div><div class=matter><h1 class=title>NJU-OS笔记</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><p>这篇博客流水线的记录一下自己学习<a href=https://jyywiki.cn/OS/2022/ target=_blank>NJU-OS</a>的笔记。</p><h2 id=1-操作系统概述>1 操作系统概述</h2><blockquote><p>本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。</p></blockquote><h3 id=计算机历史>计算机历史</h3><h3 id=理解操作系统>理解操作系统</h3><p>理解操作系统，就是回答下面三个问题：</p><ul><li>操作系统服务谁？<ul><li>操作系统服务应用程序，而程序可以理解成状态机。</li><li>注：课程涉及多线程Linux应用程序。</li></ul></li><li>站在应用视角，操作系统能为程序提供什么服务？<ul><li>操作系统 = （可操作的）对象 + （可调用的）API</li><li>注：课程只涉及 POSIX + 部分Linux特性。</li></ul></li><li>站在硬件视角，如何实现操作系统并提供这些服务？<ul><li>操作系统 = C程序</li><li>注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。</li></ul></li></ul><blockquote><p>xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。</p></blockquote><h2 id=2-操作系统上的程序>2 操作系统上的程序</h2><h3 id=什么是程序>什么是程序</h3><h3 id=操作系统中的一般程序>操作系统中的一般程序</h3><blockquote><p>课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的<a href=/>tmux笔记</a>。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。</p></blockquote><h2 id=3-多处理器编程>3 多处理器编程</h2><h3 id=并发>并发</h3><p><strong>并发的基本单位——线程</strong>：</p><p>共享内存的多个执行流：</p><ul><li>执行流拥有独立的堆栈/寄存器</li><li>共享全部的内存（指针可以相互引用）</li></ul><p>POSIX Threads</p><p>实现原子性</p><p>实现临界区之间的绝对串行化
程序其他部分依然并行执行</p><h2 id=4-理解并发程序执行>4 理解并发程序执行</h2><h2 id=5-并发控制互斥>5 并发控制：互斥</h2><p>共享内存的互斥</p><h3 id=自旋锁-spinlock>自旋锁 Spinlock</h3><p>自旋锁是一种基于忙等待的锁。</p><p>当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。</p><p><strong>x86 LOCK指令前缀</strong>：</p><p>x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。</p><p>使用带LOCK前缀的指令能实现多种原子操作，如：</p><ul><li>原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。</li><li>原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。</li></ul><p><strong>实现自旋锁</strong>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// atomic exchange
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>xchg</span>(<span style=color:#080;font-weight:700>volatile</span> <span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span>addr, <span style=color:#339;font-weight:700>int</span> newval) {
</span></span><span style=display:flex><span>  <span style=color:#339;font-weight:700>int</span> result;
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>asm</span> <span style=color:#080;font-weight:700>volatile</span> (<span style=background-color:#fff0f0>&#34;lock xchg %0, %1&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#333>:</span> <span style=background-color:#fff0f0>&#34;+m&#34;</span>(<span style=color:#333>*</span>addr), <span style=background-color:#fff0f0>&#34;=a&#34;</span>(result) <span style=color:#333>:</span> <span style=background-color:#fff0f0>&#34;1&#34;</span>(newval));
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#339;font-weight:700>int</span> locked <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>lock</span>() { <span style=color:#080;font-weight:700>while</span> (xchg(<span style=color:#333>&amp;</span>locked, <span style=color:#00d;font-weight:700>1</span>)) ; }
</span></span><span style=display:flex><span><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>unlock</span>() { xchg(<span style=color:#333>&amp;</span>locked, <span style=color:#00d;font-weight:700>0</span>); }
</span></span></code></pre></div><p><strong>原子操作与Bus Lock</strong>：</p><p>早期原子操作的实现依靠总线上锁来实现。具体如下，当一个处理器执行带有LOCK前缀的指令时，它会锁住内存总线，防止其他处理器同时对同一内存地址进行操作，从而确保了原子操作的正确性。</p><p><strong>原子操作的现代实现</strong>：</p><p>现代处理器中，原子操作通常是通过硬件支持来实现的，它们能够保证对内存的原子操作，而不需要锁住总线或者使用其他的软件实现方式，从而提高了系统的性能和并发能力。</p><p><strong>C++支持的原子操作</strong>：</p><p>详细信息可以阅读<a href=https://en.cppreference.com/w/cpp/atomic/atomic_exchange target=_blank>cppreference</a>。</p><p><strong>自旋锁的缺陷</strong>：</p><ul><li>自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加；</li><li>除了进入临界区的线程，其他处理器上的线程都在空转，且争抢锁的处理器越多，利用率越低；</li><li>获得自旋锁的线程可能被操作系统切换出去。</li></ul><p><strong>自旋锁适合的使用场景</strong>：</p><ul><li>临界区几乎不 “拥堵”；</li><li>持有自旋锁时禁止执行流切换。</li></ul><p>换句话说，自旋锁适用于短临界区的场景，比如操作系统内核的并发数据结构。</p><h3 id=互斥锁-mutex>互斥锁 Mutex</h3><p>互斥锁（mutex）是一种基于操作系统的同步原语，它使用了操作系统提供的系统调用来实现线程同步和互斥。</p><p>互斥锁的实现通常是基于一种叫做“睡眠-唤醒”机制的方式，当一个线程需要获取锁时，如果锁已经被占用，那么这个线程会被阻塞，直到锁被释放。当锁被释放时，操作系统会唤醒等待的线程，让它们竞争锁。</p><h3 id=快速用户空间互斥锁-futex>快速用户空间互斥锁 Futex</h3><p>Futex（Fast Userspace Mutex）是一种基于用户空间的同步原语。实际上，就是Spinlock和Mutex的混合。</p><p><strong>Futex的上锁过程</strong>：</p><ul><li>先在用户空间自旋。<ul><li>如果获得锁，直接进入；</li><li>未能获得锁，系统调用。</li></ul></li><li>解锁以后也需要系统调用。</li></ul><h3 id=5-总结>5 总结</h3><p>软件不够，硬件来凑 (自旋锁)
用户不够，内核来凑 (互斥锁)</p><h2 id=6-并发控制同步>6 并发控制：同步</h2><h3 id=线程同步>线程同步</h3><p>线程同步：在某个时间点共同达到互相已知的状态。</p><h3 id=条件变量>条件变量</h3><p>条件变量是一种用于线程间通信的同步原语，它允许一个线程等待另一个线程满足特定条件后再继续执行。</p><p>条件变量通常需要和互斥锁一起使用，以避免出现竞争和冲突。当一个线程需要等待特定条件时，它会释放互斥锁并进入等待状态，直到另一个线程满足条件并唤醒它。</p><h3 id=信号量>信号量</h3><p>信号量是一种计数器，用于控制同时可以访问共享资源的线程或进程数量。</p><p>在多个线程或进程竞争同一资源的情况下，信号量可以限制同时访问资源的线程或进程数量，避免竞争和冲突。</p><p>信号量有两种类型：二元信号量和计数信号量。</p><ul><li>二元信号量只有两种状态，0和1，用于实现互斥锁的功能；</li><li>计数信号量可以有多个状态，用于实现多个线程或进程之间的协作和同步。</li></ul><p>值得注意的是，虽然C++标准库中没有直接提供信号量的实现，但可以通过第三方库或者自己编写代码（互斥量+原子操作）来实现信号量。</p><h2 id=7-真实世界的并发编程>7 真实世界的并发编程</h2><p>并发编程的真实应用场景:</p><ul><li>高性能计算 (注重任务分解): 生产者-消费者 (MPI/OpenMP)</li><li>数据中心 (注重系统调用): 线程-协程 (Goroutine)</li><li>人机交互 (注重易用性): 事件-流图 (Promise)</li></ul><h2 id=8-并发bug和应对>8 并发Bug和应对</h2><h3 id=死锁-dead-lock>死锁 Dead Lock</h3><p><strong>死锁产生的条件</strong>：</p><ul><li>互斥：一个资源每次只能被一个进程使用</li><li>请求与保持：一个进程请求资阻塞时，不释放已获得的资源</li><li>不剥夺：进程已获得的资源不能强行剥夺</li><li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li></ul><h3 id=数据竞争-data-race>数据竞争 Data Race</h3><h2 id=9-操作系统的状态机模型>9 操作系统的状态机模型</h2><h2 id=10-状态机模型的应用>10 状态机模型的应用</h2><h2 id=11-操作系统上的进程>11 操作系统上的进程</h2><h3 id=回顾>回顾</h3><p><strong>定制Linux</strong>：</p><p>BusyBox: The Swiss Army Knife of embedded Linux</p><p>adb shell(toybox)</p><p><strong>Linux操作系统启动流程</strong>：</p><ul><li>CPU Reset</li><li>Firmware</li><li>Loader</li><li>Kernel_start</li><li>/bin/init</li><li>程序执行+系统调用</li></ul><p><strong>应用视角的操作系统</strong>：</p><p>操作系统为所有程序提供API</p><ul><li>进程&线程（状态机）管理<ul><li>fork,execve,exit - 进程的创建、改变和删除</li><li>pthread_create,pthread_join,pthread_exit - 线程的创建和退出</li></ul></li><li>存储（地址空间）管理<ul><li>mmap - 虚拟地址空间管理</li></ul></li><li>文件（数据对象）管理<ul><li>open,close,read,write - 文件访问管理</li><li>mkdir,link,unlink - 目录管理</li></ul></li></ul><h3 id=fork>fork()</h3><p><strong>理解操作系统是状态机管理者</strong>：</p><ul><li>操作系统在物理内存中保存多个状态机；</li><li>通过虚拟内存实现，拿一个来执行；</li><li>中断后进入操作系统代码，换一个执行。</li></ul><p><strong>状态机管理之创建状态机</strong>：</p><p>UNIX的答案是fork，即：做一份状态机的完整复制（内存、寄存器现场）。</p><p><strong>理解fork函数</strong>：</p><p><code>pid_t fork(void)</code></p><p>在fork函数返回后，会有两个进程同时运行，其中一个是父进程，另一个是新创建的子进程。</p><p>在子进程创建成功后，它会复制父进程的代码和数据段，并且开始执行从fork函数返回的位置。也就是说，子进程会从fork函数返回的地方开始执行，而不是从程序的起始位置开始执行。</p><p>需要注意的是，在子进程中，fork函数的返回值是0，而在父进程中，fork函数的返回值是新创建的子进程的进程ID。因此，在父进程中可以通过判断fork函数的返回值来区分当前进程是父进程还是子进程。</p><h3 id=execve>execve()</h3><p><strong>状态机管理之替换状态机</strong>：</p><p>UNIX的答案是execve，即：将当前运行的状态机重置成另一个程序的初始状态。</p><p><strong>理解execve函数</strong>：</p><p><code>int execve(const char *pathname, char *const argv[], char *const envp[]);</code></p><ul><li>pathname：指定要执行的程序的路径，可以是绝对路径或者相对路径。如果路径中不包含目录分隔符 /，则会从环境变量 PATH 中查找可执行文件。</li><li>argv：一个以 NULL 结尾的字符串数组，用于指定新程序的命令行参数。第一个元素通常是程序的名称，后面的元素是程序的参数。注意，第一个元素是程序的名称，而非路径名。</li><li>envp：一个以 NULL 结尾的字符串数组，用于指定新程序的环境变量。每个字符串都是一个形如 key=value 的键值对，表示一个环境变量的值。</li></ul><p>execve函数执行成功时，不会返回到调用进程，而是直接将当前进程替换为新程序的进程。如果执行失败，则会返回 -1，并设置相应的错误码。</p><h2 id=12-进程的地址空间>12 进程的地址空间</h2><h2 id=13-系统调用和unix-shell>13 系统调用和UNIX Shell</h2><h3 id=shell>Shell</h3><p><strong>简介</strong>：</p><p>Shell 是一种计算机程序，它将操作系统的服务暴露给人类用户或其他程序。</p><p>一般来说，操作系统的 Shell 使用命令行界面（CLI，Command Line Interface）或图形用户界面（GUI，Graphics User Interface），具体取决于计算机的角色和特定操作。</p><p>Shell Programming Language是一门把用户指令翻译成系统调用的编程语言。</p><p>Shell Scripts 是由 Shell Programming Language 编写的脚本文件，它们通常以 .sh 扩展名结尾，包含一系列的 Shell 命令和脚本语句，用于执行特定的操作和任务。</p><p><strong>功能</strong>：</p><ul><li>重定向: cmd > file &lt; file 2> /dev/null</li><li>顺序结构: cmd1; cmd2, cmd1 && cmd2, cmd1 || cmd2</li><li>管道: cmd1 | cmd2</li><li>预处理: $(), &lt;()</li><li>变量/环境变量、控制流……</li></ul><p><strong>未来展望</strong>：</p><ul><li>fish、zsh等用户友好、易用且美观的命令行界面</li><li><a href=https://tldr.sh/ target=_blank>tldr</a>、<a href=https://github.com/nvbn/thefuck target=_blank>thefuck</a>等自动补全工具</li><li>类似vscode的命令板块（Ctrl-Shift-P）</li><li><a href=https://dl.acm.org/doi/pdf/10.1145/3371111 target=_blank>Executable Formal Semantics for the POSIX Shell</a></li></ul><h3 id=终端和job-control>终端和Job Control</h3><h2 id=14-c标准库的实现>14 C标准库的实现</h2><h2 id=15-a-fork-in-the-road>15 a fork() in the road</h2><h2 id=16-可执行文件>16 可执行文件</h2><p><strong>状态机的描述</strong>：</p><p>操作系统的诞生就是为了给应用程序提供执行环境，而可执行文件就是最重要的操作系统对象！</p><p>可执行文件是一个描述了状态机的初始状态 + 迁移的数据结构，包括：</p><ul><li>寄存器：大部分由 ABI 规定，操作系统负责设置，例如初始的 PC；</li><li>地址空间：二进制文件 + ABI 共同决定，例如 argv 和 envp (和其他信息) 的存储；</li><li>其他有用的信息 (例如便于调试和 core dump 的信息)。</li></ul><p><strong>可执行的条件</strong>：</p><ul><li>具有执行的权限；<ul><li>可以使用<code>chmod +x [file names]</code>为文件增添可执行权限。</li></ul></li><li>加载器能识别的可执行文件。</li></ul><p><strong>常见的可执行文件</strong>：</p><p>Windows:</p><ul><li>EXE</li><li>UEFI(Unified Extensible Firmware Interface)</li><li>PE(Portable Executable)</li></ul><p>UNIX/Linux:</p><ul><li>ELF(Executable Linkable Format)</li></ul><h3 id=解析可执行文件>解析可执行文件</h3><p><strong>GNU Binutils</strong>：</p><p>Binutils是一组开源工具集，用于创建、操作和转换二进制文件。可以按功能将Binutils分成两大部分，分别是</p><ul><li>帮助生成可执行文件的工具，比如：ld (linker), as (assembler), ar (archiver)；</li><li>帮助分析可执行文件的工具，比如：objcopy/objdump/readelf。</li></ul><hr><h3 id=编译和链接>编译和链接</h3><p>编译器生成文本汇编代码 → 汇编器生成二进制指令序列。</p><p><strong>重定位 Relocation</strong>：</p><p>重定位是指将一个程序或库加载到内存中时，将它们在内存中的位置从编译时指定的地址（静态地址）调整为运行时实际的地址的过程。</p><p>重定位通常是由操作系统的动态链接器或加载器完成的，它们负责将程序或库加载到内存中，并修复程序或库中的所有引用，以便在运行时正确地执行。</p><p><strong>ELF文件</strong>：</p><p>ELF 就是一个 “容器数据结构”，包含了必要的信息。</p><p><strong>重新理解编译、链接流程</strong>：</p><p>编译器 (gcc)：High-level semantics (C 状态机) → low-level semantics (汇编)</p><p>汇编器 (as)：Low-level semantics → Binary semantics (状态机容器)</p><ul><li>“一一对应” 地翻译成二进制代码<ul><li>sections, symbols, debug info</li></ul></li><li>不能决定的要留下 “之后怎么办” 的信息<ul><li>relocations</li></ul></li></ul><p>链接器 (ld)：合并所有容器，得到 “一个完整的状态机”</p><ul><li>ldscript (-Wl,&ndash;verbose); 和 C Runtime Objects (CRT) 链接</li><li>missing/duplicate symbol 会出错</li></ul><h2 id=17-可执行文件的加载>17 可执行文件的加载</h2><h3 id=静态elf加载器>静态ELF加载器</h3><p><strong>加载器的功能</strong>：</p><ul><li>解析数据结构 + 复制到内存 + 跳转；</li><li>创建进程运行时初始状态 (argv, envp, &mldr;)。</li></ul><p><strong>Boot Block Loader</strong>：</p><p>Boot Block Loader也是也一个加载器，它能加载操作系统内核。此外，Boot Block Loader通常也称为引导扇区（boot sector），它的大小则一般为512字节。</p><p>具体来说，Boot Block Loader加载操作系统的工作流程是：</p><ul><li>首先，BIOS在启动盘第一个扇区，中查找引导程序，即：Boot Block Loader；</li><li>接着，BIOS会将该扇区中的512字节加载到内存中的0x7C00地址，并跳转到这个地址开始执行Boot Block Loader中的代码；</li><li>最后，由Boot Block Loader加载操作系统内核，并跳转到核心代码入口开始执行操作系统。</li></ul><h3 id=动态链接>动态链接</h3><p><strong>拆解应用程序的必要性</strong>：</p><p>随着库函数越来越大，希望项目能够 “运行时链接”。</p><p>动态链接能够减少库函数的磁盘和内存拷贝，如果每个可执行文件里都有所有库函数的拷贝那也太浪费了。</p><h2 id=18-x86代码导读>18 x86代码导读</h2><h2 id=19-实现上下文切换>19 实现上下文切换</h2></div></div></article></div></main><footer>© Copyright <a href=https://github.com/Zhytou target=_blank>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae target=_blank>Vitae</a> theme for <a href=https://gohugo.io target=_blank>Hugo</a></footer><script src=/js/dark-mode.js></script></body></html>
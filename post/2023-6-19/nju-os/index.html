<!doctype html><html lang=en><head><meta charset=utf-8><title>NJU-OS笔记 | Zhytou</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.114.1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><meta property="og:title" content="NJU-OS笔记"><meta property="og:description" content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
11 操作系统上的进程 回顾 定制Linux：
BusyBox: The Swiss Army Knife of embedded Linux
adb shell(toybox)
Linux操作系统启动流程：
CPU Reset Firmware Loader Kernel_start /bin/init 程序执行+系统调用 应用视角的操作系统：
操作系统为所有程序提供API
进程&线程（状态机）管理 fork,execve,exit - 进程的创建、改变和删除 pthread_create,pthread_join,pthread_exit - 线程的创建和退出 存储（地址空间）管理 mmap - 虚拟地址空间管理 文件（数据对象）管理 open,close,read,write - 文件访问管理 mkdir,link,unlink - 目录管理 fork() 理解操作系统是状态机管理者："><meta property="og:type" content="article"><meta property="og:url" content="https://zhytou.github.io/post/2023-6-19/nju-os/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-06-19T21:22:58+08:00"><meta property="article:modified_time" content="2023-06-19T21:22:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NJU-OS笔记"><meta name=twitter:description content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
11 操作系统上的进程 回顾 定制Linux：
BusyBox: The Swiss Army Knife of embedded Linux
adb shell(toybox)
Linux操作系统启动流程：
CPU Reset Firmware Loader Kernel_start /bin/init 程序执行+系统调用 应用视角的操作系统：
操作系统为所有程序提供API
进程&线程（状态机）管理 fork,execve,exit - 进程的创建、改变和删除 pthread_create,pthread_join,pthread_exit - 线程的创建和退出 存储（地址空间）管理 mmap - 虚拟地址空间管理 文件（数据对象）管理 open,close,read,write - 文件访问管理 mkdir,link,unlink - 目录管理 fork() 理解操作系统是状态机管理者："><meta itemprop=name content="NJU-OS笔记"><meta itemprop=description content="这篇博客流水线的记录一下自己学习NJU-OS的笔记。
1 操作系统概述 本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。
计算机历史 理解操作系统 理解操作系统，就是回答下面三个问题：
操作系统服务谁？ 操作系统服务应用程序，而程序可以理解成状态机。 注：课程涉及多线程Linux应用程序。 站在应用视角，操作系统能为程序提供什么服务？ 操作系统 = （可操作的）对象 + （可调用的）API 注：课程只涉及 POSIX + 部分Linux特性。 站在硬件视角，如何实现操作系统并提供这些服务？ 操作系统 = C程序 注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。 xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。
2 操作系统上的程序 什么是程序 操作系统中的一般程序 课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的tmux笔记。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。
11 操作系统上的进程 回顾 定制Linux：
BusyBox: The Swiss Army Knife of embedded Linux
adb shell(toybox)
Linux操作系统启动流程：
CPU Reset Firmware Loader Kernel_start /bin/init 程序执行+系统调用 应用视角的操作系统：
操作系统为所有程序提供API
进程&线程（状态机）管理 fork,execve,exit - 进程的创建、改变和删除 pthread_create,pthread_join,pthread_exit - 线程的创建和退出 存储（地址空间）管理 mmap - 虚拟地址空间管理 文件（数据对象）管理 open,close,read,write - 文件访问管理 mkdir,link,unlink - 目录管理 fork() 理解操作系统是状态机管理者："><meta itemprop=datePublished content="2023-06-19T21:22:58+08:00"><meta itemprop=dateModified content="2023-06-19T21:22:58+08:00"><meta itemprop=wordCount content="199"><meta itemprop=keywords content></head><body><header><div id=avatar><a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a></div><div id=titletext><h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2></div><div id=title-description><p id=subtitle>May the force be with me.</p><div id=social><nav><ul><li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li><li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>Posts</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>19</span>
<span class=rest>Jun 2023</span></div></div><div class=matter><h1 class=title>NJU-OS笔记</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><p>这篇博客流水线的记录一下自己学习<a href=https://jyywiki.cn/OS/2022/ target=_blank>NJU-OS</a>的笔记。</p><h2 id=1-操作系统概述>1 操作系统概述</h2><blockquote><p>本课程讨论狭义的操作系统，即：对单一计算机硬件系统作出抽象、支撑程序执行的软件系统。</p></blockquote><h3 id=计算机历史>计算机历史</h3><h3 id=理解操作系统>理解操作系统</h3><p>理解操作系统，就是回答下面三个问题：</p><ul><li>操作系统服务谁？<ul><li>操作系统服务应用程序，而程序可以理解成状态机。</li><li>注：课程涉及多线程Linux应用程序。</li></ul></li><li>站在应用视角，操作系统能为程序提供什么服务？<ul><li>操作系统 = （可操作的）对象 + （可调用的）API</li><li>注：课程只涉及 POSIX + 部分Linux特性。</li></ul></li><li>站在硬件视角，如何实现操作系统并提供这些服务？<ul><li>操作系统 = C程序</li><li>注：课程涉及 xv6，并在此基础上实现一个迷你操作系统。</li></ul></li></ul><blockquote><p>xv6 是MIT为操作系统的课程，开发的一个教学目的的操作系统。</p></blockquote><h2 id=2-操作系统上的程序>2 操作系统上的程序</h2><h3 id=什么是程序>什么是程序</h3><h3 id=操作系统中的一般程序>操作系统中的一般程序</h3><blockquote><p>课后作业中，使用tmux实现多窗口管理这一项让我收获挺多的，具体参见我的<a href=/>tmux笔记</a>。此外，还有一些WSL环境，终端个性化配置，Vim快捷键以及gdb调试等等小项目，也非常有意义。</p></blockquote><h2 id=11-操作系统上的进程>11 操作系统上的进程</h2><h3 id=回顾>回顾</h3><p><strong>定制Linux</strong>：</p><p>BusyBox: The Swiss Army Knife of embedded Linux</p><p>adb shell(toybox)</p><p><strong>Linux操作系统启动流程</strong>：</p><ul><li>CPU Reset</li><li>Firmware</li><li>Loader</li><li>Kernel_start</li><li>/bin/init</li><li>程序执行+系统调用</li></ul><p><strong>应用视角的操作系统</strong>：</p><p>操作系统为所有程序提供API</p><ul><li>进程&线程（状态机）管理<ul><li>fork,execve,exit - 进程的创建、改变和删除</li><li>pthread_create,pthread_join,pthread_exit - 线程的创建和退出</li></ul></li><li>存储（地址空间）管理<ul><li>mmap - 虚拟地址空间管理</li></ul></li><li>文件（数据对象）管理<ul><li>open,close,read,write - 文件访问管理</li><li>mkdir,link,unlink - 目录管理</li></ul></li></ul><h3 id=fork>fork()</h3><p><strong>理解操作系统是状态机管理者</strong>：</p><ul><li>操作系统在物理内存中保存多个状态机；</li><li>通过虚拟内存实现，拿一个来执行；</li><li>中断后进入操作系统代码，换一个执行。</li></ul><p><strong>状态机管理之创建状态机</strong>：</p><p>UNIX的答案是fork，即：做一份状态机的完整复制（内存、寄存器现场）。</p><p><strong>理解fork函数</strong>：</p><p><code>pid_t fork(void)</code></p><p>在fork函数返回后，会有两个进程同时运行，其中一个是父进程，另一个是新创建的子进程。</p><p>在子进程创建成功后，它会复制父进程的代码和数据段，并且开始执行从fork函数返回的位置。也就是说，子进程会从fork函数返回的地方开始执行，而不是从程序的起始位置开始执行。</p><p>需要注意的是，在子进程中，fork函数的返回值是0，而在父进程中，fork函数的返回值是新创建的子进程的进程ID。因此，在父进程中可以通过判断fork函数的返回值来区分当前进程是父进程还是子进程。</p><h3 id=execve>execve()</h3><p><strong>状态机管理之替换状态机</strong>：</p><p>UNIX的答案是execve，即：将当前运行的状态机重置成另一个程序的初始状态。</p><p><strong>理解execve函数</strong>：</p><p><code>int execve(const char *pathname, char *const argv[], char *const envp[]);</code></p><ul><li>pathname：指定要执行的程序的路径，可以是绝对路径或者相对路径。如果路径中不包含目录分隔符 /，则会从环境变量 PATH 中查找可执行文件。</li><li>argv：一个以 NULL 结尾的字符串数组，用于指定新程序的命令行参数。第一个元素通常是程序的名称，后面的元素是程序的参数。注意，第一个元素是程序的名称，而非路径名。</li><li>envp：一个以 NULL 结尾的字符串数组，用于指定新程序的环境变量。每个字符串都是一个形如 key=value 的键值对，表示一个环境变量的值。</li></ul><p>execve函数执行成功时，不会返回到调用进程，而是直接将当前进程替换为新程序的进程。如果执行失败，则会返回 -1，并设置相应的错误码。</p><h2 id=12-进程的地址空间>12 进程的地址空间</h2><h2 id=13-系统调用和unix-shell>13 系统调用和UNIX Shell</h2><h3 id=shell>Shell</h3><p><strong>简介</strong>：</p><p>Shell 是一种计算机程序，它将操作系统的服务暴露给人类用户或其他程序。</p><p>一般来说，操作系统的 Shell 使用命令行界面（CLI，Command Line Interface）或图形用户界面（GUI，Graphics User Interface），具体取决于计算机的角色和特定操作。</p><p>Shell Programming Language是一门把用户指令翻译成系统调用的编程语言。</p><p>Shell Scripts 是由 Shell Programming Language 编写的脚本文件，它们通常以 .sh 扩展名结尾，包含一系列的 Shell 命令和脚本语句，用于执行特定的操作和任务。</p><p><strong>功能</strong>：</p><ul><li>重定向: cmd > file &lt; file 2> /dev/null</li><li>顺序结构: cmd1; cmd2, cmd1 && cmd2, cmd1 || cmd2</li><li>管道: cmd1 | cmd2</li><li>预处理: $(), &lt;()</li><li>变量/环境变量、控制流……</li></ul><p><strong>未来展望</strong>：</p><ul><li>fish、zsh等用户友好、易用且美观的命令行界面</li><li><a href=https://tldr.sh/ target=_blank>tldr</a>、<a href=https://github.com/nvbn/thefuck target=_blank>thefuck</a>等自动补全工具</li><li>类似vscode的命令板块（Ctrl-Shift-P）</li><li><a href=https://dl.acm.org/doi/pdf/10.1145/3371111 target=_blank>Executable Formal Semantics for the POSIX Shell</a></li></ul><h3 id=终端和job-control>终端和Job Control</h3><h2 id=14-c标准库的实现>14 C标准库的实现</h2><h2 id=3-多处理器编程>3 多处理器编程</h2><h3 id=并发>并发</h3><p><strong>并发的基本单位——线程</strong>：</p><p>共享内存的多个执行流：</p><ul><li>执行流拥有独立的堆栈/寄存器</li><li>共享全部的内存（指针可以相互引用）</li></ul><p>POSIX Threads</p><p>实现原子性</p><p>实现临界区之间的绝对串行化
程序其他部分依然并行执行</p></div></div></article></div></main><footer>© Copyright <a href=https://github.com/Zhytou target=_blank>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae target=_blank>Vitae</a> theme for <a href=https://gohugo.io target=_blank>Hugo</a></footer><script src=/js/dark-mode.js></script></body></html>
<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<title>GAMES101 | Zhytou</title>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=generator content="Hugo 0.91.2">
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel="shortcut icon" href=/favicon.ico>
<link rel=stylesheet type=text/css media=screen href=/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=/css/main.css>
<link rel=stylesheet type=text/css media=screen href=/css/all.css>
<meta property="og:title" content="GAMES101">
<meta property="og:description" content="Transformation  MVP Triangle   Rasterization  Aliasing MSAA FXAA TAA Visibility/Occlusion   Shading  Illumination Model Lambert’s Cosine Law Phong/Blinn-Phong Model Shading Frequency OpenGL Graphics Pipeline   Texture  Texture Mapping Light Mapping Normal Mapping Displacement Mapping   PBR  Radiometry Optics and Microfacet Model BRDF and BxDF Rendering Equation Cook-Torrance BRDF Diffuse Part Specular Part Disney Principled BRDF Linear Space and Tone Mapping PBR Implementation PBR GI——IBL   Ray Tracing  Collision detection Scene Management   References  Transformation MVP  模型变换（Model Transformation）：模型变换指的是对3D场景中的单个对象或模型进行变换的过程。这种变换包括对对象的顶点进行缩放、旋转和平移，将对象定位和定向到世界坐标系中。 视图/相机变换（View/Camera Transformation）：视图或相机变换涉及将整个场景从世界坐标系转换到相机或视图坐标系的过程。这种变换定义了虚拟相机在场景中的位置和方向。它包括设置相机位置、定义目标点或观察方向以及指定上方向等操作。 投影变换（Projection Transformation）：投影变换是将3D场景的坐标转换为屏幕上的2D坐标的过程。这种变换模拟了3D场景如何投影到2D平面上，考虑到透视和深度提示。常见的投影类型包括透视投影和正交投影。 视口变换(Viewport Transformation)：将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2[0,width]*[0,height], 其中width和height指屏幕分辨率大小。  其中，模型和视图变换通常都放在顶点着色器阶段，而投影变换则由图形流水线自动实现（裁剪/透视剔除）。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhytou.github.io/post/2024-8-1/games101/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2024-08-01T17:06:45+08:00">
<meta property="article:modified_time" content="2024-08-01T17:06:45+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="GAMES101">
<meta name=twitter:description content="Transformation  MVP Triangle   Rasterization  Aliasing MSAA FXAA TAA Visibility/Occlusion   Shading  Illumination Model Lambert’s Cosine Law Phong/Blinn-Phong Model Shading Frequency OpenGL Graphics Pipeline   Texture  Texture Mapping Light Mapping Normal Mapping Displacement Mapping   PBR  Radiometry Optics and Microfacet Model BRDF and BxDF Rendering Equation Cook-Torrance BRDF Diffuse Part Specular Part Disney Principled BRDF Linear Space and Tone Mapping PBR Implementation PBR GI——IBL   Ray Tracing  Collision detection Scene Management   References  Transformation MVP  模型变换（Model Transformation）：模型变换指的是对3D场景中的单个对象或模型进行变换的过程。这种变换包括对对象的顶点进行缩放、旋转和平移，将对象定位和定向到世界坐标系中。 视图/相机变换（View/Camera Transformation）：视图或相机变换涉及将整个场景从世界坐标系转换到相机或视图坐标系的过程。这种变换定义了虚拟相机在场景中的位置和方向。它包括设置相机位置、定义目标点或观察方向以及指定上方向等操作。 投影变换（Projection Transformation）：投影变换是将3D场景的坐标转换为屏幕上的2D坐标的过程。这种变换模拟了3D场景如何投影到2D平面上，考虑到透视和深度提示。常见的投影类型包括透视投影和正交投影。 视口变换(Viewport Transformation)：将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2[0,width]*[0,height], 其中width和height指屏幕分辨率大小。  其中，模型和视图变换通常都放在顶点着色器阶段，而投影变换则由图形流水线自动实现（裁剪/透视剔除）。">
<meta itemprop=name content="GAMES101">
<meta itemprop=description content="Transformation  MVP Triangle   Rasterization  Aliasing MSAA FXAA TAA Visibility/Occlusion   Shading  Illumination Model Lambert’s Cosine Law Phong/Blinn-Phong Model Shading Frequency OpenGL Graphics Pipeline   Texture  Texture Mapping Light Mapping Normal Mapping Displacement Mapping   PBR  Radiometry Optics and Microfacet Model BRDF and BxDF Rendering Equation Cook-Torrance BRDF Diffuse Part Specular Part Disney Principled BRDF Linear Space and Tone Mapping PBR Implementation PBR GI——IBL   Ray Tracing  Collision detection Scene Management   References  Transformation MVP  模型变换（Model Transformation）：模型变换指的是对3D场景中的单个对象或模型进行变换的过程。这种变换包括对对象的顶点进行缩放、旋转和平移，将对象定位和定向到世界坐标系中。 视图/相机变换（View/Camera Transformation）：视图或相机变换涉及将整个场景从世界坐标系转换到相机或视图坐标系的过程。这种变换定义了虚拟相机在场景中的位置和方向。它包括设置相机位置、定义目标点或观察方向以及指定上方向等操作。 投影变换（Projection Transformation）：投影变换是将3D场景的坐标转换为屏幕上的2D坐标的过程。这种变换模拟了3D场景如何投影到2D平面上，考虑到透视和深度提示。常见的投影类型包括透视投影和正交投影。 视口变换(Viewport Transformation)：将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2[0,width]*[0,height], 其中width和height指屏幕分辨率大小。  其中，模型和视图变换通常都放在顶点着色器阶段，而投影变换则由图形流水线自动实现（裁剪/透视剔除）。"><meta itemprop=datePublished content="2024-08-01T17:06:45+08:00">
<meta itemprop=dateModified content="2024-08-01T17:06:45+08:00">
<meta itemprop=wordCount content="745">
<meta itemprop=keywords content>
</head>
<body>
<header>
<div id=avatar>
<a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a>
</div>
<div id=titletext>
<h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2>
</div>
<div id=title-description>
<p id=subtitle>May the force be with me.</p>
<div id=social>
<nav><ul>
<li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id=mainmenu>
<nav>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/post>Posts</a></li>
<li><a href=/about>About</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class=post>
<article>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>01</span>
<span class=rest>Aug 2024</span>
</div>
</div>
<div class=matter>
<h1 class=title>GAMES101</h1>
<p class=post-meta>
<span class=post-meta>
</span>
</p>
</div>
</div>
<div class=markdown>
<ul>
<li><a href=#transformation>Transformation</a>
<ul>
<li><a href=#mvp>MVP</a></li>
<li><a href=#triangle>Triangle</a></li>
</ul>
</li>
<li><a href=#rasterization>Rasterization</a>
<ul>
<li><a href=#aliasing>Aliasing</a></li>
<li><a href=#msaa>MSAA</a></li>
<li><a href=#fxaa>FXAA</a></li>
<li><a href=#taa>TAA</a></li>
<li><a href=#visibilityocclusion>Visibility/Occlusion</a></li>
</ul>
</li>
<li><a href=#shading>Shading</a>
<ul>
<li><a href=#illumination-model>Illumination Model</a></li>
<li><a href=#lamberts-cosine-law>Lambert’s Cosine Law</a></li>
<li><a href=#phongblinn-phong-model>Phong/Blinn-Phong Model</a></li>
<li><a href=#shading-frequency>Shading Frequency</a></li>
<li><a href=#opengl-graphics-pipeline>OpenGL Graphics Pipeline</a></li>
</ul>
</li>
<li><a href=#texture>Texture</a>
<ul>
<li><a href=#texture-mapping>Texture Mapping</a></li>
<li><a href=#light-mapping>Light Mapping</a></li>
<li><a href=#normal-mapping>Normal Mapping</a></li>
<li><a href=#displacement-mapping>Displacement Mapping</a></li>
</ul>
</li>
<li><a href=#pbr>PBR</a>
<ul>
<li><a href=#radiometry>Radiometry</a></li>
<li><a href=#optics-and-microfacet-model>Optics and Microfacet Model</a></li>
<li><a href=#brdf-and-bxdf>BRDF and BxDF</a></li>
<li><a href=#rendering-equation>Rendering Equation</a></li>
<li><a href=#cook-torrance-brdf>Cook-Torrance BRDF</a></li>
<li><a href=#diffuse-part>Diffuse Part</a></li>
<li><a href=#specular-part>Specular Part</a></li>
<li><a href=#disney-principled-brdf>Disney Principled BRDF</a></li>
<li><a href=#linear-space-and-tone-mapping>Linear Space and Tone Mapping</a></li>
<li><a href=#pbr-implementation>PBR Implementation</a></li>
<li><a href=#pbr-giibl>PBR GI——IBL</a></li>
</ul>
</li>
<li><a href=#ray-tracing>Ray Tracing</a>
<ul>
<li><a href=#collision-detection>Collision detection</a></li>
<li><a href=#scene-management>Scene Management</a></li>
</ul>
</li>
<li><a href=#references>References</a></li>
</ul>
<h2 id=transformation>Transformation</h2>
<h3 id=mvp>MVP</h3>
<ul>
<li>模型变换（Model Transformation）：模型变换指的是对3D场景中的单个对象或模型进行变换的过程。这种变换包括对对象的顶点进行缩放、旋转和平移，将对象定位和定向到世界坐标系中。</li>
<li>视图/相机变换（View/Camera Transformation）：视图或相机变换涉及将整个场景从世界坐标系转换到相机或视图坐标系的过程。这种变换定义了虚拟相机在场景中的位置和方向。它包括设置相机位置、定义目标点或观察方向以及指定上方向等操作。</li>
<li>投影变换（Projection Transformation）：投影变换是将3D场景的坐标转换为屏幕上的2D坐标的过程。这种变换模拟了3D场景如何投影到2D平面上，考虑到透视和深度提示。常见的投影类型包括透视投影和正交投影。</li>
<li>视口变换(Viewport Transformation)：将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2[0,width]*[0,height], 其中width和height指屏幕分辨率大小。</li>
</ul>
<p>其中，模型和视图变换通常都放在顶点着色器阶段，而投影变换则由图形流水线自动实现（裁剪/透视剔除）。</p>
<p><strong>齐次坐标</strong>：</p>
<p>为什么三维的坐标会使用四维矩阵进行平移或旋转的计算呢？即：为什么原本n维的向量要用一个n+1维向量来表示？</p>
<blockquote>
<p><a href=https://gamedev.stackexchange.com/questions/72044/why-do-we-use-4x4-matrices-to-transform-things-in-3d target=_blank>Why do we use 4x4 matrices to transform things in 3D?</a></p>
</blockquote>
<p>其实，这种表达方式被称为齐次坐标(Homogeneous Coordinates)，即原本n维的向量用一个n+1维向量来表示。其核心目的是为了更优雅的表示平移的距离，比如：</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/homogeneous_coordinates.png alt=平移>
</figure></p>
<p><strong>旋转矩阵推导</strong>：</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-9-12/2d_orientation.png alt=2d旋转>
</figure></p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-9-12/3d_orientation.png alt=3d旋转>
</figure></p>
<h3 id=triangle>Triangle</h3>
<p><strong>判断点在三角形内部</strong>：</p>
<p>设三角形顶点为P1、P2和P3，待检测点为Q，则Q在三角形P1P2P3内部的条件为，下面三个叉乘符号相同：</p>
<ul>
<li>P0P1×P0Q</li>
<li>P1P2×P1Q</li>
<li>P2P0×P2Q</li>
</ul>
<h2 id=rasterization>Rasterization</h2>
<p>光栅化（Rasterization）就是把几何图元转化成片元（像素）的过程。其中，光栅（Raster）一词来自德语，表示栅格。因此，光栅化的通俗理解就是在栅格显示设备上绘制图像。</p>
<p><strong>基本图元</strong>：</p>
<p>一般来说，光栅化的输入都是三角形图元。而采用三角形作为基本图元的原因包括：</p>
<ul>
<li>三角形是最基本的多边形。</li>
<li>三角形具有平面性。</li>
<li>三角形可以明确定义内部和外部，且可以通过向量叉积来判断。</li>
<li>任意多边形可以拆分成多个三角形。</li>
</ul>
<p><strong>采样绘制</strong>：</p>
<p>采样绘制就是将三角形图元分割为屏幕上的像素，确定哪些像素需要在稍后上色。具体来说，就是根据像素中心是否位于图元内部这一点来判断的，如下图所示。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/rasterization.png alt=采样绘制>
</figure></p>
<h3 id=aliasing>Aliasing</h3>
<p><strong>走样原理</strong>：</p>
<p>站在信号与系统的角度来看采样，在时域上是原信号和周期冲激信号的一个乘积。那么根据傅里叶变化，在频域上就是原信号和周期冲激信号的卷积，如下图所示。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/aliasing_reason.png alt=傅里叶变换>
</figure></p>
<p>那么当原信号频谱过宽或采样用的冲激信号频率太低，就容易发生信号重叠，由此造成走样。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/fourier_transform.png alt=走样原理>
</figure></p>
<p><strong>抗锯齿/抗走样原理</strong>：</p>
<p>根据走样原理，由此可得出抗锯齿原理其实就是尽可能避免信号高频部分发生重叠。一般来说，常见的抗锯齿方法有两种，分别是：</p>
<ul>
<li><strong>模糊+采样（Blur Anti-aliasing）</strong>：即先使用一个平滑滤波器去滤除部分高频信号，再进行采样。</li>
<li><strong>超采样抗锯齿（Supersampling Anti-aliasing，SSAA）</strong>：即使用一个更高的采样频率来避免潜在的重叠。</li>
</ul>
<h3 id=msaa>MSAA</h3>
<p>多重采样抗锯齿(Multisample Anti-aliasing, MSAA)是对SSAA的改进。它借鉴了超采样的思想，但同时又避免了超采样的性能消耗。因为在前面提到的SSAA中，每个子采样点都要进行单独的着色，这样在片元着色器比较复杂的情况下其实是非常浪费性能的。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/msaa.png alt=MSAA>
</figure></p>
<p>相比之下，MSAA虽然增加了每个像素点的子采样点数量，但对于每个像素来说都只需要运行一次片元着色器。因为，它使用采样点的覆盖率来计算该像素的颜色。同样的，深度和模板测试也受多个采样点的影响。</p>
<p>不过，MSAA的问题在于和延迟渲染不太兼容，因为延迟渲染时，场景光栅化之后都被输入到GBuffer上了，并不会直接着色。</p>
<h3 id=fxaa>FXAA</h3>
<p>快速近似抗锯齿(Fast Approximate Anti-Aliasing, FXAA)是一种廉价但效果不错的抗锯齿算法。不同于SSAA和MSAA，FXAA直接检测边缘，然后使用平滑滤波器去模糊这些边缘，从而达到抗锯齿效果。</p>
<h3 id=taa>TAA</h3>
<p>时域抗锯齿(Temporal Anti-Aliasing, TAA)是一种基于时域的抗锯齿技术，旨在进一步减少图形中的锯齿现象。它利用前一帧和当前帧之间的像素信息进行抗锯齿处理，通过时间上的积累和混合来减少锯齿，并提高图像的质量和稳定性。</p>
<h3 id=visibilityocclusion>Visibility/Occlusion</h3>
<p><strong>画家算法</strong>：受画家作画启发，根据片元位置从后往前依次着色，计算framebuffer值。此时，后着色的片元颜色会覆盖旧的framebuffer值。对于首位交替重叠的特殊情况难以处理。</p>
<p><strong>Z-Buffer算法</strong>：额外添加一个z-buffer记录当前像素的最小z值。</p>
<h2 id=shading>Shading</h2>
<blockquote>
<p>In computer graphics, shading is the process of applying a material to an object.</p>
</blockquote>
<p>着色（Shading）是计算机图形学中用于模拟光照效果的过程，通过对物体表面的光照属性进行计算，为物体赋予逼真的外观。</p>
<h3 id=illumination-model>Illumination Model</h3>
<p>光照模型（Illumination Model），有时也被称为着色模型，是用于计算任意给定位置的光线强度的数学模型。根据是否考虑光源和场景中物体相互作用产生的二次光照，可将光照模型分为局部光照模型和全局光照模型。其中，常见的局部光照模型包括：Lambert漫反射模型、Phong光照模型、Blinn-Phong光照模型和Cook-Torrance模型等。而全局光照模型则包括：光线追踪、路径追踪、辐射度算法和光子映射等。</p>
<p>具体的，局部光照大都基于经验（当然也有Cook-Torrance模型这种PBR的特例），而全局光照模型是基于光学物理原理的。后者的计算依赖于光能在现实世界中的传播情况，会考虑光线与整个场景中各物体表面及物体表面间的相互影响，包括多次反射、透射、散射等。正是这个原因，全局光照模型通常需要相当大的计算量，但同时也能取得非常逼真的真实效果。此外，局部光照模型往往无法直接生成阴影，而全局光照模型则可以。</p>
<h3 id=lamberts-cosine-law>Lambert&rsquo;s Cosine Law</h3>
<p>Lambertian模型用于描述粗糙材料的表面。它是一种理想模型，只考虑漫反射，即完全漫反射。这些反射光，在不同角度的辐射强度会依余弦公式变化，角度越大强度越弱。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/lambert_cosine_law.png alt=Lambert余弦定理>
</figure></p>
<h3 id=phongblinn-phong-model>Phong/Blinn-Phong Model</h3>
<p>在Phong/Blinn-Phong光照模型中，它将任意位置发出的光线分成漫反射(Diffuse/Lambertian)、镜面(Specular)和环境(Ambient)三个分量。</p>
<p>假设光源强度为I，带计算位置和光源距离为r，则该位置入射光线强度$L_{in}=I/r^2$。此时，出射光线强度为三个分量之和，即$L_{out}=L_d+L_s+L_a$。</p>
<p><strong>Diffuse/Lambertian</strong>：</p>
<p>其中，漫反射强度由入射光线强度$L_{in}$、材料漫反射系数$K_d$、法向量方向$\vec{n}$和反射光线方向$\vec{out}$一起决定，即$L_d=k_d*L_{in}<em>max(0, \vec{n}</em>\vec{out})$。</p>
<p><strong>Specular</strong>：</p>
<p>类似的，高光强度（或镜面反射强度）也由入射光线强度$L_{in}$、材料镜面反射系数$K_s$、材料的高光反光度shininess、法向量方向$\vec{n}$和反射光线方向$\vec{out}$一起决定。其中，高光反光度描述的是材料对镜面反光散射的能力。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响：</p>
<p><figure>
<img src=https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular_shininess.png alt=高光反光度>
</figure></p>
<p>尽管Phong模型和Blinn-Phong模型计算这一分量所需参数类似，但计算方法却不同，这也是二者的区别。其中，前者的计算方式如下$L_s=k_s<em>L_{in}<em>pow(max(0, \vec{in}</em>\vec{out}), shininess)$。而后者则是引入了一个名为$\vec{h}$的半程向量来改进前者计算中出现的高光不连续问题，其示意图如下。具体来说，$\vec{h}=\frac{\vec{in}+\vec{out}}{||\vec{in}+\vec{out}||}$，而高光强度$L_s=k_s</em>L_{in}<em>pow(max(0, \vec{n}</em>\vec{h}), shininess)$。</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/half_vector.png alt=半程向量>
</figure></p>
<p><strong>Ambient</strong>：</p>
<p>至于环境光的计算方式就非常简单了。它表示为光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色。</p>
<h3 id=shading-frequency>Shading Frequency</h3>
<ul>
<li>面着色（Flat Shading）：一个平面计算一次，计算结果应用给该平面的每个点</li>
<li>顶点着色（Vertex Shading/Grouraud Shading）：每个顶点都计算一次，然后面内点做插值</li>
<li>像素着色（Pixel Shading/Phong Shading）：算出每个顶点法线，对法线进行插值得到面内每个像素的法线，再做着色计算</li>
</ul>
<h3 id=opengl-graphics-pipeline>OpenGL Graphics Pipeline</h3>
<ul>
<li>应用阶段：输入一堆三维空间中的点。</li>
<li>几何阶段：依次进行MVP变换，并进行视锥体剔除、裁剪和屏幕映射，得到三角形顶点对应屏幕像素位置。</li>
<li>光栅化：通过顶点插值，得到被三角形覆盖的所有像素位置。</li>
<li>片元处理：进行着色计算，并依次进行透明度、模板和深度测试，最终得到显示在屏幕上的图像。</li>
</ul>
<p><figure>
<img src=https://pica.zhimg.com/80/v2-85a9e77245f43d4bab56f2052c3d81f0_720w.webp alt=渲染管线>
</figure></p>
<p><strong>OpenGL中的坐标变换</strong>：</p>
<p>几何阶段中的顶点处理应该是渲染管线中较为复杂的部分，下面详细总结其流程：</p>
<ul>
<li>World Coordinates:输入坐标。</li>
<li>Eye/Camera Coordinates:将原点通过平移和旋转的方式移动到相机处，得到相机坐标系下的坐标。</li>
<li>Clip Space:将数据投影至距离相机n处的平面，得到裁剪空间下的坐标。其坐标转换公式如下所示。其中，P为投影矩阵，far和near分别为远和近裁剪面的距离，ratio为宽高比，$\theta$为视角。</li>
</ul>
<p>$$
P(x,y,z,1)^{T}=(\frac{1}{ratio \cdot tan\frac{\theta}{2}}x, \frac{1}{tan\frac{\theta}{2}}y, \frac{z-near}{far-near}, -z)^{T}
$$</p>
<ul>
<li>Normalized Device Coordinates：此时，除去w，便可得到归一化坐标。随后，裁剪掉大于1或小于-1的x，y坐标（忽略z，因为投影到固定平面上了）。</li>
</ul>
<p>其中，视锥体剔除和裁剪的区别如下：</p>
<p><figure>
<img src=https://pica.zhimg.com/80/v2-109bce4132140a2490f0de65666519b2_720w.webp alt=视锥体剔除和裁剪的区别>
</figure></p>
<p><strong>各种测试</strong>：</p>
<p>在完成片元着色计算后，紧接着会进行各种测试和混合操作，最终得到呈现在屏幕上的图片。这些测试按从前到后的顺序为：</p>
<ul>
<li>模板测试</li>
<li>透明度测试：它其实和半透明渲染没什么关系，只是用到了alpha做判断，当alpha值小于某个阈值时丢弃该片元。</li>
<li>深度测试：它用于比较片元的深度值与深度缓冲区中对应位置的深度值，并决定是否绘制该片元。深度测试可以确保物体的遮挡关系正确，避免后面的物体遮挡前面的物体。</li>
</ul>
<p><strong>混合</strong>：</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/color_blend.png alt=颜色混合>
</figure></p>
<p><strong>背面剔除</strong>：</p>
<p>面剔除(Face culling)通过检查三角形的法线方向，剔除背面朝向观察者的三角形，从而减小开销。</p>
<p>在OpenGL中，可以先使用函数glEnable(GL_CULL_FACE)开启面剔除功能。接着，使用函数glCullFace函数来实现。它需要传入一个参数，用于指定剔除面类，其可能的选项包括：</p>
<ul>
<li>GL_BACK：只剔除背面。</li>
<li>GL_FRONT：只剔除正面。</li>
<li>GL_FRONT_AND_BACK：剔除背面和正面。</li>
</ul>
<p><strong>延迟渲染</strong>：</p>
<p><strong>Early-Z测试</strong>：</p>
<p>一般来说，深度测试都发生在片元着色之后。为了减少进入片元着色的像素数量，一种提前进行深度测试的Early-Z技术被提出了。它位于光栅化阶段之后，像素处理阶段之前。</p>
<p>不过，Early-Z会带来透明测试的冲突，例如某个片元A虽然遮挡了另一个片元B，但A却是透明的，GPU应当渲染的是片元B，这就产生了矛盾。</p>
<h2 id=texture>Texture</h2>
<h3 id=texture-mapping>Texture Mapping</h3>
<p>纹理贴图（Texture Mapping）是计算机图形学中将二维图像映射到三维物体表面的技术。通过定义纹理坐标（UV 坐标，范围通常为 [0,1]），将图像的每个像素对应到物体表面的顶点，最终在渲染时填充物体表面的颜色。</p>
<p><strong>纹理环绕</strong>：</p>
<ul>
<li>GL_REPEAT：重复纹理（默认），坐标超出部分循环平铺。</li>
<li>GL_MIRRORED_REPEAT：镜像重复，超出部分镜像翻转后平铺。</li>
<li>GL_CLAMP_TO_EDGE：边缘拉伸，超出部分拉伸到边缘。</li>
</ul>
<p><strong>纹理过滤</strong>：</p>
<p>当纹理像素（Texel）与屏幕像素（Pixel）大小不匹配时，通过插值算法优化显示效果，分为放大过滤（纹理太小）和缩小过滤（纹理太大）。</p>
<p><strong>Mipmap</strong>：</p>
<p>多级渐远纹理（Mipmap）是一种在计算机图形学中用于优化纹理渲染的技术，由一系列不同分辨率的纹理图像组成，这些图像是原始纹理的逐级降采样版本。具体来说，它的功能包括：</p>
<ul>
<li>提高渲染性能：在渲染场景时，远处的物体通常不需要使用高分辨率的纹理，因为它们在屏幕上只占据很少的像素。使用 Mipmap 可以根据物体与相机的距离选择合适分辨率的纹理进行渲染，减少纹理过滤时所需的计算量，从而提高渲染速度。</li>
<li>减少纹理闪烁：当物体远离相机时，如果直接使用高分辨率纹理，由于纹理采样的不连续性，会导致纹理出现闪烁现象。Mipmap 通过提供不同分辨率的纹理，使得纹理在不同距离下的过渡更加平滑，减少了闪烁问题。</li>
</ul>
<p>Mipmap 由多个层级（Level）组成，每个层级的纹理分辨率是上一层级的一半。层级 0 是原始纹理，层级 1 的纹理分辨率是层级 0 的一半，层级 2 的纹理分辨率是层级 1 的一半，依此类推。</p>
<p>在实际开发中，有时并不需要直接指定使用哪个 Mipmap 层级，而是通过纹理过滤器（Texture Filter）来自动选择合适的 Mipmap 层级。具体而言，由于GPU一次最少会渲染四个相邻的片元，它可以同时获得这四个片元的uv坐标，从而根据uv坐标的变换情况来选择合适的Mipmap层级。比如，邻近的片元uv坐标中u的差值为0.05，而此时层级为1的纹理分辨率为1024×1024，那么这两个片元选取的纹理像素点位置将相差0.05*1024=51.2，这显然跨度过大，很可能会造成锯齿效应，因此需要选择层级更高的纹理。</p>
<h3 id=light-mapping>Light Mapping</h3>
<h3 id=normal-mapping>Normal Mapping</h3>
<p>除了可以保存物体的颜色信息，纹理还可以用于保存物体的法线信息，也就是法线贴图（Normal Mapping）。它的主要作用就是通过uv坐标来获取法线信息，从而在片元着色器中计算出更加逼真的光照效果。</p>
<h3 id=displacement-mapping>Displacement Mapping</h3>
<p>视觉贴图是一种用于模拟表面几何细节的贴图，通过改变顶点的位置来实现凹凸效果。</p>
<h2 id=pbr>PBR</h2>
<blockquote>
<p><a href=https://github.com/QianMo/PBR-White-Paper/tree/master target=_blank>PBR 白皮书</a></p>
</blockquote>
<p>基于物理的渲染（Physicallly Based Rendering, PBR）是计算机图形学中一种主流的着色方法。相比于，传统的经验模型，如Phong式光照模型，PBR方法基于物理学原理和光学特性，更加真实和准确。具体来说，PBR理论包括：</p>
<ul>
<li>基于物理的材质（Material）；</li>
<li>基于物理的光照（Lighting）；</li>
<li>基于物理适配的摄像机（Camera）。</li>
</ul>
<p>而该理论的三大基础则分别是辐射度量学、微平面模型和反射方程。其中，前两者的出现基本上只是为了证明：PBR里的数学公式是符合物理的；而后者才是PBR中的核心。换句话说说，反射方程的推导、简化和应用构成了PBR理论。</p>
<p>最后，基于物理的渲染相比传统方法有以下优势：</p>
<ul>
<li>直观参数（最重要的一点）：PBR使用的参数（如粗糙度、金属度等）与实际物理属性紧密相关，这使得艺术家和开发者能够更直观地理解和调整材质参数以获得预期的视觉效果。</li>
<li>一致的材质表现：PBR模型提供了一种标准化的方法来表示材质属性，这意味着同样的材质设置在不同的光照条件下能保持一致的外观。这种一致性对于跨平台开发和维护大型项目尤其重要。</li>
<li>逼真的视觉效果：由于PBR基于真实的物理光照模型，它能够更好地模拟光与材质的交互，提供更逼真的阴影、高光和反射效果。这种逼真效果能够显著提升视觉细节和沉浸感。</li>
</ul>
<h3 id=radiometry>Radiometry</h3>
<p>辐射度量学（Radiometry）是究各种电磁辐射强弱的学科。它定义了一系列物理变量，用来从不同角度描述电磁辐射强度，包括：</p>
<ul>
<li>辐射能（Radiant Energy）指电磁波中电场能量和磁场能量的总和，也叫电磁波的能量，常用符号Q表示。</li>
<li>辐射通量/功率（Radiant Flux/Power）指单位时间内产生的、反射的、接收的能量，常用符号$\Phi$表示。</li>
<li>辐射强度（Radiant Intensity）指单位立体角上，产生的、反射的、接收的辐射通量，常用符号I表示。</li>
<li>辐照度（Irradiance）指单位投影面积上接收到的辐射通量，常用符号E表示。</li>
<li>辐射率（Radiance）指单位投影面积收到/发出的单位立体角上的辐射通量，常用符号L表示。</li>
</ul>
<p>其中，和计算机图形学相关的两个物理量其实是辐照度（Irradiance）和辐射率（Radiance）。它们的关系如下：</p>
<p><figure>
<img src=https://pic3.zhimg.com/80/v2-7cddd5ba8c0e546af7245a60982cfcaa_1440w.webp alt=Irradiance和Radiance的关系>
</figure></p>
<h3 id=optics-and-microfacet-model>Optics and Microfacet Model</h3>
<p><strong>微平面模型</strong>：</p>
<p>微表面模型是计算机图形学中用于模拟真实表面的微观结构的一种技术。它将现实世界中任意材料视作多个微小凹凸结构组成，并使用统计学原理去描述微观结构的几何形状、法线分布和表面粗糙度等参数从而计算光线的反射和折射。</p>
<p>为了更好的理解微平面模型，下面将介绍一些光学基础知识。</p>
<p><strong>折射和折射率</strong>：</p>
<p>而光在传播到两种不同介质交界处时，原始光波和新的光波的相速度（Phase Velocity）的比率定义了介质的光学性质，就是折射率（Index Of Refraction，IOR），由字母n表示。</p>
<p>除了代表光的相速度的实部n之外，还用希腊字母κ（kappa）表示介质将光能转为为其他形式能量的吸收性。n和κ通常都随波长而变化，两者组合成复数n +iκ，称为复折射率（complex index of refraction）。</p>
<p>也就是说，折射率IOR是一个复数（complex number），其分为实部和虚部两部分：</p>
<ul>
<li>折射率的实部（real part）度量了物质如何影响光速，即相对于光在真空中传播速度减慢的度量。</li>
<li>折射率的虚部（imaginary part）确定了光在传播时是否被吸收，转换成其他形式的能量，通常是热能。非吸收性介质虚部为零。</li>
</ul>
<p><strong>光与平面交互</strong>：</p>
<p><figure>
<img src=https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%202/media/db572e0923acd8d22e67a4e1875fb206.png alt=漫反射>
</figure></p>
<p>在了解了折射和折射率之后，我们可以进一步总结得出光与平面交互方法，包括：</p>
<ul>
<li>反射（Reflection）。光线在两种介质交界处的直接反射即镜面反射（Specular）。金属的镜面反射颜色为三通道的彩色，而非金属的镜面反射颜色为单通道的单色。</li>
<li>折射（Refraction）。 从表面折射入介质的光，会发生吸收和散射，而介质的整体外观由其散射和吸收特性的组合决定，其中：
<ul>
<li>散射（Scattering）。 折射率的快速变化引起散射，光的方向会改变（分裂成多个方向），但是光的总量或光谱分布不会改变。散射最终被视作的类型与观察尺度有关：
<ul>
<li>次表面散射（Subsurface Scattering）。观察像素小于散射距离，散射被视作次表面散射。</li>
<li>漫反射（Diffuse）。观察像素大于散射距离，散射被视作漫反射。</li>
<li>透射（Transmission）。入射光经过折射穿过物体后的出射现象。透射为次表面散射的特例。</li>
</ul>
</li>
<li>吸收（Absorption）。 具有复折射率的物质区域会引起吸收，具体原理是光波频率与该材质原子中的电子振动的频率相匹配。复折射率（complex number）的虚部（imaginary part）确定了光在传播时是否被吸收（转换成其他形式的能量）。发生吸收的介质的光量会随传播的距离而减小（如果吸收优先发生于某些波长，则可能也会改变光的颜色），而光的方向不会因为吸收而改变。任何颜色色调通常都是由吸收的波长相关性引起的。</li>
</ul>
</li>
</ul>
<p>因此，从宏观上看，光在介质表面扣除吸收部分，即剩下：（镜面）反射、漫反射和透射三部分。</p>
<p><strong>菲涅尔效应和方程</strong>：</p>
<h3 id=brdf-and-bxdf>BRDF and BxDF</h3>
<p>BRDF（Bidirectional Reflectance Distribution Function），译作双向反射分布函数，是一个用来描述物体表面如何反射光线的方程。简单来说，它就是微表面模型的数学表达。</p>
<p>具体的，BRDF表示了当给定一条入射光的时候，某一条特定的出射光线的性质是怎么样的。它的精确定义是出射光辐射率（Radiance）的微分和入射光辐照度（Irradiance）的微分之比，即$f(l,v)=\frac{dL_o(v)}{dE(l)}$。其中，v和l分别为出射和入射光线方向。</p>
<p>其实，采用ωi和ωo作为输入参数的Blinn-Phong光照模型也可以被当作是一个BRDF。不过由于Blinn-Phong模型并没有遵循能量守恒定律，因此它不被认为是基于物理的渲染。至于，目前广泛用于基于物理渲染和实时渲染的BRDF模型则是一种被称为Cook-Torrance的BRDF模型。我们将在后两节详细介绍它。</p>
<p>除了BRDF之外，图形学中还有一些其他的双向分布函数，比如BRDF、BTDF、BSDF、BSSRDF等，这些一起被称作BxDF。</p>
<p><figure>
<img src=https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%201/media/8c60f94b8b6f430fc5dcb41068770454.png alt=BxDF>
</figure></p>
<p>在上述这些BxDF中，BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。</p>
<h3 id=rendering-equation>Rendering Equation</h3>
<p>渲染方程是一个描述光能在场景中流转的方程，它基于能量守恒定律，在理论上给出了一个完美的光能求解结果。在一个特定的位置和方向，出射光Lo是发射光Le与反射光之和。而反射光本身则是各个方向的入射光Li之和乘以表面反射率及入射角。</p>
<p><figure>
<img src=https://pic2.zhimg.com/80/v2-6494cee4b32f7f654c724b2efb728285_1440w.webp alt=渲染方程>
</figure></p>
<p>其中，积分中的$f_r(x, \vec{w'}, \vec{w})$正是BRDF，即出射光辐射率的微分和入射光辐照度的微分之比。</p>
<h3 id=cook-torrance-brdf>Cook-Torrance BRDF</h3>
<blockquote>
<p><a href=https://learnopengl-cn.github.io/07%20PBR/01%20Theory/#brdf target=_blank>learnopengl中关于Cook-Torrance BRDF的介绍</a></p>
</blockquote>
<p>Cook-Torrance BRDF是一种目前最流行一种BRDF反射模型，它包含漫反射和镜面反射两个部分：$f_r=k_df_{lambert}+k_sf_{cook-torrance}$。其中，$f_{lambert}=\frac\rho\pi$，而$f_{cook-torrance}=\frac{DFG}{4(\vec{w_o}<em>\vec{n})(\vec{w_i}</em>\vec{n})}$。</p>
<p>此外，上述表达式其实只考虑直接光，即它是一个局部光照模型。若在有限光源的情况下，计算Cook-Torrance BRDF的间接光/环境光。其方法和传统模型类似，可通过一个名为环境光遮蔽贴图（Ambient Occlusion, AO）的方式获取每个位置的环境光强度，比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GLSL data-lang=GLSL><span style=color:#888>// albedo就是片元位置的baseColor</span>
<span style=color:#080;font-weight:700>vec3</span> ambient <span style=color:#333>=</span> <span style=color:#080;font-weight:700>vec3</span>(<span style=color:#60e;font-weight:700>0.03</span>) <span style=color:#333>*</span> albedo <span style=color:#333>*</span> ao;
</code></pre></div><p>至于，使用IBL技术表示的全局光照则需要使用更复杂的手段解决，比如预计算PRT等。</p>
<h3 id=diffuse-part>Diffuse Part</h3>
<p>Cook-Torrance BRDF中，漫反射系数$f_{lambert}=\frac\rho\pi$的推导基于一个前提：入射光是均匀且遍布整个半球方向。那么出射光则可表示为：</p>
<p>$$
\begin{align}
L_o(w_o) &= \int_{H^2}{f_rL_i(w_i)cos\theta}dw_i\
&= f_rL_i\int_{H^2}{cos\theta}dw_i\
&= f_rL_i\pi\
f_r &= \frac\rho\pi
\end{align}
$$</p>
<p>其中，$\rho$表示的是发生反射位置的颜色。</p>
<h3 id=specular-part>Specular Part</h3>
<p>Cook-Torrance BRDF的镜面反射部分包含法线分布函数（Normal Distribution Function)、菲涅尔方程（Fresnel Equation）、几何函数（Geometry Function）以及用于矫正的分母 。</p>
<p>其中，分母作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正，有两点需要注意：</p>
<ul>
<li>对于分母中的点积，仅仅避免负值是不够的 - 也必须避免零值。通常通过在常规的clamp或绝对值操作之后添加非常小的正值来完成。</li>
<li>Microfacet Cook-Torrance BRDF是实践中使用最广泛的模型，实际上也是人们可以想到的最简单的微平面模型。它仅对几何光学系统中的单层微表面上的单个散射进行建模，没有考虑多次散射，分层材质，以及衍射。Microfacet模型，实际上还有很长的路要走。</li>
</ul>
<p><strong>菲涅尔项</strong>：</p>
<p>其中，菲涅尔方程描述的是被反射的光线对比光线被折射的部分所占的比率，这个比率会随着观察角度变化而变化。比如，当我们站在湖边低头看脚下的湖水，会发现水是透明的，反射不会特别强烈；而如果我们看远处的湖面时，会发现水并不透明，而且反射非常强烈。</p>
<p>目前，菲涅尔项一般都采用Schlick近似。因为计算成本低廉，而且精度足。</p>
<p><strong>法线分布函数</strong>：</p>
<p>法线分布函数用于描述给定法线$\vec{n}$、半程向量$\vec{h}$和粗糙度$\alpha$时，法线方向和半程向量方向一致的比例。它满足一些列基本性质，包括：</p>
<ul>
<li>微平面法线密度始终为非负值；</li>
<li>微表面的总面积始终不小于宏观表面总面积；</li>
<li>任何方向上微观表面投影面积始终与宏观表面投影面积相同；</li>
<li>若观察方向为法线方向，则其积分可以归一化。</li>
</ul>
<p>一个最常见的法线分布函数其实就是Blinn-Phong中关于镜面反射引入的shiness参数，其具体表达如下：$NDF(\vec{n}, \vec{h}, shiness)=pow(max(0, \vec{n}*\vec{h}), shininess)$。当粗糙度越小（或反光度越大），镜面反射光线越集中，物体表面越有光泽；反之，镜面反射越散射，物体表面越缺乏光泽。</p>
<p><figure>
<img src=https://learnopengl-cn.github.io/img/07/01/ndf.png alt=法线分布函数>
</figure></p>
<p>除此之外，还有比较经典的CGX法线分布函数$NDF(\vec{n}, \vec{h}, \alpha)=\frac{\alpha^2}{\pi((\vec{n}*\vec{h})^2(\alpha^2-1)+1)^2}$。将它在GLSL实现可得：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GLSL data-lang=GLSL><span style=color:#080;font-weight:700>float</span> D_GGX_TR(<span style=color:#080;font-weight:700>vec3</span> N, <span style=color:#080;font-weight:700>vec3</span> H, <span style=color:#080;font-weight:700>float</span> a)
{
  <span style=color:#080;font-weight:700>float</span> a2     <span style=color:#333>=</span> a<span style=color:#333>*</span>a;
  <span style=color:#080;font-weight:700>float</span> NdotH  <span style=color:#333>=</span> max(dot(N, H), <span style=color:#60e;font-weight:700>0.0</span>);
  <span style=color:#080;font-weight:700>float</span> NdotH2 <span style=color:#333>=</span> NdotH<span style=color:#333>*</span>NdotH;

  <span style=color:#080;font-weight:700>float</span> nom    <span style=color:#333>=</span> a2;
  <span style=color:#080;font-weight:700>float</span> denom  <span style=color:#333>=</span> (NdotH2 <span style=color:#333>*</span> (a2 <span style=color:#333>-</span> <span style=color:#60e;font-weight:700>1.0</span>) <span style=color:#333>+</span> <span style=color:#60e;font-weight:700>1.0</span>);
  denom        <span style=color:#333>=</span> PI <span style=color:#333>*</span> denom <span style=color:#333>*</span> denom;

  <span style=color:#080;font-weight:700>return</span> nom <span style=color:#333>/</span> denom;
}
</code></pre></div><p>注意：NDF其实和传统的Normal Mapping有一定相似。只不过，法线贴图只为每个像素提供。而法线分布函数使用法线贴图和粗糙度贴图一起，提供了亚像素精度的细节。且传统法线贴图没有经过归一化处理，不满足能量守恒，容易出现失真。</p>
<p><strong>几何函数</strong>：</p>
<p>几何函数用于描述给定法线$\vec{n}$、视线$\vec{v}$和粗糙度$\alpha$时，反射光线被遮蔽的比率，它是实现PBR能量守恒的核心。比如：$G(\vec{n}, \vec{v}, k)=\frac{\vec{n}<em>\vec{v}}{(\vec{n}</em>\vec{v})(1-k)+k}$。</p>
<p>其中，k是针对粗糙度的重映射(Remapping)，取决于我们要用的是针对直接光照还是针对IBL光照的几何函数。</p>
<p>$$
k_{direct}=\frac{(\alpha+1)^2}{8}\
k_{ibl}=\frac{\alpha^2}{2}
$$</p>
<h3 id=disney-principled-brdf>Disney Principled BRDF</h3>
<p>迪士尼动画工作室在SIGGRAPH 2012上著名的talk《Physically-based shading at Disney》中提出了迪士尼原则的BRDF（Disney Principled BRDF），奠定了后续游戏行业和电影行业PBR的方向和标准。它的核心贡献其实是避免了过去PBR中复杂晦涩物理参数，而引入了一系列直观的参数，包括：用于表示表示材料吸收光的金属度（metallic）和用于表示材料镜面反射集中度的粗糙度（roughness）等。</p>
<p><strong>漫反射/镜面反射的比例</strong>：</p>
<p>在Cook-Torrance BRDF中，$k_d$和$k_s$参数分别表示了漫反射和镜面反射的比例。将它们用菲涅尔项和金属度（能够反映折射部分，也就是被金属吸收的部分）表示如下：</p>
<p>$$
k_d=(1-F)*(1-metallic)\
k_s=F
$$</p>
<p>换句话说，Cook-Torrance BRDF可改写为</p>
<p>$$
\begin{align}
f_r =& k_df_{lambert}+k_sf_{cook-torrance}\
=& (1-F)<em>(1-metallic)\frac\rho\pi+F\frac{DG}{4(\vec{w_o}</em>\vec{n})(\vec{w_i}*\vec{n})}<br>
\end{align}
$$</p>
<p><strong>PBR常见材料/纹理</strong>：</p>
<p><figure>
<img src=https://zhytou.github.io/post/2024-8-1/pbr_textures.png alt=PBR纹理列表>
</figure></p>
<p>对美工来说，PBR一般右两种材质工作流：金属/粗糙度工作流（Metal/Roughness）和镜面反射/光泽度工作流（Specular/Glossiness）。它们的目的都是进行PBR渲染，获取尽可能真实的渲染效果，即一体两面。</p>
<p>其中，金属度/粗错度工作流需要三张贴图来表示PBR需要的参数：</p>
<ul>
<li>albedo/baseColor：每个Texel表示对应位置的表面颜色，且不包含任何光影信息。</li>
<li>metallic：每个Texel表示对应位置金属成分的占比，1表示100%的纯金属，0表示100%的非金属。</li>
<li>roughness：每个Texel表示对应位置粗糙程度。越粗糙，该位置镜面反射光线越分散，光泽程度越低。</li>
</ul>
<p>类似的，镜面反射/光泽度工作流也需要三张贴图表示PBR所需参数：</p>
<ul>
<li>diffuse/albedo：每个Texel表示对应位置的表面颜色。</li>
<li>specular：每个Texel表示对应位置的$F_0$，即入射角为0°时的菲涅尔系数。</li>
<li>glossiness：每个Texel表示对应位置粗糙程度。</li>
</ul>
<h3 id=linear-space-and-tone-mapping>Linear Space and Tone Mapping</h3>
<blockquote>
<p><a href=https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/#hdr target=_blank>learnopengl中关于线性空间和HDR的介绍</a></p>
</blockquote>
<p><strong>线性空间</strong>：</p>
<p>在渲染中，颜色值的计算总是发生在线性空间中的。因为，线性空间中的颜色计算才是正确的。然而人眼对亮度的感知是非线性的，所以为了更好的利用表示颜色带宽，所以引入了Gama矫正。因此，在渲染时，也需要将输出颜色给进行Gama矫正。</p>
<p><strong>色调调整</strong>：</p>
<p>一般来说，当存储在帧缓冲（Framebuffer）中时，亮度和颜色的值是默认被限制在0.0到1.0之间的。换句话说，显示器只能显示值为0.0到1.0间的颜色。然而，光照方程中却没有这个限制。当片段颜色超过1.0时，被称作HDR（High Dynamic Range, 高动态范围）。与之相对的，处于0.0到1.0的颜色则被称为标准动态范围（LDR，Low Dynamic Range）。</p>
<p>在实时渲染中，使用HDR记录颜色信息是很重要的，因为它允许片段保留更多的细节，同时还让我们能够根据光源的真实强度指定它的强度。不过，由于显示器只能显示LDR范围的颜色，将计算得到的HDR结果转换为LDR颜色就是一个必要过程，即色调映射。</p>
<p>色调映射（Tone Mapping）是一个损失很小的转换浮点颜色值至我们所需的LDR[0.0, 1.0]范围内的过程。最简单的色调映射算法是Reinhard色调映射，它涉及到分散整个HDR颜色值到LDR颜色值上，所有的值都有对应。比如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GLSL data-lang=GLSL><span style=color:#080;font-weight:700>void</span> main()
{             
  <span style=color:#080;font-weight:700>const</span> <span style=color:#080;font-weight:700>float</span> gamma <span style=color:#333>=</span> <span style=color:#60e;font-weight:700>2.2</span>;
  <span style=color:#080;font-weight:700>vec3</span> hdrColor <span style=color:#333>=</span> texture(hdrBuffer, TexCoords).rgb;

  <span style=color:#888>// Reinhard色调映射</span>
  <span style=color:#080;font-weight:700>vec3</span> mapped <span style=color:#333>=</span> hdrColor <span style=color:#333>/</span> (hdrColor <span style=color:#333>+</span> <span style=color:#080;font-weight:700>vec3</span>(<span style=color:#60e;font-weight:700>1.0</span>));
  <span style=color:#888>// Gamma校正</span>
  mapped <span style=color:#333>=</span> pow(mapped, <span style=color:#080;font-weight:700>vec3</span>(<span style=color:#60e;font-weight:700>1.0</span> <span style=color:#333>/</span> gamma));

  color <span style=color:#333>=</span> <span style=color:#080;font-weight:700>vec4</span>(mapped, <span style=color:#60e;font-weight:700>1.0</span>);
}   
</code></pre></div><h3 id=pbr-implementation>PBR Implementation</h3>
<blockquote>
<p><a href=https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/ target=_blank>learnopengl中关于使用opengl实现一个PBR着色器</a></p>
</blockquote>
<h3 id=pbr-giibl>PBR GI——IBL</h3>
<blockquote>
<p><a href=https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/ target=_blank>learnopengl中漫反射IBL</a>
<a href=https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/ target=_blank>learnopengl中镜面反射IBL</a></p>
</blockquote>
<h2 id=ray-tracing>Ray Tracing</h2>
<h3 id=collision-detection>Collision detection</h3>
<p>记光线起点为 $\mathbf{O}$，方向为单位向量 $\mathbf{D}$，则射线上任意点可表示为：<br>
$$ \mathbf{R}(t) = \mathbf{O} + t\mathbf{D} \quad (t \geq 0) $$</p>
<p><strong>三角形</strong>：</p>
<p>给定三角形的三个顶点 $\mathbf{V_0}, \mathbf{V_1}, \mathbf{V_2}$，那么三角形确定的平面法向量 $\mathbf{N}$ 可通过叉乘计算：</p>
<p>$$ \mathbf{N} = (\mathbf{V_1} - \mathbf{V_0}) \times (\mathbf{V_2} - \mathbf{V_0}) $$</p>
<p>进一步，可确定此平面方程为：</p>
<p>$$ (\mathbf{P} - \mathbf{V_0}) \cdot \mathbf{N} = 0 $$</p>
<p>将射线方程代入平面方程：</p>
<p>$$ (\mathbf{O} + t\mathbf{D} - \mathbf{V_0}) \cdot \mathbf{N} = 0 $$</p>
<p>解得：</p>
<p>$$ t = \frac{(\mathbf{V_0} - \mathbf{O}) \cdot \mathbf{N}}{\mathbf{D} \cdot \mathbf{N}} $$</p>
<ul>
<li>若分母 $\mathbf{D} \cdot \mathbf{N} \approx 0$，射线与平面平行（无交点）；</li>
<li>若 $t &lt; 0$，交点在射线反方向。</li>
</ul>
<p>此时，只需判断该交点是否在三角形内部，即可确认射线与三角形是否发生碰撞。</p>
<p>具体来说，可以使用重心法确认，即将交点表示为三个顶点的线性组合：</p>
<p>记
$$ \mathbf{e_1} = \mathbf{V_1} - \mathbf{V_0}, \quad \mathbf{e_2} = \mathbf{V_2} - \mathbf{V_0}, \quad \mathbf{OP} = \mathbf{P} - \mathbf{V_0} $$</p>
<p>那么$\mathbf{OP}$可表示为 $\mathbf{e_1}$ 和 $\mathbf{e_2}$ 的线性组合：<br>
$$ \mathbf{OP} = u\mathbf{e_1} + v\mathbf{e_2} $$</p>
<p>求出$u$和$v$，若 $u \geq 0, v \geq 0, u + v \leq 1$，则交点在三角形内部。</p>
<p><strong>AABB</strong>：</p>
<h3 id=scene-management>Scene Management</h3>
<p><strong>Octree</strong>：</p>
<p>八叉树（Octree）是三维空间划分的数据结构之一，它用于加速空间查询。简单来说，八叉树的空间划分方式是，把一个立方体分割为八个小立法体，然后递归地分割小立方体。</p>
<p><figure>
<img src=https://en.wikipedia.org/wiki/Octree#/media/File:Octree2.svg alt=octree>
</figure></p>
<p><strong>BVH</strong>:</p>
<p>包围体积层次结构（Bounding Volume Hierarchy, BVH）是一种用于加速射线追踪的数据结构。BVH的基本思想是，将场景中的物体划分为一个个包围盒，然后递归地将这些包围盒划分为更小的包围盒，直到达到某个终止条件。</p>
<p><strong>SAH</strong>:</p>
<p>表面积启发算法（Surface Area Heuristics, SAH）通过改变包围盒的划分位置从而最小化光线遍历代价的一种优化方法。其具体实现往往是定义一个代价函数，然后通过枚举所有可能的划分位置，找到最小代价的划分位置。其中，代价函数一般包括两部分：遍历代价和划分代价。最常见的代价函数为，扫描线穿过包围盒的代价为1，包围盒划分代价为0.125。</p>
<h2 id=references>References</h2>
<ul>
<li><a href=https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html target=_blank>GAMES101: 现代计算机图形学入门</a></li>
<li><a href=https://blog.csdn.net/motarookie/category_11510961.html target=_blank>CSDN GAMES101学习笔记</a></li>
<li><a href=https://learnopengl-cn.github.io/ target=_blank>LearnOpenGL</a></li>
<li><a href=https://zhuanlan.zhihu.com/p/430541328 target=_blank>知乎 图形学基础</a></li>
</ul>
</div>
</div>
</article>
</div>
</main>
<footer>
© Copyright <a href=https://github.com/Zhytou>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae>Vitae</a> theme for <a href=https://gohugo.io>Hugo</a>
</footer><script src=/js/dark-mode.js></script>
</body>
</html>
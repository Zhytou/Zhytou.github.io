<!doctype html><html lang=en><head><meta charset=UTF-8><title>C++实现反射 | Zhytou</title>
<meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Hugo 0.121.0"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><meta property="og:title" content="C++实现反射"><meta property="og:description" content="最近在实习的过程中，老板要求写一个回测系统。其大致工作模式就是hft-sys写死，会动态链接加载不同model，通过model类名实例化对象并调用内部函数。因此，整个的难点其实就是动态链接+反射。这篇博客就记录一下自己在网上查到的资料以及相关实践。
总的来说，C++实现发射的方法包括：
侵入式 运行时 编译期 侵入式 侵入式的做法其实有些类似Qt，在需要支持反射的类定义中添加宏，从而引入一系列帮助系统确认类型的metadata。
其原理也非常容易理解，使用一个全局Map管理类名和其构造函数的键值对，并用宏帮助注册。
// reflect.h using ModelConstructorFn = Model *(*) (); // 用于保存Model Info的全局Map map<string, ModelConstructorFn> miMap; // ModelInfo类，用于保存模型信息 struct ModelInfo { ModelInfo(const string& name, ObjectConstructorFn ctor): name_(name), ctor_(ctor) { if (miMap.find(name) == miMap.end()) { miMap[name] = ctor; } } ~ModelInfo() {} string name_; ModelConstructorFn ctor_; }; #define DECLARE_MODEL(name) \ protected: \ static ModelInfo model_info_; \ public: \ static Model* CreateModel(); #define IMPLEMENT_MODEL(name) \ ModelInfo name::model_info_(#name, (ModelConstructorFn) name::CreateModel);\ Model* name::CreateModel() { \ return new name; \ } // model."><meta property="og:type" content="article"><meta property="og:url" content="https://zhytou.github.io/post/2023-10-27/cpp-reflect/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-10-27T15:17:54+08:00"><meta property="article:modified_time" content="2023-10-27T15:17:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++实现反射"><meta name=twitter:description content="最近在实习的过程中，老板要求写一个回测系统。其大致工作模式就是hft-sys写死，会动态链接加载不同model，通过model类名实例化对象并调用内部函数。因此，整个的难点其实就是动态链接+反射。这篇博客就记录一下自己在网上查到的资料以及相关实践。
总的来说，C++实现发射的方法包括：
侵入式 运行时 编译期 侵入式 侵入式的做法其实有些类似Qt，在需要支持反射的类定义中添加宏，从而引入一系列帮助系统确认类型的metadata。
其原理也非常容易理解，使用一个全局Map管理类名和其构造函数的键值对，并用宏帮助注册。
// reflect.h using ModelConstructorFn = Model *(*) (); // 用于保存Model Info的全局Map map<string, ModelConstructorFn> miMap; // ModelInfo类，用于保存模型信息 struct ModelInfo { ModelInfo(const string& name, ObjectConstructorFn ctor): name_(name), ctor_(ctor) { if (miMap.find(name) == miMap.end()) { miMap[name] = ctor; } } ~ModelInfo() {} string name_; ModelConstructorFn ctor_; }; #define DECLARE_MODEL(name) \ protected: \ static ModelInfo model_info_; \ public: \ static Model* CreateModel(); #define IMPLEMENT_MODEL(name) \ ModelInfo name::model_info_(#name, (ModelConstructorFn) name::CreateModel);\ Model* name::CreateModel() { \ return new name; \ } // model."><meta itemprop=name content="C++实现反射"><meta itemprop=description content="最近在实习的过程中，老板要求写一个回测系统。其大致工作模式就是hft-sys写死，会动态链接加载不同model，通过model类名实例化对象并调用内部函数。因此，整个的难点其实就是动态链接+反射。这篇博客就记录一下自己在网上查到的资料以及相关实践。
总的来说，C++实现发射的方法包括：
侵入式 运行时 编译期 侵入式 侵入式的做法其实有些类似Qt，在需要支持反射的类定义中添加宏，从而引入一系列帮助系统确认类型的metadata。
其原理也非常容易理解，使用一个全局Map管理类名和其构造函数的键值对，并用宏帮助注册。
// reflect.h using ModelConstructorFn = Model *(*) (); // 用于保存Model Info的全局Map map<string, ModelConstructorFn> miMap; // ModelInfo类，用于保存模型信息 struct ModelInfo { ModelInfo(const string& name, ObjectConstructorFn ctor): name_(name), ctor_(ctor) { if (miMap.find(name) == miMap.end()) { miMap[name] = ctor; } } ~ModelInfo() {} string name_; ModelConstructorFn ctor_; }; #define DECLARE_MODEL(name) \ protected: \ static ModelInfo model_info_; \ public: \ static Model* CreateModel(); #define IMPLEMENT_MODEL(name) \ ModelInfo name::model_info_(#name, (ModelConstructorFn) name::CreateModel);\ Model* name::CreateModel() { \ return new name; \ } // model."><meta itemprop=datePublished content="2023-10-27T15:17:54+08:00"><meta itemprop=dateModified content="2023-10-27T15:17:54+08:00"><meta itemprop=wordCount content="294"><meta itemprop=keywords content></head><body><header><div id=avatar><a href=https://zhytou.github.io/><img src=https://avatars.githubusercontent.com/u/56868292 alt=Zhytou></a></div><div id=titletext><h2 id=title><a href=https://zhytou.github.io/>Zhytou</a></h2></div><div id=title-description><p id=subtitle>May the force be with me.</p><div id=social><nav><ul><li><a href=https://github.com/Zhytou rel=me><i title=Github class="icons fab fa-github"></i></a></li><li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>Posts</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>27</span>
<span class=rest>Oct 2023</span></div></div><div class=matter><h1 class=title>C++实现反射</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><p>最近在实习的过程中，老板要求写一个回测系统。其大致工作模式就是hft-sys写死，会动态链接加载不同model，通过model类名实例化对象并调用内部函数。因此，整个的难点其实就是动态链接+反射。这篇博客就记录一下自己在网上查到的资料以及相关实践。</p><p>总的来说，C++实现发射的方法包括：</p><ul><li>侵入式</li><li>运行时</li><li>编译期</li></ul><h2 id=侵入式>侵入式</h2><p>侵入式的做法其实有些类似Qt，在需要支持反射的类定义中添加宏，从而引入一系列帮助系统确认类型的metadata。</p><p>其原理也非常容易理解，使用一个全局Map管理类名和其构造函数的键值对，并用宏帮助注册。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// reflect.h
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>using</span> ModelConstructorFn <span style=color:#333>=</span> Model <span style=color:#333>*</span>(<span style=color:#333>*</span>) ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// 用于保存Model Info的全局Map
</span></span></span><span style=display:flex><span><span style=color:#888></span>map<span style=color:#333>&lt;</span>string, ModelConstructorFn<span style=color:#333>&gt;</span> miMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// ModelInfo类，用于保存模型信息
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>ModelInfo</span> {
</span></span><span style=display:flex><span>    ModelInfo(<span style=color:#080;font-weight:700>const</span> string<span style=color:#333>&amp;</span> name, ObjectConstructorFn ctor)<span style=color:#333>:</span>
</span></span><span style=display:flex><span>      name_(name), ctor_(ctor) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (miMap.find(name) <span style=color:#333>==</span> miMap.end()) {
</span></span><span style=display:flex><span>            miMap[name] <span style=color:#333>=</span> ctor;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#333>~</span>ModelInfo() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    string name_;
</span></span><span style=display:flex><span>    ModelConstructorFn ctor_;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#579>#define DECLARE_MODEL(name) \
</span></span></span><span style=display:flex><span><span style=color:#579>  protected: \
</span></span></span><span style=display:flex><span><span style=color:#579>    static ModelInfo model_info_; \
</span></span></span><span style=display:flex><span><span style=color:#579>  public: \
</span></span></span><span style=display:flex><span><span style=color:#579>    static Model* CreateModel();
</span></span></span><span style=display:flex><span><span style=color:#579></span>
</span></span><span style=display:flex><span><span style=color:#579>#define IMPLEMENT_MODEL(name) \
</span></span></span><span style=display:flex><span><span style=color:#579>  ModelInfo name::model_info_(#name, (ModelConstructorFn) name::CreateModel);\
</span></span></span><span style=display:flex><span><span style=color:#579>  Model* name::CreateModel() { \
</span></span></span><span style=display:flex><span><span style=color:#579>    return new name; \
</span></span></span><span style=display:flex><span><span style=color:#579>  }
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// model.h
</span></span></span><span style=display:flex><span><span style=color:#888>// 基类Model
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Model</span> {
</span></span><span style=display:flex><span> <span style=color:#080;font-weight:700>public</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>    Model() {}
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>virtual</span> <span style=color:#333>~</span>Model() {}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#888>// 接口
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#080;font-weight:700>virtual</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>OnQuote</span>(<span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span>) <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>// model_cta.cc
</span></span></span><span style=display:flex><span><span style=color:#888>// 需要支持反射的子类
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>ModelCTA</span> <span style=color:#333>:</span> <span style=color:#080;font-weight:700>public</span> Model {
</span></span><span style=display:flex><span>    DECLARE_MODEL(ModelCTA)
</span></span><span style=display:flex><span> <span style=color:#080;font-weight:700>public</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>void</span> OnQuote(<span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span>) {
</span></span><span style=display:flex><span>        <span style=color:#888>// ...
</span></span></span><span style=display:flex><span><span style=color:#888></span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IMPLEMENT_MODEL(ModelCTA)
</span></span></code></pre></div><p>从上面的例子我们可以看到，通过宏DECLARE_MODEL在子类中额外定义了一个静态变量model_info_和CreateModel函数。由于静态变量的特性，它会在main函数之前初始化，即：会执行其构造函数中<code>miMap[name] = ctor;</code>的操作，以达成向miMap中注册信息的目的。当然，这只是最简单的反射，它还存在很多局限性，包括：无法根据类名动态的判断其内部属性是否存在（python getattr操作）、无法使用带参数的构造函数等。</p><h2 id=运行时>运行时</h2><p>事实上，仔细观察侵入式反射的例子，对于只是希望根据类名创建对象来说，其中的MapInfo类其实可以省略。只要找到某种机制向miMap写入键值对即可。由此便有了下面这种方法:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// modelfactory.h
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Model</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> ModelConstructorFn <span style=color:#333>=</span> Model <span style=color:#333>*</span>(<span style=color:#333>*</span>) ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>ModelFactory</span> {
</span></span><span style=display:flex><span> <span style=color:#080;font-weight:700>public</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>static</span> ModelFactory <span style=color:#333>*</span>GetInstance();
</span></span><span style=display:flex><span>    Model <span style=color:#333>*</span><span style=color:#06b;font-weight:700>Create</span>(<span style=color:#080;font-weight:700>const</span> string <span style=color:#333>&amp;</span>name) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (miMap_ <span style=color:#333>==</span> <span style=color:#080;font-weight:700>nullptr</span>) {
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>return</span> <span style=color:#080;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>auto</span> iter <span style=color:#333>=</span> miMap_<span style=color:#333>-&gt;</span>find(name);
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (miMap_<span style=color:#333>-&gt;</span>end() <span style=color:#333>!=</span> iter) {
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>return</span> iter<span style=color:#333>-&gt;</span>second();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>return</span> <span style=color:#080;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>bool</span> <span style=color:#06b;font-weight:700>Register</span>(<span style=color:#080;font-weight:700>const</span> string <span style=color:#333>&amp;</span>name, ModelConstructorFn constructor) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (miMap_ <span style=color:#333>==</span> <span style=color:#080;font-weight:700>nullptr</span>) {
</span></span><span style=display:flex><span>            miMap_ <span style=color:#333>=</span> <span style=color:#080;font-weight:700>new</span> map<span style=color:#333>&lt;</span>string, ModelConstructorFn<span style=color:#333>&gt;</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>auto</span> iter <span style=color:#333>=</span> miMap_<span style=color:#333>-&gt;</span>find(name);
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> (miMap_<span style=color:#333>-&gt;</span>end() <span style=color:#333>==</span> iter) {
</span></span><span style=display:flex><span>            miMap_<span style=color:#333>-&gt;</span>emplace(name, ctor);
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>return</span> <span style=color:#007020>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>return</span> <span style=color:#007020>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#080;font-weight:700>private</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>    ModelFactory() {}
</span></span><span style=display:flex><span>    <span style=color:#333>~</span>ModelFactory() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>static</span> ModelFactory <span style=color:#333>*</span>instance_;
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>static</span> map<span style=color:#333>&lt;</span>string, ModelConstructorFn<span style=color:#333>&gt;</span> <span style=color:#333>*</span>miMap_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888>// model_cta.cc
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>ModelCTA</span> <span style=color:#333>:</span> <span style=color:#080;font-weight:700>public</span> Model {
</span></span><span style=display:flex><span>    DECLARE_MODEL(ModelCTA)
</span></span><span style=display:flex><span> <span style=color:#080;font-weight:700>public</span><span style=color:#333>:</span>
</span></span><span style=display:flex><span>    <span style=color:#339;font-weight:700>void</span> OnQuote(<span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span>) {
</span></span><span style=display:flex><span>        <span style=color:#888>// ...
</span></span></span><span style=display:flex><span><span style=color:#888></span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>RegitserHelper</span> {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>struct</span> <span style=color:#06b;font-weight:700>RegitserHelper</span>(string name, ModelConstructorFn ctor) {
</span></span><span style=display:flex><span>        ModelFactory <span style=color:#333>*</span>mf <span style=color:#333>=</span> ModelFactory<span style=color:#333>::</span>GetInstance();
</span></span><span style=display:flex><span>        mf<span style=color:#333>-&gt;</span>Register(name, ctor);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>static</span> <span style=color:#06b;font-weight:700>RegitserHelperregister_modelcta_helper</span>(<span style=background-color:#fff0f0>&#34;ModelCTA&#34;</span>, []() <span style=color:#333>-&gt;</span> Model <span style=color:#333>*</span> { <span style=color:#080;font-weight:700>return</span> <span style=color:#080;font-weight:700>new</span> ModelCTA(); });
</span></span></code></pre></div><p>为了替代RegisterHelper类，我们可以利用gcc constructor特性使得某个函数在main函数之前运行，从而达成注册Model的目的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>__attribute__((constructor)) <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> initilize() {
</span></span><span style=display:flex><span>    ModelFactory <span style=color:#333>*</span>mf <span style=color:#333>=</span> ModelFactory<span style=color:#333>::</span>GetInstance();
</span></span><span style=display:flex><span>    mf<span style=color:#333>-&gt;</span>Register(<span style=background-color:#fff0f0>&#34;ModelCTA&#34;</span>, []() <span style=color:#333>-&gt;</span> Model <span style=color:#333>*</span> { <span style=color:#080;font-weight:700>return</span> <span style=color:#080;font-weight:700>new</span> <span style=color:#06b;font-weight:700>ModelCTA</span>(); });
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=参考>参考</h2><p><figure><img src=https://netcan.github.io/2020/08/01/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0C-%E7%BC%96%E8%AF%91%E6%9C%9F%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84/ alt=如何优雅的实现C++编译器反射></figure></p></div></div></article></div></main><footer>© Copyright <a href=https://github.com/Zhytou target=_blank>Zhytou</a> | <a href=https://github.com/dataCobra/hugo-vitae target=_blank>Vitae</a> theme for <a href=https://gohugo.io target=_blank>Hugo</a></footer><script src=/js/dark-mode.js></script></body></html>